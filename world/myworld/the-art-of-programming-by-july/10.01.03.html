<!DOCTYPE HTML>
<html lang="zh-tw" >
    
    <head>
        
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <title>教你一步一步用c语言实现sift算法、下 | 编程之法：面试和算法心得</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 2.6.5">
        <meta name="author" content="wizardforcel">
        
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">
        
    <link rel="stylesheet" href="gitbook/style.css">
    
        
        <link rel="stylesheet" href="gitbook/plugins/gitbook-plugin-comment/plugin.css">
        
    
        
        <link rel="stylesheet" href="gitbook/plugins/gitbook-plugin-highlight/website.css">
        
    
        
        <link rel="stylesheet" href="gitbook/plugins/gitbook-plugin-search/search.css">
        
    
        
        <link rel="stylesheet" href="gitbook/plugins/gitbook-plugin-fontsettings/website.css">
        
    
    

        
    
    
    <link rel="next" href="./part4.html" />
    
    
    <link rel="prev" href="./10.01.02.html" />
    

        
    </head>
    <body>
        
        
    <div class="book"
        data-level="13.3"
        data-chapter-title="教你一步一步用c语言实现sift算法、下"
        data-filepath="10.01.03.md"
        data-basepath="."
        data-revision="Thu Jan 14 2016 10:53:03 GMT+0000 (UTC)"
        data-innerlanguage="">
    

<div class="book-summary">
    <nav role="navigation">
        <ul class="summary">
            
            
            
                
                <li>
                    <a href="https://www.gitbook.com/book/wizardforcel/the-art-of-programming-by-july" target="blank" class="custom-link">编程之法：面试和算法心得</a>
                </li>
            
            

            
            <li class="divider"></li>
            

            
    
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="./index.html">
                
                        <i class="fa fa-check"></i>
                        
                        介紹
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="1" data-path="00.01.html">
            
                
                    <a href="./00.01.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                        程序员如何准备面试中的算法
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="2" data-path="part1.html">
            
                
                    <a href="./part1.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                        第一部分 数据结构
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="3" data-path="ch1.html">
            
                
                    <a href="./ch1.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                        第一章 字符串
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.1" data-path="01.00.html">
            
                
                    <a href="./01.00.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.1.</b>
                        
                        1.0 本章导读
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="01.01.html">
            
                
                    <a href="./01.01.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.2.</b>
                        
                        1.1 旋转字符串
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="01.02.html">
            
                
                    <a href="./01.02.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.3.</b>
                        
                        1.2 字符串包含
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="3.4" data-path="01.03.html">
            
                
                    <a href="./01.03.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.4.</b>
                        
                        1.3 字符串转换成整数
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="3.5" data-path="01.04.html">
            
                
                    <a href="./01.04.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.5.</b>
                        
                        1.4 回文判断
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="3.6" data-path="01.05.html">
            
                
                    <a href="./01.05.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.6.</b>
                        
                        1.5 最长回文子串
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="3.7" data-path="01.06.html">
            
                
                    <a href="./01.06.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.7.</b>
                        
                        1.6 字符串的全排列
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="3.8" data-path="01.10.html">
            
                
                    <a href="./01.10.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.8.</b>
                        
                        1.10 本章习题
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="4" data-path="ch2.html">
            
                
                    <a href="./ch2.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                        第二章 数组
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1" data-path="02.00.html">
            
                
                    <a href="./02.00.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.1.</b>
                        
                        2.0 本章导读
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="02.01.html">
            
                
                    <a href="./02.01.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.2.</b>
                        
                        2.1 寻找最小的 k 个数
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="02.02.html">
            
                
                    <a href="./02.02.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.3.</b>
                        
                        2.2 寻找和为定值的两个数
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="4.4" data-path="02.03.html">
            
                
                    <a href="./02.03.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.4.</b>
                        
                        2.3 寻找和为定值的多个数
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="4.5" data-path="02.04.html">
            
                
                    <a href="./02.04.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.5.</b>
                        
                        2.4 最大连续子数组和
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="4.6" data-path="02.05.html">
            
                
                    <a href="./02.05.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.6.</b>
                        
                        2.5 跳台阶
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="4.7" data-path="02.06.html">
            
                
                    <a href="./02.06.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.7.</b>
                        
                        2.6 奇偶排序
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="4.8" data-path="02.07.html">
            
                
                    <a href="./02.07.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.8.</b>
                        
                        2.7 荷兰国旗
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="4.9" data-path="02.08.html">
            
                
                    <a href="./02.08.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.9.</b>
                        
                        2.8 矩阵相乘
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="4.10" data-path="02.09.html">
            
                
                    <a href="./02.09.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.10.</b>
                        
                        2.9 完美洗牌
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="4.11" data-path="02.15.html">
            
                
                    <a href="./02.15.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.11.</b>
                        
                        2.15 本章习题
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="5" data-path="ch3.html">
            
                
                    <a href="./ch3.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>5.</b>
                        
                        第三章 树
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="5.1" data-path="03.00.html">
            
                
                    <a href="./03.00.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>5.1.</b>
                        
                        3.0 本章导读
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="5.2" data-path="03.01.html">
            
                
                    <a href="./03.01.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>5.2.</b>
                        
                        3.1 红黑树
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="5.3" data-path="03.02.html">
            
                
                    <a href="./03.02.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>5.3.</b>
                        
                        3.2 B树
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="5.4" data-path="03.03.html">
            
                
                    <a href="./03.03.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>5.4.</b>
                        
                        3.3 最近公共祖先LCA
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="5.5" data-path="03.10.html">
            
                
                    <a href="./03.10.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>5.5.</b>
                        
                        3.10 本章习题
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="6" data-path="part2.html">
            
                
                    <a href="./part2.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>6.</b>
                        
                        第二部分 算法心得
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="7" data-path="ch4.html">
            
                
                    <a href="./ch4.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>7.</b>
                        
                        第四章 查找匹配
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="7.1" data-path="04.01.html">
            
                
                    <a href="./04.01.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>7.1.</b>
                        
                        4.1 有序数组的查找
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="7.2" data-path="04.02.html">
            
                
                    <a href="./04.02.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>7.2.</b>
                        
                        4.2 行列递增矩阵的查找
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="7.3" data-path="04.03.html">
            
                
                    <a href="./04.03.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>7.3.</b>
                        
                        4.3 出现次数超过一半的数字
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="8" data-path="ch5.html">
            
                
                    <a href="./ch5.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>8.</b>
                        
                        第五章 动态规划
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="8.1" data-path="05.00.html">
            
                
                    <a href="./05.00.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>8.1.</b>
                        
                        5.0 本章导读
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="8.2" data-path="05.01.html">
            
                
                    <a href="./05.01.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>8.2.</b>
                        
                        5.1 最大连续乘积子串
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="8.3" data-path="05.02.html">
            
                
                    <a href="./05.02.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>8.3.</b>
                        
                        5.2 字符串编辑距离
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="8.4" data-path="05.03.html">
            
                
                    <a href="./05.03.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>8.4.</b>
                        
                        5.3 格子取数
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="8.5" data-path="05.04.html">
            
                
                    <a href="./05.04.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>8.5.</b>
                        
                        5.4 交替字符串
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="8.6" data-path="05.10.html">
            
                
                    <a href="./05.10.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>8.6.</b>
                        
                        5.10 本章习题
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="9" data-path="part3.html">
            
                
                    <a href="./part3.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>9.</b>
                        
                        第三部分 综合演练
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="10" data-path="ch6.html">
            
                
                    <a href="./ch6.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>10.</b>
                        
                        第六章 海量数据处理
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="10.1" data-path="06.00.html">
            
                
                    <a href="./06.00.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>10.1.</b>
                        
                        6.0 本章导读
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="10.2" data-path="06.01.html">
            
                
                    <a href="./06.01.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>10.2.</b>
                        
                        6.1 关联式容器
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="10.3" data-path="06.02.html">
            
                
                    <a href="./06.02.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>10.3.</b>
                        
                        6.2 分而治之
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="10.4" data-path="06.03.html">
            
                
                    <a href="./06.03.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>10.4.</b>
                        
                        6.3 simhash算法
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="10.5" data-path="06.04.html">
            
                
                    <a href="./06.04.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>10.5.</b>
                        
                        6.4 外排序
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="10.6" data-path="06.05.html">
            
                
                    <a href="./06.05.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>10.6.</b>
                        
                        6.5 MapReduce
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="10.7" data-path="06.06.html">
            
                
                    <a href="./06.06.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>10.7.</b>
                        
                        6.6 多层划分
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="10.8" data-path="06.07.html">
            
                
                    <a href="./06.07.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>10.8.</b>
                        
                        6.7 Bitmap
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="10.9" data-path="06.08.html">
            
                
                    <a href="./06.08.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>10.9.</b>
                        
                        6.8 Bloom filter
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="10.10" data-path="06.09.html">
            
                
                    <a href="./06.09.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>10.10.</b>
                        
                        6.9 Trie树
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="10.11" data-path="06.10.html">
            
                
                    <a href="./06.10.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>10.11.</b>
                        
                        6.10 数据库
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="10.12" data-path="06.11.html">
            
                
                    <a href="./06.11.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>10.12.</b>
                        
                        6.11 倒排索引
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="10.13" data-path="06.15.html">
            
                
                    <a href="./06.15.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>10.13.</b>
                        
                        6.15 本章习题
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="11" data-path="ch7.html">
            
                
                    <a href="./ch7.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>11.</b>
                        
                        第七章 机器学习
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="11.1" data-path="07.01.html">
            
                
                    <a href="./07.01.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>11.1.</b>
                        
                        7.1 K 近邻算法
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="11.2" data-path="07.02.svm.html">
            
                
                    <a href="./07.02.svm.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>11.2.</b>
                        
                        7.2 支持向量机
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="12" data-path="ch8.html">
            
                
                    <a href="./ch8.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>12.</b>
                        
                        附录 更多题型
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="12.1" data-path="08.00.html">
            
                
                    <a href="./08.00.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>12.1.</b>
                        
                        附录A 语言基础
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="12.2" data-path="08.01.html">
            
                
                    <a href="./08.01.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>12.2.</b>
                        
                        附录B 概率统计
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="12.3" data-path="08.02.html">
            
                
                    <a href="./08.02.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>12.3.</b>
                        
                        附录C 智力逻辑
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="12.4" data-path="08.03.html">
            
                
                    <a href="./08.03.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>12.4.</b>
                        
                        附录D 系统设计
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="12.5" data-path="08.04.html">
            
                
                    <a href="./08.04.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>12.5.</b>
                        
                        附录E 操作系统
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="12.6" data-path="08.05.html">
            
                
                    <a href="./08.05.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>12.6.</b>
                        
                        附录F 网络协议
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="13" data-path="ch10.html">
            
                
                    <a href="./ch10.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>13.</b>
                        
                        sift算法
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="13.1" data-path="10.01.01.html">
            
                
                    <a href="./10.01.01.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>13.1.</b>
                        
                        sift算法的编译与实现
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="13.2" data-path="10.01.02.html">
            
                
                    <a href="./10.01.02.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>13.2.</b>
                        
                        教你一步一步用c语言实现sift算法、上
                    </a>
            
            
        </li>
    
        <li class="chapter active" data-level="13.3" data-path="10.01.03.html">
            
                
                    <a href="./10.01.03.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>13.3.</b>
                        
                        教你一步一步用c语言实现sift算法、下
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="14" data-path="part4.html">
            
                
                    <a href="./part4.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.</b>
                        
                        其它
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="14.1" data-path="a.1.html">
            
                
                    <a href="./a.1.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.1.</b>
                        
                        40亿个数中快速查找
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="14.2" data-path="a.2.html">
            
                
                    <a href="./a.2.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.2.</b>
                        
                        hash表算法
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="14.3" data-path="a.3.html">
            
                
                    <a href="./a.3.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.3.</b>
                        
                        一致性哈希算法
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="14.4" data-path="a.4.html">
            
                
                    <a href="./a.4.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.4.</b>
                        
                        倒排索引关键词不重复Hash编码
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="14.5" data-path="a.5.html">
            
                
                    <a href="./a.5.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.5.</b>
                        
                        傅里叶变换算法、上
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="14.6" data-path="a.6.html">
            
                
                    <a href="./a.6.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.6.</b>
                        
                        傅里叶变换算法、下
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="14.7" data-path="a.7.html">
            
                
                    <a href="./a.7.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.7.</b>
                        
                        后缀树
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="14.8" data-path="a.8.html">
            
                
                    <a href="./a.8.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.8.</b>
                        
                        基于给定的文档生成倒排索引的编码与实践
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="14.9" data-path="a.9.html">
            
                
                    <a href="./a.9.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.9.</b>
                        
                        搜索关键词智能提示suggestion
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="14.10" data-path="a.10.html">
            
                
                    <a href="./a.10.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.10.</b>
                        
                        最小操作数
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="14.11" data-path="a.11.html">
            
                
                    <a href="./a.11.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.11.</b>
                        
                        最短摘要的生成
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="14.12" data-path="a.12.html">
            
                
                    <a href="./a.12.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.12.</b>
                        
                        最长公共子序列
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="14.13" data-path="a.13.html">
            
                
                    <a href="./a.13.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.13.</b>
                        
                        木块砌墙原稿
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="14.14" data-path="a.14.html">
            
                
                    <a href="./a.14.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.14.</b>
                        
                        附近地点搜索
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="14.15" data-path="a.15.html">
            
                
                    <a href="./a.15.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>14.15.</b>
                        
                        随机取出其中之一元素
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    


            
            <li class="divider"></li>
            <li>
                <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
                    本書使用 GitBook 釋出
                </a>
            </li>
            
        </ul>
    </nav>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header" role="navigation">
    <!-- Actions Left -->
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="./" >编程之法：面试和算法心得</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1" role="main">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-">
                    
                        <h1 id="&#x6559;&#x4F60;&#x4E00;&#x6B65;&#x4E00;&#x6B65;&#x7528;c&#x8BED;&#x8A00;&#x5B9E;&#x73B0;sift&#x7B97;&#x6CD5;&#x3001;&#x4E0B;">&#x6559;&#x4F60;&#x4E00;&#x6B65;&#x4E00;&#x6B65;&#x7528;c&#x8BED;&#x8A00;&#x5B9E;&#x73B0;sift&#x7B97;&#x6CD5;&#x3001;&#x4E0B;</h1>
<p>&#x672C;&#x6587;&#x63A5;&#x4E0A;&#xFF0C;<a href="10.01.02.html">&#x6559;&#x4F60;&#x4E00;&#x6B65;&#x4E00;&#x6B65;&#x7528;c&#x8BED;&#x8A00;&#x5B9E;&#x73B0;sift&#x7B97;&#x6CD5;&#x3001;&#x4E0A;</a>&#x800C;&#x6765;&#xFF1A;</p>
<h3 id="&#x51FD;&#x6570;&#x7F16;&#x5199;"><strong>&#x51FD;&#x6570;&#x7F16;&#x5199;</strong></h3>
<p>ok&#xFF0C;&#x63A5;&#x4E0A;&#x6587;&#xFF0C;&#x54B1;&#x4EEC;&#x4E00;&#x4E2A;&#x4E00;&#x4E2A;&#x7684;&#x6765;&#x7F16;&#x5199;main&#x51FD;&#x6570;&#x4E2D;&#x6240;&#x6D89;&#x53CA;&#x5230;&#x6240;&#x6709;&#x51FD;&#x6570;&#xFF0C;&#x8FD9;&#x4E5F;&#x662F;&#x672C;&#x6587;&#x7684;&#x5173;&#x952E;&#x90E8;&#x5206;&#xFF1A;</p>
<pre><code class="lang-c">//&#x4E0B;&#x91C7;&#x6837;&#x539F;&#x6765;&#x7684;&#x56FE;&#x50CF;&#xFF0C;&#x8FD4;&#x56DE;&#x7F29;&#x5C0F;2&#x500D;&#x5C3A;&#x5BF8;&#x7684;&#x56FE;&#x50CF;  
CvMat * halfSizeImage(CvMat * im)   
{  
    unsigned int i,j;  
    int w = im-&gt;cols/2;  
    int h = im-&gt;rows/2;   
    CvMat *imnew = cvCreateMat(h, w, CV_32FC1);  

#define Im(ROW,COL) ((float *)(im-&gt;data.fl + im-&gt;step/sizeof(float) *(ROW)))[(COL)]  
#define Imnew(ROW,COL) ((float *)(imnew-&gt;data.fl + imnew-&gt;step/sizeof(float) *(ROW)))[(COL)]  
    for ( j = 0; j &lt; h; j++)   
        for ( i = 0; i &lt; w; i++)   
            Imnew(j,i)=Im(j*2, i*2);  
    return imnew;  
}  

//&#x4E0A;&#x91C7;&#x6837;&#x539F;&#x6765;&#x7684;&#x56FE;&#x50CF;&#xFF0C;&#x8FD4;&#x56DE;&#x653E;&#x5927;2&#x500D;&#x5C3A;&#x5BF8;&#x7684;&#x56FE;&#x50CF;  
CvMat * doubleSizeImage(CvMat * im)   
{  
    unsigned int i,j;  
    int w = im-&gt;cols*2;  
    int h = im-&gt;rows*2;   
    CvMat *imnew = cvCreateMat(h, w, CV_32FC1);  

#define Im(ROW,COL) ((float *)(im-&gt;data.fl + im-&gt;step/sizeof(float) *(ROW)))[(COL)]  
#define Imnew(ROW,COL) ((float *)(imnew-&gt;data.fl + imnew-&gt;step/sizeof(float) *(ROW)))[(COL)]  

    for ( j = 0; j &lt; h; j++)   
        for ( i = 0; i &lt; w; i++)   
            Imnew(j,i)=Im(j/2, i/2);  

    return imnew;  
}  

//&#x4E0A;&#x91C7;&#x6837;&#x539F;&#x6765;&#x7684;&#x56FE;&#x50CF;&#xFF0C;&#x8FD4;&#x56DE;&#x653E;&#x5927;2&#x500D;&#x5C3A;&#x5BF8;&#x7684;&#x7EBF;&#x6027;&#x63D2;&#x503C;&#x56FE;&#x50CF;  
CvMat * doubleSizeImage2(CvMat * im)   
{  
    unsigned int i,j;  
    int w = im-&gt;cols*2;  
    int h = im-&gt;rows*2;   
    CvMat *imnew = cvCreateMat(h, w, CV_32FC1);  

#define Im(ROW,COL) ((float *)(im-&gt;data.fl + im-&gt;step/sizeof(float) *(ROW)))[(COL)]  
#define Imnew(ROW,COL) ((float *)(imnew-&gt;data.fl + imnew-&gt;step/sizeof(float) *(ROW)))[(COL)]  

    // fill every pixel so we don&apos;t have to worry about skipping pixels later  
    for ( j = 0; j &lt; h; j++)   
    {  
        for ( i = 0; i &lt; w; i++)   
        {  
            Imnew(j,i)=Im(j/2, i/2);  
        }  
    }  
    /* 
    A B C 
    E F G 
    H I J 
    pixels A C H J are pixels from original image 
    pixels B E G I F are interpolated pixels 
    */  
    // interpolate pixels B and I  
    for ( j = 0; j &lt; h; j += 2)  
        for ( i = 1; i &lt; w - 1; i += 2)  
            Imnew(j,i)=0.5*(Im(j/2, i/2)+Im(j/2, i/2+1));  
    // interpolate pixels E and G  
    for ( j = 1; j &lt; h - 1; j += 2)  
        for ( i = 0; i &lt; w; i += 2)  
            Imnew(j,i)=0.5*(Im(j/2, i/2)+Im(j/2+1, i/2));  
    // interpolate pixel F  
    for ( j = 1; j &lt; h - 1; j += 2)  
        for ( i = 1; i &lt; w - 1; i += 2)  
            Imnew(j,i)=0.25*(Im(j/2, i/2)+Im(j/2+1, i/2)+Im(j/2, i/2+1)+Im(j/2+1, i/2+1));  
    return imnew;  
}  

//&#x53CC;&#x7EBF;&#x6027;&#x63D2;&#x503C;&#xFF0C;&#x8FD4;&#x56DE;&#x50CF;&#x7D20;&#x95F4;&#x7684;&#x7070;&#x5EA6;&#x503C;  
float getPixelBI(CvMat * im, float col, float row)   
{  
    int irow, icol;  
    float rfrac, cfrac;  
    float row1 = 0, row2 = 0;  
    int width=im-&gt;cols;  
    int height=im-&gt;rows;  
#define ImMat(ROW,COL) ((float *)(im-&gt;data.fl + im-&gt;step/sizeof(float) *(ROW)))[(COL)]  

    irow = (int) row;  
    icol = (int) col;  

    if (irow &lt; 0 || irow &gt;= height  
        || icol &lt; 0 || icol &gt;= width)  
        return 0;  
    if (row &gt; height - 1)  
        row = height - 1;  
    if (col &gt; width - 1)  
        col = width - 1;  
    rfrac = 1.0 - (row - (float) irow);  
    cfrac = 1.0 - (col - (float) icol);  
    if (cfrac &lt; 1)   
    {  
        row1 = cfrac * ImMat(irow,icol) + (1.0 - cfrac) * ImMat(irow,icol+1);  
    }   
    else   
    {  
        row1 = ImMat(irow,icol);  
    }  
    if (rfrac &lt; 1)   
    {  
        if (cfrac &lt; 1)   
        {  
            row2 = cfrac * ImMat(irow+1,icol) + (1.0 - cfrac) * ImMat(irow+1,icol+1);  
        } else   
        {  
            row2 = ImMat(irow+1,icol);  
        }  
    }  
    return rfrac * row1 + (1.0 - rfrac) * row2;  
}  

//&#x77E9;&#x9635;&#x5F52;&#x4E00;&#x5316;  
void normalizeMat(CvMat* mat)   
{  
#define Mat(ROW,COL) ((float *)(mat-&gt;data.fl + mat-&gt;step/sizeof(float) *(ROW)))[(COL)]  
    float sum = 0;  

    for (unsigned int j = 0; j &lt; mat-&gt;rows; j++)   
        for (unsigned int i = 0; i &lt; mat-&gt;cols; i++)   
            sum += Mat(j,i);  
    for ( j = 0; j &lt; mat-&gt;rows; j++)   
        for (unsigned int i = 0; i &lt; mat-&gt;rows; i++)   
            Mat(j,i) /= sum;  
}  

//&#x5411;&#x91CF;&#x5F52;&#x4E00;&#x5316;  
void normalizeVec(float* vec, int dim)   
{  
    unsigned int i;  
    float sum = 0;  
    for ( i = 0; i &lt; dim; i++)  
        sum += vec[i];  
    for ( i = 0; i &lt; dim; i++)  
        vec[i] /= sum;  
}  

//&#x5F97;&#x5230;&#x5411;&#x91CF;&#x7684;&#x6B27;&#x5F0F;&#x957F;&#x5EA6;&#xFF0C;2-&#x8303;&#x6570;  
float GetVecNorm( float* vec, int dim )  
{  
    float sum=0.0;  
    for (unsigned int i=0;i&lt;dim;i++)  
        sum+=vec[i]*vec[i];  
    return sqrt(sum);  
}  

//&#x4EA7;&#x751F;1D&#x9AD8;&#x65AF;&#x6838;  
float* GaussianKernel1D(float sigma, int dim)   
{  

    unsigned int i;  
    //printf(&quot;GaussianKernel1D(): Creating 1x%d vector for sigma=%.3f gaussian kernel/n&quot;, dim, sigma);  

    float *kern=(float*)malloc( dim*sizeof(float) );  
    float s2 = sigma * sigma;  
    int c = dim / 2;  
    float m= 1.0/(sqrt(2.0 * CV_PI) * sigma);  
    double v;   
    for ( i = 0; i &lt; (dim + 1) / 2; i++)   
    {  
        v = m * exp(-(1.0*i*i)/(2.0 * s2)) ;  
        kern[c+i] = v;  
        kern[c-i] = v;  
    }  
    //   normalizeVec(kern, dim);  
    // for ( i = 0; i &lt; dim; i++)  
    //  printf(&quot;%f  &quot;, kern[i]);  
    //  printf(&quot;/n&quot;);  
    return kern;  
}  

//&#x4EA7;&#x751F;2D&#x9AD8;&#x65AF;&#x6838;&#x77E9;&#x9635;  
CvMat* GaussianKernel2D(float sigma)   
{  
    // int dim = (int) max(3.0f, GAUSSKERN * sigma);  
    int dim = (int) max(3.0f, 2.0 * GAUSSKERN *sigma + 1.0f);  
    // make dim odd  
    if (dim % 2 == 0)  
        dim++;  
    //printf(&quot;GaussianKernel(): Creating %dx%d matrix for sigma=%.3f gaussian/n&quot;, dim, dim, sigma);  
    CvMat* mat=cvCreateMat(dim, dim, CV_32FC1);  
#define Mat(ROW,COL) ((float *)(mat-&gt;data.fl + mat-&gt;step/sizeof(float) *(ROW)))[(COL)]  
    float s2 = sigma * sigma;  
    int c = dim / 2;  
    //printf(&quot;%d %d/n&quot;, mat.size(), mat[0].size());  
    float m= 1.0/(sqrt(2.0 * CV_PI) * sigma);  
    for (int i = 0; i &lt; (dim + 1) / 2; i++)   
    {  
        for (int j = 0; j &lt; (dim + 1) / 2; j++)   
        {  
            //printf(&quot;%d %d %d/n&quot;, c, i, j);  
            float v = m * exp(-(1.0*i*i + 1.0*j*j) / (2.0 * s2));  
            Mat(c+i,c+j) =v;  
            Mat(c-i,c+j) =v;  
            Mat(c+i,c-j) =v;  
            Mat(c-i,c-j) =v;  
        }  
    }  
    // normalizeMat(mat);  
    return mat;  
}  

//x&#x65B9;&#x5411;&#x50CF;&#x7D20;&#x5904;&#x4F5C;&#x5377;&#x79EF;  
float ConvolveLocWidth(float* kernel, int dim, CvMat * src, int x, int y)   
{  
#define Src(ROW,COL) ((float *)(src-&gt;data.fl + src-&gt;step/sizeof(float) *(ROW)))[(COL)]  
    unsigned int i;  
    float pixel = 0;  
    int col;  
    int cen = dim / 2;  
    //printf(&quot;ConvolveLoc(): Applying convoluation at location (%d, %d)/n&quot;, x, y);  
    for ( i = 0; i &lt; dim; i++)   
    {  
        col = x + (i - cen);  
        if (col &lt; 0)  
            col = 0;  
        if (col &gt;= src-&gt;cols)  
            col = src-&gt;cols - 1;  
        pixel += kernel[i] * Src(y,col);  
    }  
    if (pixel &gt; 1)  
        pixel = 1;  
    return pixel;  
}  

//x&#x65B9;&#x5411;&#x4F5C;&#x5377;&#x79EF;  
void Convolve1DWidth(float* kern, int dim, CvMat * src, CvMat * dst)   
{  
#define DST(ROW,COL) ((float *)(dst-&gt;data.fl + dst-&gt;step/sizeof(float) *(ROW)))[(COL)]  
    unsigned int i,j;  

    for ( j = 0; j &lt; src-&gt;rows; j++)   
    {  
        for ( i = 0; i &lt; src-&gt;cols; i++)   
        {  
            //printf(&quot;%d, %d/n&quot;, i, j);  
            DST(j,i) = ConvolveLocWidth(kern, dim, src, i, j);  
        }  
    }  
}  

//y&#x65B9;&#x5411;&#x50CF;&#x7D20;&#x5904;&#x4F5C;&#x5377;&#x79EF;  
float ConvolveLocHeight(float* kernel, int dim, CvMat * src, int x, int y)   
{  
#define Src(ROW,COL) ((float *)(src-&gt;data.fl + src-&gt;step/sizeof(float) *(ROW)))[(COL)]  
    unsigned int j;  
    float pixel = 0;  
    int cen = dim / 2;  
    //printf(&quot;ConvolveLoc(): Applying convoluation at location (%d, %d)/n&quot;, x, y);  
    for ( j = 0; j &lt; dim; j++)   
    {  
        int row = y + (j - cen);  
        if (row &lt; 0)  
            row = 0;  
        if (row &gt;= src-&gt;rows)  
            row = src-&gt;rows - 1;  
        pixel += kernel[j] * Src(row,x);  
    }  
    if (pixel &gt; 1)  
        pixel = 1;  
    return pixel;  
}  

//y&#x65B9;&#x5411;&#x4F5C;&#x5377;&#x79EF;  
void Convolve1DHeight(float* kern, int dim, CvMat * src, CvMat * dst)   
{  
#define Dst(ROW,COL) ((float *)(dst-&gt;data.fl + dst-&gt;step/sizeof(float) *(ROW)))[(COL)]  
    unsigned int i,j;  
    for ( j = 0; j &lt; src-&gt;rows; j++)   
    {  
        for ( i = 0; i &lt; src-&gt;cols; i++)   
        {  
            //printf(&quot;%d, %d/n&quot;, i, j);  
            Dst(j,i) = ConvolveLocHeight(kern, dim, src, i, j);  
        }  
    }  
}  

//&#x5377;&#x79EF;&#x6A21;&#x7CCA;&#x56FE;&#x50CF;  
int BlurImage(CvMat * src, CvMat * dst, float sigma)   
{  
    float* convkernel;  
    int dim = (int) max(3.0f, 2.0 * GAUSSKERN * sigma + 1.0f);  
    CvMat *tempMat;  
    // make dim odd  
    if (dim % 2 == 0)  
        dim++;  
    tempMat = cvCreateMat(src-&gt;rows, src-&gt;cols, CV_32FC1);  
    convkernel = GaussianKernel1D(sigma, dim);  

    Convolve1DWidth(convkernel, dim, src, tempMat);  
    Convolve1DHeight(convkernel, dim, tempMat, dst);  
    cvReleaseMat(&amp;tempMat);  
    return dim;  
}
</code></pre>
<h3 id="&#x4E94;&#x4E2A;&#x6B65;&#x9AA4;"><strong>&#x4E94;&#x4E2A;&#x6B65;&#x9AA4;</strong></h3>
<p>ok&#xFF0C;&#x63A5;&#x4E0B;&#x6765;&#xFF0C;&#x8FDB;&#x5165;&#x91CD;&#x70B9;&#x90E8;&#x5206;&#xFF0C;&#x54B1;&#x4EEC;&#x4F9D;&#x636E;&#x4E0A;&#x6587;&#x4ECB;&#x7ECD;&#x7684;sift&#x7B97;&#x6CD5;&#x7684;&#x51E0;&#x4E2A;&#x6B65;&#x9AA4;&#xFF0C;&#x6765;&#x4E00;&#x4E00;&#x5B9E;&#x73B0;&#x8FD9;&#x4E9B;&#x51FD;&#x6570;&#x3002;</p>
<p>&#x4E3A;&#x4E86;&#x7248;&#x8FF0;&#x6E05;&#x6670;&#xFF0C;&#x518D;&#x8D34;&#x4E00;&#x4E0B;&#xFF0C;&#x4E3B;&#x51FD;&#x6570;&#xFF0C;&#x987A;&#x4FBF;&#x518D;&#x52A0;&#x5F3A;&#x4E0B;&#x5BF9;sift &#x7B97;&#x6CD5;&#x7684;&#x4E94;&#x4E2A;&#x6B65;&#x9AA4;&#x7684;&#x8BA4;&#x8BC6;&#xFF1A;</p>
<p>1&#x3001; SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E00;&#x6B65;&#xFF1A;&#x56FE;&#x50CF;&#x9884;&#x5904;&#x7406;</p>
<p>CvMat *ScaleInitImage(CvMat * im) ;                  //&#x91D1;&#x5B57;&#x5854;&#x521D;&#x59CB;&#x5316;</p>
<p>2&#x3001; SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E8C;&#x6B65;&#xFF1A;&#x5EFA;&#x7ACB;&#x9AD8;&#x65AF;&#x91D1;&#x5B57;&#x5854;&#x51FD;&#x6570;</p>
<p>ImageOctaves* BuildGaussianOctaves(CvMat * image) ;  //&#x5EFA;&#x7ACB;&#x9AD8;&#x65AF;&#x91D1;&#x5B57;&#x5854;</p>
<p>3&#x3001; SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E09;&#x6B65;&#xFF1A;&#x7279;&#x5F81;&#x70B9;&#x4F4D;&#x7F6E;&#x68C0;&#x6D4B;&#xFF0C;&#x6700;&#x540E;&#x786E;&#x5B9A;&#x7279;&#x5F81;&#x70B9;&#x7684;&#x4F4D;&#x7F6E;</p>
<p>int DetectKeypoint(int numoctaves, ImageOctaves *GaussianPyr);</p>
<p>4&#x3001; SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x56DB;&#x6B65;&#xFF1A;&#x8BA1;&#x7B97;&#x9AD8;&#x65AF;&#x56FE;&#x50CF;&#x7684;&#x68AF;&#x5EA6;&#x65B9;&#x5411;&#x548C;&#x5E45;&#x503C;&#xFF0C;&#x8BA1;&#x7B97;&#x5404;&#x4E2A;&#x7279;&#x5F81;&#x70B9;&#x7684;&#x4E3B;&#x65B9;&#x5411;</p>
<p>void ComputeGrad_DirecandMag(int numoctaves, ImageOctaves *GaussianPyr);</p>
<p>5&#x3001; SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E94;&#x6B65;&#xFF1A;&#x62BD;&#x53D6;&#x5404;&#x4E2A;&#x7279;&#x5F81;&#x70B9;&#x5904;&#x7684;&#x7279;&#x5F81;&#x63CF;&#x8FF0;&#x5B57;</p>
<p>void ExtractFeatureDescriptors(int numoctaves, ImageOctaves *GaussianPyr);</p>
<p>ok&#xFF0C;&#x63A5;&#x4E0B;&#x6765;&#x4E00;&#x4E00;&#x5177;&#x4F53;&#x5B9E;&#x73B0;&#x8FD9;&#x51E0;&#x4E2A;&#x51FD;&#x6570;&#xFF1A;</p>
<h4 id="sift&#x7B97;&#x6CD5;&#x7B2C;&#x4E00;&#x6B65;"><strong>SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E00;&#x6B65;</strong></h4>
<p>SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E00;&#x6B65;&#xFF1A;&#x6269;&#x5927;&#x56FE;&#x50CF;&#xFF0C;&#x9884;&#x6EE4;&#x6CE2;&#x5254;&#x9664;&#x566A;&#x58F0;&#xFF0C;&#x5F97;&#x5230;&#x91D1;&#x5B57;&#x5854;&#x7684;&#x6700;&#x5E95;&#x5C42;-&#x7B2C;&#x4E00;&#x9636;&#x7684;&#x7B2C;&#x4E00;&#x5C42;&#xFF1A;</p>
<pre><code class="lang-c"><span class="hljs-function">CvMat *<span class="hljs-title">ScaleInitImage</span><span class="hljs-params">(CvMat * im)</span>   
</span>{  
    <span class="hljs-keyword">double</span> sigma,preblur_sigma;  
    CvMat *imMat;  
    CvMat * dst;  
    CvMat *tempMat;  
    <span class="hljs-comment">//&#x9996;&#x5148;&#x5BF9;&#x56FE;&#x50CF;&#x8FDB;&#x884C;&#x5E73;&#x6ED1;&#x6EE4;&#x6CE2;&#xFF0C;&#x6291;&#x5236;&#x566A;&#x58F0;  </span>
    imMat = cvCreateMat(im-&gt;rows, im-&gt;cols, CV_32FC1);  
    BlurImage(im, imMat, INITSIGMA);  
    <span class="hljs-comment">//&#x9488;&#x5BF9;&#x4E24;&#x79CD;&#x60C5;&#x51B5;&#x5206;&#x522B;&#x8FDB;&#x884C;&#x5904;&#x7406;&#xFF1A;&#x521D;&#x59CB;&#x5316;&#x653E;&#x5927;&#x539F;&#x59CB;&#x56FE;&#x50CF;&#x6216;&#x8005;&#x5728;&#x539F;&#x56FE;&#x50CF;&#x57FA;&#x7840;&#x4E0A;&#x8FDB;&#x884C;&#x540E;&#x7EED;&#x64CD;&#x4F5C;  </span>
    <span class="hljs-comment">//&#x5EFA;&#x7ACB;&#x91D1;&#x5B57;&#x5854;&#x7684;&#x6700;&#x5E95;&#x5C42;  </span>
    <span class="hljs-keyword">if</span> (DOUBLE_BASE_IMAGE_SIZE)   
    {  
        tempMat = doubleSizeImage2(imMat);<span class="hljs-comment">//&#x5BF9;&#x6269;&#x5927;&#x4E24;&#x500D;&#x7684;&#x56FE;&#x50CF;&#x8FDB;&#x884C;&#x4E8C;&#x6B21;&#x91C7;&#x6837;&#xFF0C;&#x91C7;&#x6837;&#x7387;&#x4E3A;0.5&#xFF0C;&#x91C7;&#x7528;&#x7EBF;&#x6027;&#x63D2;&#x503C;  </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> TEMPMAT(ROW,COL) ((float *)(tempMat-&gt;data.fl + tempMat-&gt;step/sizeof(float) * (ROW)))[(COL)]  </span>

        dst = cvCreateMat(tempMat-&gt;rows, tempMat-&gt;cols, CV_32FC1);  
        preblur_sigma = <span class="hljs-number">1.0</span>;<span class="hljs-comment">//sqrt(2 - 4*INITSIGMA*INITSIGMA);  </span>
        BlurImage(tempMat, dst, preblur_sigma);   

        <span class="hljs-comment">// The initial blurring for the first image of the first octave of the pyramid.  </span>
        sigma = <span class="hljs-built_in">sqrt</span>( (<span class="hljs-number">4</span>*INITSIGMA*INITSIGMA) + preblur_sigma * preblur_sigma );  
        <span class="hljs-comment">//  sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA * 4);  </span>
        <span class="hljs-comment">//printf(&quot;Init Sigma: %f/n&quot;, sigma);  </span>
        BlurImage(dst, tempMat, sigma);       <span class="hljs-comment">//&#x5F97;&#x5230;&#x91D1;&#x5B57;&#x5854;&#x7684;&#x6700;&#x5E95;&#x5C42;-&#x653E;&#x5927;2&#x500D;&#x7684;&#x56FE;&#x50CF;  </span>
        cvReleaseMat( &amp;dst );   
        <span class="hljs-keyword">return</span> tempMat;  
    }   
    <span class="hljs-keyword">else</span>   
    {  
        dst = cvCreateMat(im-&gt;rows, im-&gt;cols, CV_32FC1);  
        <span class="hljs-comment">//sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA);  </span>
        preblur_sigma = <span class="hljs-number">1.0</span>;<span class="hljs-comment">//sqrt(2 - 4*INITSIGMA*INITSIGMA);  </span>
        sigma = <span class="hljs-built_in">sqrt</span>( (<span class="hljs-number">4</span>*INITSIGMA*INITSIGMA) + preblur_sigma * preblur_sigma );  
        <span class="hljs-comment">//printf(&quot;Init Sigma: %f/n&quot;, sigma);  </span>
        BlurImage(imMat, dst, sigma);        <span class="hljs-comment">//&#x5F97;&#x5230;&#x91D1;&#x5B57;&#x5854;&#x7684;&#x6700;&#x5E95;&#x5C42;&#xFF1A;&#x539F;&#x59CB;&#x56FE;&#x50CF;&#x5927;&#x5C0F;  </span>
        <span class="hljs-keyword">return</span> dst;  
    }   
}
</code></pre>
<h4 id="sift&#x7B97;&#x6CD5;&#x7B2C;&#x4E8C;&#x6B65;"><strong>SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E8C;&#x6B65;</strong></h4>
<p>SIFT&#x7B2C;&#x4E8C;&#x6B65;&#xFF0C;&#x5EFA;&#x7ACB;Gaussian&#x91D1;&#x5B57;&#x5854;&#xFF0C;&#x7ED9;&#x5B9A;&#x91D1;&#x5B57;&#x5854;&#x7B2C;&#x4E00;&#x9636;&#x7B2C;&#x4E00;&#x5C42;&#x56FE;&#x50CF;&#x540E;&#xFF0C;&#x8BA1;&#x7B97;&#x9AD8;&#x65AF;&#x91D1;&#x5B57;&#x5854;&#x5176;&#x4ED6;&#x5C3A;&#x5EA6;&#x56FE;&#x50CF;&#xFF0C;
&#x6BCF;&#x4E00;&#x9636;&#x7684;&#x6570;&#x76EE;&#x7531;&#x53D8;&#x91CF;SCALESPEROCTAVE&#x51B3;&#x5B9A;&#xFF0C;&#x7ED9;&#x5B9A;&#x4E00;&#x4E2A;&#x57FA;&#x672C;&#x56FE;&#x50CF;&#xFF0C;&#x8BA1;&#x7B97;&#x5B83;&#x7684;&#x9AD8;&#x65AF;&#x91D1;&#x5B57;&#x5854;&#x56FE;&#x50CF;&#xFF0C;&#x8FD4;&#x56DE;&#x5916;&#x90E8;&#x5411;&#x91CF;&#x662F;&#x9636;&#x68AF;&#x6307;&#x9488;&#xFF0C;&#x5185;&#x90E8;&#x5411;&#x91CF;&#x662F;&#x6BCF;&#x4E00;&#x4E2A;&#x9636;&#x68AF;&#x5185;&#x90E8;&#x7684;&#x4E0D;&#x540C;&#x5C3A;&#x5EA6;&#x56FE;&#x50CF;&#x3002;</p>
<pre><code class="lang-c">//SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E8C;&#x6B65;  
ImageOctaves* BuildGaussianOctaves(CvMat * image)   
{  
    ImageOctaves *octaves;  
    CvMat *tempMat;  
    CvMat *dst;  
    CvMat *temp;  

    int i,j;  
    double k = pow(2, 1.0/((float)SCALESPEROCTAVE));  //&#x65B9;&#x5DEE;&#x500D;&#x6570;  
    float preblur_sigma, initial_sigma , sigma1,sigma2,sigma,absolute_sigma,sigma_f;  
    //&#x8BA1;&#x7B97;&#x91D1;&#x5B57;&#x5854;&#x7684;&#x9636;&#x68AF;&#x6570;&#x76EE;  
    int dim = min(image-&gt;rows, image-&gt;cols);  
    int numoctaves = (int) (log((double) dim) / log(2.0)) - 2;    //&#x91D1;&#x5B57;&#x5854;&#x9636;&#x6570;  
    //&#x9650;&#x5B9A;&#x91D1;&#x5B57;&#x5854;&#x7684;&#x9636;&#x68AF;&#x6570;  
    numoctaves = min(numoctaves, MAXOCTAVES);  
    //&#x4E3A;&#x9AD8;&#x65AF;&#x91D1;&#x5854;&#x548C;DOG&#x91D1;&#x5B57;&#x5854;&#x5206;&#x914D;&#x5185;&#x5B58;  
    octaves=(ImageOctaves*) malloc( numoctaves * sizeof(ImageOctaves) );  
    DOGoctaves=(ImageOctaves*) malloc( numoctaves * sizeof(ImageOctaves) );  

    printf(&quot;BuildGaussianOctaves(): Base image dimension is %dx%d/n&quot;, (int)(0.5*(image-&gt;cols)), (int)(0.5*(image-&gt;rows)) );  
    printf(&quot;BuildGaussianOctaves(): Building %d octaves/n&quot;, numoctaves);  

    // start with initial source image  
    tempMat=cvCloneMat( image );  
    // preblur_sigma = 1.0;//sqrt(2 - 4*INITSIGMA*INITSIGMA);  
    initial_sigma = sqrt(2);//sqrt( (4*INITSIGMA*INITSIGMA) + preblur_sigma * preblur_sigma );  
    //   initial_sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA * 4);  

    //&#x5728;&#x6BCF;&#x4E00;&#x9636;&#x91D1;&#x5B57;&#x5854;&#x56FE;&#x50CF;&#x4E2D;&#x5EFA;&#x7ACB;&#x4E0D;&#x540C;&#x7684;&#x5C3A;&#x5EA6;&#x56FE;&#x50CF;  
    for ( i = 0; i &lt; numoctaves; i++)   
    {     
        //&#x9996;&#x5148;&#x5EFA;&#x7ACB;&#x91D1;&#x5B57;&#x5854;&#x6BCF;&#x4E00;&#x9636;&#x68AF;&#x7684;&#x6700;&#x5E95;&#x5C42;&#xFF0C;&#x5176;&#x4E2D;0&#x9636;&#x68AF;&#x7684;&#x6700;&#x5E95;&#x5C42;&#x5DF2;&#x7ECF;&#x5EFA;&#x7ACB;&#x597D;  
        printf(&quot;Building octave %d of dimesion (%d, %d)/n&quot;, i, tempMat-&gt;cols,tempMat-&gt;rows);  
        //&#x4E3A;&#x5404;&#x4E2A;&#x9636;&#x68AF;&#x5206;&#x914D;&#x5185;&#x5B58;  
        octaves[i].Octave= (ImageLevels*) malloc( (SCALESPEROCTAVE + 3) * sizeof(ImageLevels) );  
        DOGoctaves[i].Octave= (ImageLevels*) malloc( (SCALESPEROCTAVE + 2) * sizeof(ImageLevels) );  
        //&#x5B58;&#x50A8;&#x5404;&#x4E2A;&#x9636;&#x68AF;&#x7684;&#x6700;&#x5E95;&#x5C42;  
        (octaves[i].Octave)[0].Level=tempMat;  

        octaves[i].col=tempMat-&gt;cols;  
        octaves[i].row=tempMat-&gt;rows;  
        DOGoctaves[i].col=tempMat-&gt;cols;  
        DOGoctaves[i].row=tempMat-&gt;rows;  
        if (DOUBLE_BASE_IMAGE_SIZE)  
            octaves[i].subsample=pow(2,i)*0.5;  
        else  
            octaves[i].subsample=pow(2,i);  

        if(i==0)       
        {  
            (octaves[0].Octave)[0].levelsigma = initial_sigma;  
            (octaves[0].Octave)[0].absolute_sigma = initial_sigma;  
            printf(&quot;0 scale and blur sigma : %f /n&quot;, (octaves[0].subsample) * ((octaves[0].Octave)[0].absolute_sigma));  
        }  
        else  
        {  
            (octaves[i].Octave)[0].levelsigma = (octaves[i-1].Octave)[SCALESPEROCTAVE].levelsigma;  
            (octaves[i].Octave)[0].absolute_sigma = (octaves[i-1].Octave)[SCALESPEROCTAVE].absolute_sigma;  
            printf( &quot;0 scale and blur sigma : %f /n&quot;, ((octaves[i].Octave)[0].absolute_sigma) );  
        }  
        sigma = initial_sigma;  
        //&#x5EFA;&#x7ACB;&#x672C;&#x9636;&#x68AF;&#x5176;&#x4ED6;&#x5C42;&#x7684;&#x56FE;&#x50CF;  
        for ( j =  1; j &lt; SCALESPEROCTAVE + 3; j++)   
        {  
            dst = cvCreateMat(tempMat-&gt;rows, tempMat-&gt;cols, CV_32FC1);//&#x7528;&#x4E8E;&#x5B58;&#x50A8;&#x9AD8;&#x65AF;&#x5C42;  
            temp = cvCreateMat(tempMat-&gt;rows, tempMat-&gt;cols, CV_32FC1);//&#x7528;&#x4E8E;&#x5B58;&#x50A8;DOG&#x5C42;  
            // 2 passes of 1D on original  
            //   if(i!=0)  
            //   {  
            //       sigma1 = pow(k, j - 1) * ((octaves[i-1].Octave)[j-1].levelsigma);  
            //          sigma2 = pow(k, j) * ((octaves[i].Octave)[j-1].levelsigma);  
            //       sigma = sqrt(sigma2*sigma2 - sigma1*sigma1);  
            sigma_f= sqrt(k*k-1)*sigma;  
            //   }  
            //   else  
            //   {  
            //       sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA * 4)*pow(k,j);  
            //   }    
            sigma = k*sigma;  
            absolute_sigma = sigma * (octaves[i].subsample);  
            printf(&quot;%d scale and Blur sigma: %f  /n&quot;, j, absolute_sigma);  

            (octaves[i].Octave)[j].levelsigma = sigma;  
            (octaves[i].Octave)[j].absolute_sigma = absolute_sigma;  
            //&#x4EA7;&#x751F;&#x9AD8;&#x65AF;&#x5C42;  
            int length=BlurImage((octaves[i].Octave)[j-1].Level, dst, sigma_f);//&#x76F8;&#x5E94;&#x5C3A;&#x5EA6;  
            (octaves[i].Octave)[j].levelsigmalength = length;  
            (octaves[i].Octave)[j].Level=dst;  
            //&#x4EA7;&#x751F;DOG&#x5C42;  
            cvSub( ((octaves[i].Octave)[j]).Level, ((octaves[i].Octave)[j-1]).Level, temp, 0 );  
            //         cvAbsDiff( ((octaves[i].Octave)[j]).Level, ((octaves[i].Octave)[j-1]).Level, temp );  
            ((DOGoctaves[i].Octave)[j-1]).Level=temp;  
        }  
        // halve the image size for next iteration  
        tempMat  = halfSizeImage( ( (octaves[i].Octave)[SCALESPEROCTAVE].Level ) );  
    }  
    return octaves;  
}
</code></pre>
<h4 id="sift&#x7B97;&#x6CD5;&#x7B2C;&#x4E09;&#x6B65;"><strong>SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E09;&#x6B65;</strong></h4>
<p>SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E09;&#x6B65;&#xFF0C;&#x7279;&#x5F81;&#x70B9;&#x4F4D;&#x7F6E;&#x68C0;&#x6D4B;&#xFF0C;&#x6700;&#x540E;&#x786E;&#x5B9A;&#x7279;&#x5F81;&#x70B9;&#x7684;&#x4F4D;&#x7F6E;&#x68C0;&#x6D4B;DOG&#x91D1;&#x5B57;&#x5854;&#x4E2D;&#x7684;&#x5C40;&#x90E8;&#x6700;&#x5927;&#x503C;&#xFF0C;&#x627E;&#x5230;&#x4E4B;&#x540E;&#xFF0C;&#x8FD8;&#x8981;&#x7ECF;&#x8FC7;&#x4E24;&#x4E2A;&#x68C0;&#x9A8C;&#x624D;&#x80FD;&#x786E;&#x8BA4;&#x4E3A;&#x7279;&#x5F81;&#x70B9;&#xFF1A;&#x4E00;&#x662F;&#x5B83;&#x5FC5;&#x987B;&#x6709;&#x660E;&#x663E;&#x7684;&#x5DEE;&#x5F02;&#xFF0C;&#x4E8C;&#x662F;&#x4ED6;&#x4E0D;&#x5E94;&#x8BE5;&#x662F;&#x8FB9;&#x7F18;&#x70B9;&#xFF0C;&#xFF08;&#x4E5F;&#x5C31;&#x662F;&#x8BF4;&#xFF0C;&#x5728;&#x6781;&#x503C;&#x70B9;&#x5904;&#x7684;&#x4E3B;&#x66F2;&#x7387;&#x6BD4;&#x5E94;&#x8BE5;&#x5C0F;&#x4E8E;&#x67D0;&#x4E00;&#x4E2A;&#x9608;&#x503C;&#xFF09;&#x3002;</p>
<pre><code class="lang-c">//SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E09;&#x6B65;&#xFF0C;&#x7279;&#x5F81;&#x70B9;&#x4F4D;&#x7F6E;&#x68C0;&#x6D4B;&#xFF0C;  
int DetectKeypoint(int numoctaves, ImageOctaves *GaussianPyr)  
{  
    //&#x8BA1;&#x7B97;&#x7528;&#x4E8E;DOG&#x6781;&#x503C;&#x70B9;&#x68C0;&#x6D4B;&#x7684;&#x4E3B;&#x66F2;&#x7387;&#x6BD4;&#x7684;&#x9608;&#x503C;  
    double curvature_threshold;  
    curvature_threshold= ((CURVATURE_THRESHOLD + 1)*(CURVATURE_THRESHOLD + 1))/CURVATURE_THRESHOLD;  
#define ImLevels(OCTAVE,LEVEL,ROW,COL) ((float *)(DOGoctaves[(OCTAVE)].Octave[(LEVEL)].Level-&gt;data.fl + DOGoctaves[(OCTAVE)].Octave[(LEVEL)].Level-&gt;step/sizeof(float) *(ROW)))[(COL)]  

    int   keypoint_count = 0;     
    for (int i=0; i&lt;numoctaves; i++)    
    {          
        for(int j=1;j&lt;SCALESPEROCTAVE+1;j++)//&#x53D6;&#x4E2D;&#x95F4;&#x7684;scaleperoctave&#x4E2A;&#x5C42;  
        {    
            //&#x5728;&#x56FE;&#x50CF;&#x7684;&#x6709;&#x6548;&#x533A;&#x57DF;&#x5185;&#x5BFB;&#x627E;&#x5177;&#x6709;&#x663E;&#x8457;&#x6027;&#x7279;&#x5F81;&#x7684;&#x5C40;&#x90E8;&#x6700;&#x5927;&#x503C;  
            //float sigma=(GaussianPyr[i].Octave)[j].levelsigma;  
            //int dim = (int) (max(3.0f, 2.0*GAUSSKERN *sigma + 1.0f)*0.5);  
            int dim = (int)(0.5*((GaussianPyr[i].Octave)[j].levelsigmalength)+0.5);  
            for (int m=dim;m&lt;((DOGoctaves[i].row)-dim);m++)   
                for(int n=dim;n&lt;((DOGoctaves[i].col)-dim);n++)  
                {       
                    if ( fabs(ImLevels(i,j,m,n))&gt;= CONTRAST_THRESHOLD )  
                    {  

                        if ( ImLevels(i,j,m,n)!=0.0 )  //1&#x3001;&#x9996;&#x5148;&#x662F;&#x975E;&#x96F6;  
                        {  
                            float inf_val=ImLevels(i,j,m,n);  
                            if(( (inf_val &lt;= ImLevels(i,j-1,m-1,n-1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j-1,m  ,n-1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j-1,m+1,n-1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j-1,m-1,n  ))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j-1,m  ,n  ))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j-1,m+1,n  ))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j-1,m-1,n+1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j-1,m  ,n+1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j-1,m+1,n+1))&amp;&amp;    //&#x5E95;&#x5C42;&#x7684;&#x5C0F;&#x5C3A;&#x5EA6;9  

                                (inf_val &lt;= ImLevels(i,j,m-1,n-1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j,m  ,n-1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j,m+1,n-1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j,m-1,n  ))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j,m+1,n  ))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j,m-1,n+1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j,m  ,n+1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j,m+1,n+1))&amp;&amp;     //&#x5F53;&#x524D;&#x5C42;8  

                                (inf_val &lt;= ImLevels(i,j+1,m-1,n-1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j+1,m  ,n-1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j+1,m+1,n-1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j+1,m-1,n  ))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j+1,m  ,n  ))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j+1,m+1,n  ))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j+1,m-1,n+1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j+1,m  ,n+1))&amp;&amp;  
                                (inf_val &lt;= ImLevels(i,j+1,m+1,n+1))     //&#x4E0B;&#x4E00;&#x5C42;&#x5927;&#x5C3A;&#x5EA6;9          
                                ) ||   
                                ( (inf_val &gt;= ImLevels(i,j-1,m-1,n-1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j-1,m  ,n-1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j-1,m+1,n-1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j-1,m-1,n  ))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j-1,m  ,n  ))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j-1,m+1,n  ))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j-1,m-1,n+1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j-1,m  ,n+1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j-1,m+1,n+1))&amp;&amp;  

                                (inf_val &gt;= ImLevels(i,j,m-1,n-1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j,m  ,n-1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j,m+1,n-1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j,m-1,n  ))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j,m+1,n  ))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j,m-1,n+1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j,m  ,n+1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j,m+1,n+1))&amp;&amp;   

                                (inf_val &gt;= ImLevels(i,j+1,m-1,n-1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j+1,m  ,n-1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j+1,m+1,n-1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j+1,m-1,n  ))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j+1,m  ,n  ))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j+1,m+1,n  ))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j+1,m-1,n+1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j+1,m  ,n+1))&amp;&amp;  
                                (inf_val &gt;= ImLevels(i,j+1,m+1,n+1))   
                                ) )      //2&#x3001;&#x6EE1;&#x8DB3;26&#x4E2A;&#x4E2D;&#x6781;&#x503C;&#x70B9;  
                            {     
                                //&#x6B64;&#x5904;&#x53EF;&#x5B58;&#x50A8;  
                                //&#x7136;&#x540E;&#x5FC5;&#x987B;&#x5177;&#x6709;&#x660E;&#x663E;&#x7684;&#x663E;&#x8457;&#x6027;&#xFF0C;&#x5373;&#x5FC5;&#x987B;&#x5927;&#x4E8E;CONTRAST_THRESHOLD=0.02  
                                if ( fabs(ImLevels(i,j,m,n))&gt;= CONTRAST_THRESHOLD )  
                                {  
                                    //&#x6700;&#x540E;&#x663E;&#x8457;&#x5904;&#x7684;&#x7279;&#x5F81;&#x70B9;&#x5FC5;&#x987B;&#x5177;&#x6709;&#x8DB3;&#x591F;&#x7684;&#x66F2;&#x7387;&#x6BD4;&#xFF0C;CURVATURE_THRESHOLD=10.0&#xFF0C;&#x9996;&#x5148;&#x8BA1;&#x7B97;Hessian&#x77E9;&#x9635;  
                                    // Compute the entries of the Hessian matrix at the extrema location.  
                                    /* 
                                    1   0   -1 
                                    0   0   0 
                                    -1   0   1         *0.25 
                                    */  
                                    // Compute the trace and the determinant of the Hessian.  
                                    //Tr_H = Dxx + Dyy;  
                                    //Det_H = Dxx*Dyy - Dxy^2;  
                                    float Dxx,Dyy,Dxy,Tr_H,Det_H,curvature_ratio;  
                                    Dxx = ImLevels(i,j,m,n-1) + ImLevels(i,j,m,n+1)-2.0*ImLevels(i,j,m,n);  
                                    Dyy = ImLevels(i,j,m-1,n) + ImLevels(i,j,m+1,n)-2.0*ImLevels(i,j,m,n);  
                                    Dxy = ImLevels(i,j,m-1,n-1) + ImLevels(i,j,m+1,n+1) - ImLevels(i,j,m+1,n-1) - ImLevels(i,j,m-1,n+1);  
                                    Tr_H = Dxx + Dyy;  
                                    Det_H = Dxx*Dyy - Dxy*Dxy;  
                                    // Compute the ratio of the principal curvatures.  
                                    curvature_ratio = (1.0*Tr_H*Tr_H)/Det_H;  
                                    if ( (Det_H&gt;=0.0) &amp;&amp; (curvature_ratio &lt;= curvature_threshold) )  //&#x6700;&#x540E;&#x5F97;&#x5230;&#x6700;&#x5177;&#x6709;&#x663E;&#x8457;&#x6027;&#x7279;&#x5F81;&#x7684;&#x7279;&#x5F81;&#x70B9;  
                                    {  
                                        //&#x5C06;&#x5176;&#x5B58;&#x50A8;&#x8D77;&#x6765;&#xFF0C;&#x4EE5;&#x8BA1;&#x7B97;&#x540E;&#x9762;&#x7684;&#x7279;&#x5F81;&#x63CF;&#x8FF0;&#x5B57;  
                                        keypoint_count++;  
                                        Keypoint k;  
                                        /* Allocate memory for the keypoint. */  
                                        k = (Keypoint) malloc(sizeof(struct KeypointSt));  
                                        k-&gt;next = keypoints;  
                                        keypoints = k;  
                                        k-&gt;row = m*(GaussianPyr[i].subsample);  
                                        k-&gt;col =n*(GaussianPyr[i].subsample);  
                                        k-&gt;sy = m;    //&#x884C;  
                                        k-&gt;sx = n;    //&#x5217;  
                                        k-&gt;octave=i;  
                                        k-&gt;level=j;  
                                        k-&gt;scale = (GaussianPyr[i].Octave)[j].absolute_sigma;        
                                    }//if &gt;curvature_thresh  
                                }//if &gt;contrast  
                            }//if inf value  
                        }//if non zero  
                    }//if &gt;contrast  
                }  //for concrete image level col  
        }//for levels  
    }//for octaves  
    return keypoint_count;  
}  

//&#x5728;&#x56FE;&#x50CF;&#x4E2D;&#xFF0C;&#x663E;&#x793A;SIFT&#x7279;&#x5F81;&#x70B9;&#x7684;&#x4F4D;&#x7F6E;  
void DisplayKeypointLocation(IplImage* image, ImageOctaves *GaussianPyr)  
{  

    Keypoint p = keypoints; // p&#x6307;&#x5411;&#x7B2C;&#x4E00;&#x4E2A;&#x7ED3;&#x70B9;  
    while(p) // &#x6CA1;&#x5230;&#x8868;&#x5C3E;  
    {     
        cvLine( image, cvPoint((int)((p-&gt;col)-3),(int)(p-&gt;row)),   
            cvPoint((int)((p-&gt;col)+3),(int)(p-&gt;row)), CV_RGB(255,255,0),  
            1, 8, 0 );  
        cvLine( image, cvPoint((int)(p-&gt;col),(int)((p-&gt;row)-3)),   
            cvPoint((int)(p-&gt;col),(int)((p-&gt;row)+3)), CV_RGB(255,255,0),  
            1, 8, 0 );  
        //  cvCircle(image,cvPoint((uchar)(p-&gt;col),(uchar)(p-&gt;row)),  
        //   (int)((GaussianPyr[p-&gt;octave].Octave)[p-&gt;level].absolute_sigma),  
        //   CV_RGB(255,0,0),1,8,0);  
        p=p-&gt;next;  
    }   
}  

// Compute the gradient direction and magnitude of the gaussian pyramid images  
void ComputeGrad_DirecandMag(int numoctaves, ImageOctaves *GaussianPyr)  
{  
    // ImageOctaves *mag_thresh ;  
    mag_pyr=(ImageOctaves*) malloc( numoctaves * sizeof(ImageOctaves) );  
    grad_pyr=(ImageOctaves*) malloc( numoctaves * sizeof(ImageOctaves) );  
    // float sigma=( (GaussianPyr[0].Octave)[SCALESPEROCTAVE+2].absolute_sigma ) / GaussianPyr[0].subsample;  
    // int dim = (int) (max(3.0f, 2 * GAUSSKERN *sigma + 1.0f)*0.5+0.5);  
#define ImLevels(OCTAVE,LEVEL,ROW,COL) ((float *)(GaussianPyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;data.fl + GaussianPyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;step/sizeof(float) *(ROW)))[(COL)]  
    for (int i=0; i&lt;numoctaves; i++)    
    {          
        mag_pyr[i].Octave= (ImageLevels*) malloc( (SCALESPEROCTAVE) * sizeof(ImageLevels) );  
        grad_pyr[i].Octave= (ImageLevels*) malloc( (SCALESPEROCTAVE) * sizeof(ImageLevels) );  
        for(int j=1;j&lt;SCALESPEROCTAVE+1;j++)//&#x53D6;&#x4E2D;&#x95F4;&#x7684;scaleperoctave&#x4E2A;&#x5C42;  
        {    
            CvMat *Mag = cvCreateMat(GaussianPyr[i].row, GaussianPyr[i].col, CV_32FC1);  
            CvMat *Ori = cvCreateMat(GaussianPyr[i].row, GaussianPyr[i].col, CV_32FC1);  
            CvMat *tempMat1 = cvCreateMat(GaussianPyr[i].row, GaussianPyr[i].col, CV_32FC1);  
            CvMat *tempMat2 = cvCreateMat(GaussianPyr[i].row, GaussianPyr[i].col, CV_32FC1);  
            cvZero(Mag);  
            cvZero(Ori);  
            cvZero(tempMat1);  
            cvZero(tempMat2);   
#define MAG(ROW,COL) ((float *)(Mag-&gt;data.fl + Mag-&gt;step/sizeof(float) *(ROW)))[(COL)]     
#define ORI(ROW,COL) ((float *)(Ori-&gt;data.fl + Ori-&gt;step/sizeof(float) *(ROW)))[(COL)]    
#define TEMPMAT1(ROW,COL) ((float *)(tempMat1-&gt;data.fl + tempMat1-&gt;step/sizeof(float) *(ROW)))[(COL)]  
#define TEMPMAT2(ROW,COL) ((float *)(tempMat2-&gt;data.fl + tempMat2-&gt;step/sizeof(float) *(ROW)))[(COL)]  
            for (int m=1;m&lt;(GaussianPyr[i].row-1);m++)   
                for(int n=1;n&lt;(GaussianPyr[i].col-1);n++)  
                {  
                    //&#x8BA1;&#x7B97;&#x5E45;&#x503C;  
                    TEMPMAT1(m,n) = 0.5*( ImLevels(i,j,m,n+1)-ImLevels(i,j,m,n-1) );  //dx  
                    TEMPMAT2(m,n) = 0.5*( ImLevels(i,j,m+1,n)-ImLevels(i,j,m-1,n) );  //dy  
                    MAG(m,n) = sqrt(TEMPMAT1(m,n)*TEMPMAT1(m,n)+TEMPMAT2(m,n)*TEMPMAT2(m,n));  //mag  
                    //&#x8BA1;&#x7B97;&#x65B9;&#x5411;  
                    ORI(m,n) =atan( TEMPMAT2(m,n)/TEMPMAT1(m,n) );  
                    if (ORI(m,n)==CV_PI)  
                        ORI(m,n)=-CV_PI;  
                }  
                ((mag_pyr[i].Octave)[j-1]).Level=Mag;  
                ((grad_pyr[i].Octave)[j-1]).Level=Ori;  
                cvReleaseMat(&amp;tempMat1);  
                cvReleaseMat(&amp;tempMat2);  
        }//for levels  
    }//for octaves  
}
</code></pre>
<h4 id="sift&#x7B97;&#x6CD5;&#x7B2C;&#x56DB;&#x6B65;"><strong>SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x56DB;&#x6B65;</strong></h4>
<pre><code class="lang-c">//SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x56DB;&#x6B65;&#xFF1A;&#x8BA1;&#x7B97;&#x5404;&#x4E2A;&#x7279;&#x5F81;&#x70B9;&#x7684;&#x4E3B;&#x65B9;&#x5411;&#xFF0C;&#x786E;&#x5B9A;&#x4E3B;&#x65B9;&#x5411;  
void AssignTheMainOrientation(int numoctaves, ImageOctaves *GaussianPyr,ImageOctaves *mag_pyr,ImageOctaves *grad_pyr)  
{  
    // Set up the histogram bin centers for a 36 bin histogram.  
    int num_bins = 36;  
    float hist_step = 2.0*PI/num_bins;  
    float hist_orient[36];  
    for (int i=0;i&lt;36;i++)  
        hist_orient[i]=-PI+i*hist_step;  
    float sigma1=( ((GaussianPyr[0].Octave)[SCALESPEROCTAVE].absolute_sigma) ) / (GaussianPyr[0].subsample);//SCALESPEROCTAVE+2  
    int zero_pad = (int) (max(3.0f, 2 * GAUSSKERN *sigma1 + 1.0f)*0.5+0.5);  
    //Assign orientations to the keypoints.  
#define ImLevels(OCTAVES,LEVELS,ROW,COL) ((float *)((GaussianPyr[(OCTAVES)].Octave[(LEVELS)].Level)-&gt;data.fl + (GaussianPyr[(OCTAVES)].Octave[(LEVELS)].Level)-&gt;step/sizeof(float) *(ROW)))[(COL)]  

    int keypoint_count = 0;  
    Keypoint p = keypoints; // p&#x6307;&#x5411;&#x7B2C;&#x4E00;&#x4E2A;&#x7ED3;&#x70B9;  

    while(p) // &#x6CA1;&#x5230;&#x8868;&#x5C3E;  
    {  
        int i=p-&gt;octave;  
        int j=p-&gt;level;  
        int m=p-&gt;sy;   //&#x884C;  
        int n=p-&gt;sx;   //&#x5217;  
        if ((m&gt;=zero_pad)&amp;&amp;(m&lt;GaussianPyr[i].row-zero_pad)&amp;&amp;  
            (n&gt;=zero_pad)&amp;&amp;(n&lt;GaussianPyr[i].col-zero_pad) )  
        {  
            float sigma=( ((GaussianPyr[i].Octave)[j].absolute_sigma) ) / (GaussianPyr[i].subsample);  
            //&#x4EA7;&#x751F;&#x4E8C;&#x7EF4;&#x9AD8;&#x65AF;&#x6A21;&#x677F;  
            CvMat* mat = GaussianKernel2D( sigma );           
            int dim=(int)(0.5 * (mat-&gt;rows));  
            //&#x5206;&#x914D;&#x7528;&#x4E8E;&#x5B58;&#x50A8;Patch&#x5E45;&#x503C;&#x548C;&#x65B9;&#x5411;&#x7684;&#x7A7A;&#x95F4;  
#define MAT(ROW,COL) ((float *)(mat-&gt;data.fl + mat-&gt;step/sizeof(float) *(ROW)))[(COL)]  

            //&#x58F0;&#x660E;&#x65B9;&#x5411;&#x76F4;&#x65B9;&#x56FE;&#x53D8;&#x91CF;  
            double* orienthist = (double *) malloc(36 * sizeof(double));  
            for ( int sw = 0 ; sw &lt; 36 ; ++sw)   
            {  
                orienthist[sw]=0.0;    
            }  
            //&#x5728;&#x7279;&#x5F81;&#x70B9;&#x7684;&#x5468;&#x56F4;&#x7EDF;&#x8BA1;&#x68AF;&#x5EA6;&#x65B9;&#x5411;  
            for (int x=m-dim,mm=0;x&lt;=(m+dim);x++,mm++)   
                for(int y=n-dim,nn=0;y&lt;=(n+dim);y++,nn++)  
                {       
                    //&#x8BA1;&#x7B97;&#x7279;&#x5F81;&#x70B9;&#x5904;&#x7684;&#x5E45;&#x503C;  
                    double dx = 0.5*(ImLevels(i,j,x,y+1)-ImLevels(i,j,x,y-1));  //dx  
                    double dy = 0.5*(ImLevels(i,j,x+1,y)-ImLevels(i,j,x-1,y));  //dy  
                    double mag = sqrt(dx*dx+dy*dy);  //mag  
                    //&#x8BA1;&#x7B97;&#x65B9;&#x5411;  
                    double Ori =atan( 1.0*dy/dx );  
                    int binIdx = FindClosestRotationBin(36, Ori);                   //&#x5F97;&#x5230;&#x79BB;&#x73B0;&#x6709;&#x65B9;&#x5411;&#x6700;&#x8FD1;&#x7684;&#x76F4;&#x65B9;&#x5757;  
                    orienthist[binIdx] = orienthist[binIdx] + 1.0* mag * MAT(mm,nn);//&#x5229;&#x7528;&#x9AD8;&#x65AF;&#x52A0;&#x6743;&#x7D2F;&#x52A0;&#x8FDB;&#x76F4;&#x65B9;&#x56FE;&#x76F8;&#x5E94;&#x7684;&#x5757;  
                }  
                // Find peaks in the orientation histogram using nonmax suppression.  
                AverageWeakBins (orienthist, 36);  
                // find the maximum peak in gradient orientation  
                double maxGrad = 0.0;  
                int maxBin = 0;  
                for (int b = 0 ; b &lt; 36 ; ++b)   
                {  
                    if (orienthist[b] &gt; maxGrad)   
                    {  
                        maxGrad = orienthist[b];  
                        maxBin = b;  
                    }  
                }  
                // First determine the real interpolated peak high at the maximum bin  
                // position, which is guaranteed to be an absolute peak.  
                double maxPeakValue=0.0;  
                double maxDegreeCorrection=0.0;  
                if ( (InterpolateOrientation ( orienthist[maxBin == 0 ? (36 - 1) : (maxBin - 1)],  
                    orienthist[maxBin], orienthist[(maxBin + 1) % 36],  
                    &amp;maxDegreeCorrection, &amp;maxPeakValue)) == false)  
                    printf(&quot;BUG: Parabola fitting broken&quot;);  

                // Now that we know the maximum peak value, we can find other keypoint  
                // orientations, which have to fulfill two criterias:  
                //  
                //  1. They must be a local peak themselves. Else we might add a very  
                //     similar keypoint orientation twice (imagine for example the  
                //     values: 0.4 1.0 0.8, if 1.0 is maximum peak, 0.8 is still added  
                //     with the default threshhold, but the maximum peak orientation  
                //     was already added).  
                //  2. They must have at least peakRelThresh times the maximum peak  
                //     value.  
                bool binIsKeypoint[36];  
                for ( b = 0 ; b &lt; 36 ; ++b)   
                {  
                    binIsKeypoint[b] = false;  
                    // The maximum peak of course is  
                    if (b == maxBin)   
                    {  
                        binIsKeypoint[b] = true;  
                        continue;  
                    }  
                    // Local peaks are, too, in case they fulfill the threshhold  
                    if (orienthist[b] &lt; (peakRelThresh * maxPeakValue))  
                        continue;  
                    int leftI = (b == 0) ? (36 - 1) : (b - 1);  
                    int rightI = (b + 1) % 36;  
                    if (orienthist[b] &lt;= orienthist[leftI] || orienthist[b] &lt;= orienthist[rightI])  
                        continue; // no local peak  
                    binIsKeypoint[b] = true;  
                }  
                // find other possible locations  
                double oneBinRad = (2.0 * PI) / 36;  
                for ( b = 0 ; b &lt; 36 ; ++b)   
                {  
                    if (binIsKeypoint[b] == false)  
                        continue;  
                    int bLeft = (b == 0) ? (36 - 1) : (b - 1);  
                    int bRight = (b + 1) % 36;  
                    // Get an interpolated peak direction and value guess.  
                    double peakValue;  
                    double degreeCorrection;  

                    double maxPeakValue, maxDegreeCorrection;                
                    if (InterpolateOrientation ( orienthist[maxBin == 0 ? (36 - 1) : (maxBin - 1)],  
                        orienthist[maxBin], orienthist[(maxBin + 1) % 36],  
                        &#xB0;reeCorrection, &amp;peakValue) == false)  
                    {  
                        printf(&quot;BUG: Parabola fitting broken&quot;);  
                    }  

                    double degree = (b + degreeCorrection) * oneBinRad - PI;  
                    if (degree &lt; -PI)  
                        degree += 2.0 * PI;  
                    else if (degree &gt; PI)  
                        degree -= 2.0 * PI;  
                    //&#x5B58;&#x50A8;&#x65B9;&#x5411;&#xFF0C;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x5229;&#x7528;&#x68C0;&#x6D4B;&#x5230;&#x7684;&#x94FE;&#x8868;&#x8FDB;&#x884C;&#x8BE5;&#x6B65;&#x4E3B;&#x65B9;&#x5411;&#x7684;&#x6307;&#x5B9A;;  
                    //&#x5206;&#x914D;&#x5185;&#x5B58;&#x91CD;&#x65B0;&#x5B58;&#x50A8;&#x7279;&#x5F81;&#x70B9;  
                    Keypoint k;  
                    /* Allocate memory for the keypoint Descriptor. */  
                    k = (Keypoint) malloc(sizeof(struct KeypointSt));  
                    k-&gt;next = keyDescriptors;  
                    keyDescriptors = k;  
                    k-&gt;descrip = (float*)malloc(LEN * sizeof(float));  
                    k-&gt;row = p-&gt;row;  
                    k-&gt;col = p-&gt;col;  
                    k-&gt;sy = p-&gt;sy;    //&#x884C;  
                    k-&gt;sx = p-&gt;sx;    //&#x5217;  
                    k-&gt;octave = p-&gt;octave;  
                    k-&gt;level = p-&gt;level;  
                    k-&gt;scale = p-&gt;scale;        
                    k-&gt;ori = degree;  
                    k-&gt;mag = peakValue;    
                }//for  
                free(orienthist);  
        }  
        p=p-&gt;next;  
    }   
}  

//&#x5BFB;&#x627E;&#x4E0E;&#x65B9;&#x5411;&#x76F4;&#x65B9;&#x56FE;&#x6700;&#x8FD1;&#x7684;&#x67F1;&#xFF0C;&#x786E;&#x5B9A;&#x5176;index   
int FindClosestRotationBin (int binCount, float angle)  
{  
    angle += CV_PI;  
    angle /= 2.0 * CV_PI;  
    // calculate the aligned bin  
    angle *= binCount;  
    int idx = (int) angle;  
    if (idx == binCount)  
        idx = 0;  
    return (idx);  
}  

// Average the content of the direction bins.  
void AverageWeakBins (double* hist, int binCount)  
{  
    // TODO: make some tests what number of passes is the best. (its clear  
    // one is not enough, as we may have something like  
    // ( 0.4, 0.4, 0.3, 0.4, 0.4 ))  
    for (int sn = 0 ; sn &lt; 2 ; ++sn)   
    {  
        double firstE = hist[0];  
        double last = hist[binCount-1];  
        for (int sw = 0 ; sw &lt; binCount ; ++sw)   
        {  
            double cur = hist[sw];  
            double next = (sw == (binCount - 1)) ? firstE : hist[(sw + 1) % binCount];  
            hist[sw] = (last + cur + next) / 3.0;  
            last = cur;  
        }  
    }  
}  

// Fit a parabol to the three points (-1.0 ; left), (0.0 ; middle) and  
// (1.0 ; right).  
// Formulas:  
// f(x) = a (x - c)^2 + b  
// c is the peak offset (where f&apos;(x) is zero), b is the peak value.  
// In case there is an error false is returned, otherwise a correction  
// value between [-1 ; 1] is returned in &apos;degreeCorrection&apos;, where -1  
// means the peak is located completely at the left vector, and -0.5 just  
// in the middle between left and middle and &gt; 0 to the right side. In  
// &apos;peakValue&apos; the maximum estimated peak value is stored.  
bool InterpolateOrientation (double left, double middle,double right, double *degreeCorrection, double *peakValue)  
{  
    double a = ((left + right) - 2.0 * middle) / 2.0;   //&#x629B;&#x7269;&#x7EBF;&#x634F;&#x5408;&#x7CFB;&#x6570;a  
    // degreeCorrection = peakValue = Double.NaN;  

    // Not a parabol  
    if (a == 0.0)  
        return false;  
    double c = (((left - middle) / a) - 1.0) / 2.0;  
    double b = middle - c * c * a;  
    if (c &lt; -0.5 || c &gt; 0.5)  
        return false;  
    *degreeCorrection = c;  
    *peakValue = b;  
    return true;  
}  

//&#x663E;&#x793A;&#x7279;&#x5F81;&#x70B9;&#x5904;&#x7684;&#x4E3B;&#x65B9;&#x5411;  
void DisplayOrientation (IplImage* image, ImageOctaves *GaussianPyr)  
{  
    Keypoint p = keyDescriptors; // p&#x6307;&#x5411;&#x7B2C;&#x4E00;&#x4E2A;&#x7ED3;&#x70B9;  
    while(p) // &#x6CA1;&#x5230;&#x8868;&#x5C3E;  
    {  
        float scale=(GaussianPyr[p-&gt;octave].Octave)[p-&gt;level].absolute_sigma;  
        float autoscale = 3.0;   
        float uu=autoscale*scale*cos(p-&gt;ori);  
        float vv=autoscale*scale*sin(p-&gt;ori);  
        float x=(p-&gt;col)+uu;  
        float y=(p-&gt;row)+vv;  
        cvLine( image, cvPoint((int)(p-&gt;col),(int)(p-&gt;row)),   
            cvPoint((int)x,(int)y), CV_RGB(255,255,0),  
            1, 8, 0 );  
        // Arrow head parameters  
        float alpha = 0.33; // Size of arrow head relative to the length of the vector  
        float beta = 0.33;  // Width of the base of the arrow head relative to the length  

        float xx0= (p-&gt;col)+uu-alpha*(uu+beta*vv);  
        float yy0= (p-&gt;row)+vv-alpha*(vv-beta*uu);  
        float xx1= (p-&gt;col)+uu-alpha*(uu-beta*vv);  
        float yy1= (p-&gt;row)+vv-alpha*(vv+beta*uu);  
        cvLine( image, cvPoint((int)xx0,(int)yy0),   
            cvPoint((int)x,(int)y), CV_RGB(255,255,0),  
            1, 8, 0 );  
        cvLine( image, cvPoint((int)xx1,(int)yy1),   
            cvPoint((int)x,(int)y), CV_RGB(255,255,0),  
            1, 8, 0 );  
        p=p-&gt;next;  
    }   
}
</code></pre>
<h4 id="sift&#x7B97;&#x6CD5;&#x7B2C;&#x4E94;&#x6B65;"><strong>SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E94;&#x6B65;</strong></h4>
<p>SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E94;&#x6B65;&#xFF1A;&#x62BD;&#x53D6;&#x5404;&#x4E2A;&#x7279;&#x5F81;&#x70B9;&#x5904;&#x7684;&#x7279;&#x5F81;&#x63CF;&#x8FF0;&#x5B57;&#xFF0C;&#x786E;&#x5B9A;&#x7279;&#x5F81;&#x70B9;&#x7684;&#x63CF;&#x8FF0;&#x5B57;&#x3002;&#x63CF;&#x8FF0;&#x5B57;&#x662F;Patch&#x7F51;&#x683C;&#x5185;&#x68AF;&#x5EA6;&#x65B9;&#x5411;&#x7684;&#x63CF;&#x8FF0;&#xFF0C;&#x65CB;&#x8F6C;&#x7F51;&#x683C;&#x5230;&#x4E3B;&#x65B9;&#x5411;&#xFF0C;&#x63D2;&#x503C;&#x5F97;&#x5230;&#x7F51;&#x683C;&#x5904;&#x68AF;&#x5EA6;&#x503C;&#x3002;</p>
<p>&#x4E00;&#x4E2A;&#x7279;&#x5F81;&#x70B9;&#x53EF;&#x4EE5;&#x7528;2<em>2</em>8=32&#x7EF4;&#x7684;&#x5411;&#x91CF;&#xFF0C;&#x4E5F;&#x53EF;&#x4EE5;&#x7528;4<em>4</em>8=128&#x7EF4;&#x7684;&#x5411;&#x91CF;&#x66F4;&#x7CBE;&#x786E;&#x7684;&#x8FDB;&#x884C;&#x63CF;&#x8FF0;&#x3002;</p>
<pre><code class="lang-c">void ExtractFeatureDescriptors(int numoctaves, ImageOctaves *GaussianPyr)  
{  
    // The orientation histograms have 8 bins  
    float orient_bin_spacing = PI/4;  
    float orient_angles[8]={-PI,-PI+orient_bin_spacing,-PI*0.5, -orient_bin_spacing,  
        0.0, orient_bin_spacing, PI*0.5,  PI+orient_bin_spacing};  
    //&#x4EA7;&#x751F;&#x63CF;&#x8FF0;&#x5B57;&#x4E2D;&#x5FC3;&#x5404;&#x70B9;&#x5750;&#x6807;  
    float *feat_grid=(float *) malloc( 2*16 * sizeof(float));  
    for (int i=0;i&lt;GridSpacing;i++)  
    {  
        for (int j=0;j&lt;2*GridSpacing;++j,++j)  
        {  
            feat_grid[i*2*GridSpacing+j]=-6.0+i*GridSpacing;  
            feat_grid[i*2*GridSpacing+j+1]=-6.0+0.5*j*GridSpacing;  
        }  
    }  
    //&#x4EA7;&#x751F;&#x7F51;&#x683C;  
    float *feat_samples=(float *) malloc( 2*256 * sizeof(float));  
    for ( i=0;i&lt;4*GridSpacing;i++)  
    {  
        for (int j=0;j&lt;8*GridSpacing;j+=2)  
        {  
            feat_samples[i*8*GridSpacing+j]=-(2*GridSpacing-0.5)+i;  
            feat_samples[i*8*GridSpacing+j+1]=-(2*GridSpacing-0.5)+0.5*j;  
        }  
    }  
    float feat_window = 2*GridSpacing;  
    Keypoint p = keyDescriptors; // p&#x6307;&#x5411;&#x7B2C;&#x4E00;&#x4E2A;&#x7ED3;&#x70B9;  
    while(p) // &#x6CA1;&#x5230;&#x8868;&#x5C3E;  
    {  
        float scale=(GaussianPyr[p-&gt;octave].Octave)[p-&gt;level].absolute_sigma;  

        float sine = sin(p-&gt;ori);  
        float cosine = cos(p-&gt;ori);    
        //&#x8BA1;&#x7B97;&#x4E2D;&#x5FC3;&#x70B9;&#x5750;&#x6807;&#x65CB;&#x8F6C;&#x4E4B;&#x540E;&#x7684;&#x4F4D;&#x7F6E;  
        float *featcenter=(float *) malloc( 2*16 * sizeof(float));  
        for (int i=0;i&lt;GridSpacing;i++)  
        {  
            for (int j=0;j&lt;2*GridSpacing;j+=2)  
            {  
                float x=feat_grid[i*2*GridSpacing+j];  
                float y=feat_grid[i*2*GridSpacing+j+1];  
                featcenter[i*2*GridSpacing+j]=((cosine * x + sine * y) + p-&gt;sx);  
                featcenter[i*2*GridSpacing+j+1]=((-sine * x + cosine * y) + p-&gt;sy);  
            }  
        }  
        // calculate sample window coordinates (rotated along keypoint)  
        float *feat=(float *) malloc( 2*256 * sizeof(float));  
        for ( i=0;i&lt;64*GridSpacing;i++,i++)  
        {  
            float x=feat_samples[i];  
            float y=feat_samples[i+1];  
            feat[i]=((cosine * x + sine * y) + p-&gt;sx);  
            feat[i+1]=((-sine * x + cosine * y) + p-&gt;sy);  
        }  
        //Initialize the feature descriptor.  
        float *feat_desc = (float *) malloc( 128 * sizeof(float));  
        for (i=0;i&lt;128;i++)  
        {  
            feat_desc[i]=0.0;  
            // printf(&quot;%f  &quot;,feat_desc[i]);    
        }  
        //printf(&quot;/n&quot;);  
        for ( i=0;i&lt;512;++i,++i)  
        {  
            float x_sample = feat[i];  
            float y_sample = feat[i+1];  
            // Interpolate the gradient at the sample position  
            /* 
            0   1   0 
            1   *   1 
            0   1   0   &#x5177;&#x4F53;&#x63D2;&#x503C;&#x7B56;&#x7565;&#x5982;&#x56FE;&#x793A; 
            */  
            float sample12=getPixelBI(((GaussianPyr[p-&gt;octave].Octave)[p-&gt;level]).Level, x_sample, y_sample-1);  
            float sample21=getPixelBI(((GaussianPyr[p-&gt;octave].Octave)[p-&gt;level]).Level, x_sample-1, y_sample);   
            float sample22=getPixelBI(((GaussianPyr[p-&gt;octave].Octave)[p-&gt;level]).Level, x_sample, y_sample);   
            float sample23=getPixelBI(((GaussianPyr[p-&gt;octave].Octave)[p-&gt;level]).Level, x_sample+1, y_sample);   
            float sample32=getPixelBI(((GaussianPyr[p-&gt;octave].Octave)[p-&gt;level]).Level, x_sample, y_sample+1);   
            //float diff_x = 0.5*(sample23 - sample21);  
            //float diff_y = 0.5*(sample32 - sample12);  
            float diff_x = sample23 - sample21;  
            float diff_y = sample32 - sample12;  
            float mag_sample = sqrt( diff_x*diff_x + diff_y*diff_y );  
            float grad_sample = atan( diff_y / diff_x );  
            if(grad_sample == CV_PI)  
                grad_sample = -CV_PI;  
            // Compute the weighting for the x and y dimensions.  
            float *x_wght=(float *) malloc( GridSpacing * GridSpacing * sizeof(float));  
            float *y_wght=(float *) malloc( GridSpacing * GridSpacing * sizeof(float));  
            float *pos_wght=(float *) malloc( 8*GridSpacing * GridSpacing * sizeof(float));;  
            for (int m=0;m&lt;32;++m,++m)  
            {  
                float x=featcenter[m];  
                float y=featcenter[m+1];  
                x_wght[m/2] = max(1 - (fabs(x - x_sample)*1.0/GridSpacing), 0);  
                y_wght[m/2] = max(1 - (fabs(y - y_sample)*1.0/GridSpacing), 0);   

            }  
            for ( m=0;m&lt;16;++m)  
                for (int n=0;n&lt;8;++n)  
                    pos_wght[m*8+n]=x_wght[m]*y_wght[m];  
            free(x_wght);  
            free(y_wght);  
            //&#x8BA1;&#x7B97;&#x65B9;&#x5411;&#x7684;&#x52A0;&#x6743;&#xFF0C;&#x9996;&#x5148;&#x65CB;&#x8F6C;&#x68AF;&#x5EA6;&#x573A;&#x5230;&#x4E3B;&#x65B9;&#x5411;&#xFF0C;&#x7136;&#x540E;&#x8BA1;&#x7B97;&#x5DEE;&#x5F02;   
            float diff[8],orient_wght[128];  
            for ( m=0;m&lt;8;++m)  
            {   
                float angle = grad_sample-(p-&gt;ori)-orient_angles[m]+CV_PI;  
                float temp = angle / (2.0 * CV_PI);  
                angle -= (int)(temp) * (2.0 * CV_PI);  
                diff[m]= angle - CV_PI;  
            }  
            // Compute the gaussian weighting.  
            float x=p-&gt;sx;  
            float y=p-&gt;sy;  
            float g = exp(-((x_sample-x)*(x_sample-x)+(y_sample-y)*(y_sample-y))/(2*feat_window*feat_window))/(2*CV_PI*feat_window*feat_window);  

            for ( m=0;m&lt;128;++m)  
            {  
                orient_wght[m] = max((1.0 - 1.0*fabs(diff[m%8])/orient_bin_spacing),0);  
                feat_desc[m] = feat_desc[m] + orient_wght[m]*pos_wght[m]*g*mag_sample;  
            }  
            free(pos_wght);     
        }  
        free(feat);  
        free(featcenter);  
        float norm=GetVecNorm( feat_desc, 128);  
        for (int m=0;m&lt;128;m++)  
        {  
            feat_desc[m]/=norm;  
            if (feat_desc[m]&gt;0.2)  
                feat_desc[m]=0.2;  
        }  
        norm=GetVecNorm( feat_desc, 128);  
        for ( m=0;m&lt;128;m++)  
        {  
            feat_desc[m]/=norm;  
            printf(&quot;%f  &quot;,feat_desc[m]);    
        }  
        printf(&quot;/n&quot;);  
        p-&gt;descrip = feat_desc;  
        p=p-&gt;next;  
    }  
    free(feat_grid);  
    free(feat_samples);  
}  

//&#x4E3A;&#x4E86;&#x663E;&#x793A;&#x56FE;&#x8C61;&#x91D1;&#x5B57;&#x5854;&#xFF0C;&#x800C;&#x4F5C;&#x7684;&#x56FE;&#x50CF;&#x6C34;&#x5E73;&#x62FC;&#x63A5;  
CvMat* MosaicHorizen( CvMat* im1, CvMat* im2 )  
{  
    int row,col;  
    CvMat *mosaic = cvCreateMat( max(im1-&gt;rows,im2-&gt;rows),(im1-&gt;cols+im2-&gt;cols),CV_32FC1);  
#define Mosaic(ROW,COL) ((float*)(mosaic-&gt;data.fl + mosaic-&gt;step/sizeof(float)*(ROW)))[(COL)]  
#define Im11Mat(ROW,COL) ((float *)(im1-&gt;data.fl + im1-&gt;step/sizeof(float) *(ROW)))[(COL)]  
#define Im22Mat(ROW,COL) ((float *)(im2-&gt;data.fl + im2-&gt;step/sizeof(float) *(ROW)))[(COL)]  
    cvZero(mosaic);  
    /* Copy images into mosaic1. */  
    for ( row = 0; row &lt; im1-&gt;rows; row++)  
        for ( col = 0; col &lt; im1-&gt;cols; col++)  
            Mosaic(row,col)=Im11Mat(row,col) ;  
    for (  row = 0; row &lt; im2-&gt;rows; row++)  
        for (  col = 0; col &lt; im2-&gt;cols; col++)  
            Mosaic(row, (col+im1-&gt;cols) )= Im22Mat(row,col) ;  
    return mosaic;  
}  

//&#x4E3A;&#x4E86;&#x663E;&#x793A;&#x56FE;&#x8C61;&#x91D1;&#x5B57;&#x5854;&#xFF0C;&#x800C;&#x4F5C;&#x7684;&#x56FE;&#x50CF;&#x5782;&#x76F4;&#x62FC;&#x63A5;  
CvMat* MosaicVertical( CvMat* im1, CvMat* im2 )  
{  
    int row,col;  
    CvMat *mosaic = cvCreateMat(im1-&gt;rows+im2-&gt;rows,max(im1-&gt;cols,im2-&gt;cols), CV_32FC1);  
#define Mosaic(ROW,COL) ((float*)(mosaic-&gt;data.fl + mosaic-&gt;step/sizeof(float)*(ROW)))[(COL)]  
#define Im11Mat(ROW,COL) ((float *)(im1-&gt;data.fl + im1-&gt;step/sizeof(float) *(ROW)))[(COL)]  
#define Im22Mat(ROW,COL) ((float *)(im2-&gt;data.fl + im2-&gt;step/sizeof(float) *(ROW)))[(COL)]  
    cvZero(mosaic);  

    /* Copy images into mosaic1. */  
    for ( row = 0; row &lt; im1-&gt;rows; row++)  
        for ( col = 0; col &lt; im1-&gt;cols; col++)  
            Mosaic(row,col)= Im11Mat(row,col) ;  
    for ( row = 0; row &lt; im2-&gt;rows; row++)  
        for ( col = 0; col &lt; im2-&gt;cols; col++)  
            Mosaic((row+im1-&gt;rows),col)=Im22Mat(row,col) ;  

    return mosaic;  
}
</code></pre>
<p>ok&#xFF0C;&#x4E3A;&#x4E86;&#x7248;&#x8FF0;&#x6E05;&#x6670;&#xFF0C;&#x518D;&#x8D34;&#x4E00;&#x4E0B;&#x4E0A;&#x6587;&#x6240;&#x8FF0;&#x7684;&#x4E3B;&#x51FD;&#x6570;&#xFF08;&#x6CE8;&#xFF0C;&#x4E0A;&#x6587;&#x5DF2;&#x8D34;&#x51FA;&#xFF0C;&#x6B64;&#x662F;&#x4E3A;&#x4E86;&#x7248;&#x8FF0;&#x6E05;&#x6670;&#xFF0C;&#x91CD;&#x590D;&#x9020;&#x8F6E;&#xFF09;&#xFF1A;</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">void</span> )</span>  
</span>{  
    <span class="hljs-comment">//&#x58F0;&#x660E;&#x5F53;&#x524D;&#x5E27;IplImage&#x6307;&#x9488;  </span>
    IplImage* src = <span class="hljs-literal">NULL</span>;   
    IplImage* image1 = <span class="hljs-literal">NULL</span>;   
    IplImage* grey_im1 = <span class="hljs-literal">NULL</span>;   
    IplImage* DoubleSizeImage = <span class="hljs-literal">NULL</span>;  

    IplImage* mosaic1 = <span class="hljs-literal">NULL</span>;   
    IplImage* mosaic2 = <span class="hljs-literal">NULL</span>;   

    CvMat* mosaicHorizen1 = <span class="hljs-literal">NULL</span>;  
    CvMat* mosaicHorizen2 = <span class="hljs-literal">NULL</span>;  
    CvMat* mosaicVertical1 = <span class="hljs-literal">NULL</span>;  

    CvMat* image1Mat = <span class="hljs-literal">NULL</span>;  
    CvMat* tempMat=<span class="hljs-literal">NULL</span>;  

    ImageOctaves *Gaussianpyr;  
    <span class="hljs-keyword">int</span> rows,cols;  

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> Im1Mat(ROW,COL) ((float *)(image1Mat-&gt;data.fl + image1Mat-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>

    <span class="hljs-comment">//&#x7070;&#x5EA6;&#x56FE;&#x8C61;&#x50CF;&#x7D20;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;  </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> Im1B(ROW,COL) ((uchar*)(image1-&gt;imageData + image1-&gt;widthStep*(ROW)))[(COL)*<span class="hljs-number">3</span>]  </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> Im1G(ROW,COL) ((uchar*)(image1-&gt;imageData + image1-&gt;widthStep*(ROW)))[(COL)*<span class="hljs-number">3</span>+<span class="hljs-number">1</span>]  </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> Im1R(ROW,COL) ((uchar*)(image1-&gt;imageData + image1-&gt;widthStep*(ROW)))[(COL)*<span class="hljs-number">3</span>+<span class="hljs-number">2</span>]  </span>

    storage = cvCreateMemStorage(<span class="hljs-number">0</span>);   

    <span class="hljs-comment">//&#x8BFB;&#x53D6;&#x56FE;&#x7247;  </span>
    <span class="hljs-keyword">if</span>( (src = cvLoadImage( <span class="hljs-string">&quot;street1.jpg&quot;</span>, <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span> )  <span class="hljs-comment">// test1.jpg einstein.pgm back1.bmp  </span>
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  

    <span class="hljs-comment">//&#x4E3A;&#x56FE;&#x50CF;&#x5206;&#x914D;&#x5185;&#x5B58;   </span>
    image1 = cvCreateImage(cvSize(src-&gt;width, src-&gt;height),  IPL_DEPTH_8U,<span class="hljs-number">3</span>);  
    grey_im1 = cvCreateImage(cvSize(src-&gt;width, src-&gt;height),  IPL_DEPTH_8U,<span class="hljs-number">1</span>);  
    DoubleSizeImage = cvCreateImage(cvSize(<span class="hljs-number">2</span>*(src-&gt;width), <span class="hljs-number">2</span>*(src-&gt;height)),  IPL_DEPTH_8U,<span class="hljs-number">3</span>);  

    <span class="hljs-comment">//&#x4E3A;&#x56FE;&#x50CF;&#x9635;&#x5217;&#x5206;&#x914D;&#x5185;&#x5B58;&#xFF0C;&#x5047;&#x8BBE;&#x4E24;&#x5E45;&#x56FE;&#x50CF;&#x7684;&#x5927;&#x5C0F;&#x76F8;&#x540C;&#xFF0C;tempMat&#x8DDF;&#x968F;image1&#x7684;&#x5927;&#x5C0F;  </span>
    image1Mat = cvCreateMat(src-&gt;height, src-&gt;width, CV_32FC1);  
    <span class="hljs-comment">//&#x8F6C;&#x5316;&#x6210;&#x5355;&#x901A;&#x9053;&#x56FE;&#x50CF;&#x518D;&#x5904;&#x7406;  </span>
    cvCvtColor(src, grey_im1, CV_BGR2GRAY);  
    <span class="hljs-comment">//&#x8F6C;&#x6362;&#x8FDB;&#x5165;Mat&#x6570;&#x636E;&#x7ED3;&#x6784;,&#x56FE;&#x50CF;&#x64CD;&#x4F5C;&#x4F7F;&#x7528;&#x7684;&#x662F;&#x6D6E;&#x70B9;&#x578B;&#x64CD;&#x4F5C;  </span>
    cvConvert(grey_im1, image1Mat);  

    <span class="hljs-keyword">double</span> t = (<span class="hljs-keyword">double</span>)cvGetTickCount();  
    <span class="hljs-comment">//&#x56FE;&#x50CF;&#x5F52;&#x4E00;&#x5316;  </span>
    cvConvertScale( image1Mat, image1Mat, <span class="hljs-number">1.0</span>/<span class="hljs-number">255</span>, <span class="hljs-number">0</span> );  

    <span class="hljs-keyword">int</span> dim = min(image1Mat-&gt;rows, image1Mat-&gt;cols);  
    numoctaves = (<span class="hljs-keyword">int</span>) (<span class="hljs-built_in">log</span>((<span class="hljs-keyword">double</span>) dim) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2.0</span>)) - <span class="hljs-number">2</span>;    <span class="hljs-comment">//&#x91D1;&#x5B57;&#x5854;&#x9636;&#x6570;  </span>
    numoctaves = min(numoctaves, MAXOCTAVES);  

    <span class="hljs-comment">//SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E00;&#x6B65;&#xFF0C;&#x9884;&#x6EE4;&#x6CE2;&#x9664;&#x566A;&#x58F0;&#xFF0C;&#x5EFA;&#x7ACB;&#x91D1;&#x5B57;&#x5854;&#x5E95;&#x5C42;  </span>
    tempMat = ScaleInitImage(image1Mat) ;  
    <span class="hljs-comment">//SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E8C;&#x6B65;&#xFF0C;&#x5EFA;&#x7ACB;Guassian&#x91D1;&#x5B57;&#x5854;&#x548C;DOG&#x91D1;&#x5B57;&#x5854;  </span>
    Gaussianpyr = BuildGaussianOctaves(tempMat) ;  

    t = (<span class="hljs-keyword">double</span>)cvGetTickCount() - t;  
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;the time of build Gaussian pyramid and DOG pyramid is %.1f/n&quot;</span>, t/(cvGetTickFrequency()*<span class="hljs-number">1000.</span>) );  

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> ImLevels(OCTAVE,LEVEL,ROW,COL) ((float *)(Gaussianpyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;data.fl + Gaussianpyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
    <span class="hljs-comment">//&#x663E;&#x793A;&#x9AD8;&#x65AF;&#x91D1;&#x5B57;&#x5854;  </span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;numoctaves;i++)  
    {  
        <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span>)  
        {  
            mosaicHorizen1=MosaicHorizen( (Gaussianpyr[<span class="hljs-number">0</span>].Octave)[<span class="hljs-number">0</span>].Level, (Gaussianpyr[<span class="hljs-number">0</span>].Octave)[<span class="hljs-number">1</span>].Level );  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;j&lt;SCALESPEROCTAVE+<span class="hljs-number">3</span>;j++)  
                mosaicHorizen1=MosaicHorizen( mosaicHorizen1, (Gaussianpyr[<span class="hljs-number">0</span>].Octave)[j].Level );  
            <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>;j&lt;NUMSIZE;j++)  
                mosaicHorizen1=halfSizeImage(mosaicHorizen1);  
        }  
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i==<span class="hljs-number">1</span>)  
        {  
            mosaicHorizen2=MosaicHorizen( (Gaussianpyr[<span class="hljs-number">1</span>].Octave)[<span class="hljs-number">0</span>].Level, (Gaussianpyr[<span class="hljs-number">1</span>].Octave)[<span class="hljs-number">1</span>].Level );  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;j&lt;SCALESPEROCTAVE+<span class="hljs-number">3</span>;j++)  
                mosaicHorizen2=MosaicHorizen( mosaicHorizen2, (Gaussianpyr[<span class="hljs-number">1</span>].Octave)[j].Level );  
            <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>;j&lt;NUMSIZE;j++)  
                mosaicHorizen2=halfSizeImage(mosaicHorizen2);  
            mosaicVertical1=MosaicVertical( mosaicHorizen1, mosaicHorizen2 );  
        }  
        <span class="hljs-keyword">else</span>  
        {  
            mosaicHorizen1=MosaicHorizen( (Gaussianpyr[i].Octave)[<span class="hljs-number">0</span>].Level, (Gaussianpyr[i].Octave)[<span class="hljs-number">1</span>].Level );  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;j&lt;SCALESPEROCTAVE+<span class="hljs-number">3</span>;j++)  
                mosaicHorizen1=MosaicHorizen( mosaicHorizen1, (Gaussianpyr[i].Octave)[j].Level );  
            <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>;j&lt;NUMSIZE;j++)  
                mosaicHorizen1=halfSizeImage(mosaicHorizen1);  
            mosaicVertical1=MosaicVertical( mosaicVertical1, mosaicHorizen1 );  
        }  
    }  
    mosaic1 = cvCreateImage(cvSize(mosaicVertical1-&gt;width, mosaicVertical1-&gt;height),  IPL_DEPTH_8U,<span class="hljs-number">1</span>);  
    cvConvertScale( mosaicVertical1, mosaicVertical1, <span class="hljs-number">255.0</span>, <span class="hljs-number">0</span> );  
    cvConvertScaleAbs( mosaicVertical1, mosaic1, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> );  

    <span class="hljs-comment">//  cvSaveImage(&quot;GaussianPyramid of me.jpg&quot;,mosaic1);  </span>
    cvNamedWindow(<span class="hljs-string">&quot;mosaic1&quot;</span>,<span class="hljs-number">1</span>);  
    cvShowImage(<span class="hljs-string">&quot;mosaic1&quot;</span>, mosaic1);  
    cvWaitKey(<span class="hljs-number">0</span>);  
    cvDestroyWindow(<span class="hljs-string">&quot;mosaic1&quot;</span>);  
    <span class="hljs-comment">//&#x663E;&#x793A;DOG&#x91D1;&#x5B57;&#x5854;  </span>
    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;numoctaves;i++)  
    {  
        <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span>)  
        {  
            mosaicHorizen1=MosaicHorizen( (DOGoctaves[<span class="hljs-number">0</span>].Octave)[<span class="hljs-number">0</span>].Level, (DOGoctaves[<span class="hljs-number">0</span>].Octave)[<span class="hljs-number">1</span>].Level );  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;j&lt;SCALESPEROCTAVE+<span class="hljs-number">2</span>;j++)  
                mosaicHorizen1=MosaicHorizen( mosaicHorizen1, (DOGoctaves[<span class="hljs-number">0</span>].Octave)[j].Level );  
            <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>;j&lt;NUMSIZE;j++)  
                mosaicHorizen1=halfSizeImage(mosaicHorizen1);  
        }  
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i==<span class="hljs-number">1</span>)  
        {  
            mosaicHorizen2=MosaicHorizen( (DOGoctaves[<span class="hljs-number">1</span>].Octave)[<span class="hljs-number">0</span>].Level, (DOGoctaves[<span class="hljs-number">1</span>].Octave)[<span class="hljs-number">1</span>].Level );  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;j&lt;SCALESPEROCTAVE+<span class="hljs-number">2</span>;j++)  
                mosaicHorizen2=MosaicHorizen( mosaicHorizen2, (DOGoctaves[<span class="hljs-number">1</span>].Octave)[j].Level );  
            <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>;j&lt;NUMSIZE;j++)  
                mosaicHorizen2=halfSizeImage(mosaicHorizen2);  
            mosaicVertical1=MosaicVertical( mosaicHorizen1, mosaicHorizen2 );  
        }  
        <span class="hljs-keyword">else</span>  
        {  
            mosaicHorizen1=MosaicHorizen( (DOGoctaves[i].Octave)[<span class="hljs-number">0</span>].Level, (DOGoctaves[i].Octave)[<span class="hljs-number">1</span>].Level );  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;j&lt;SCALESPEROCTAVE+<span class="hljs-number">2</span>;j++)  
                mosaicHorizen1=MosaicHorizen( mosaicHorizen1, (DOGoctaves[i].Octave)[j].Level );  
            <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>;j&lt;NUMSIZE;j++)  
                mosaicHorizen1=halfSizeImage(mosaicHorizen1);  
            mosaicVertical1=MosaicVertical( mosaicVertical1, mosaicHorizen1 );  
        }  
    }  
    <span class="hljs-comment">//&#x8003;&#x8651;&#x5230;DOG&#x91D1;&#x5B57;&#x5854;&#x5404;&#x5C42;&#x56FE;&#x50CF;&#x90FD;&#x4F1A;&#x6709;&#x6B63;&#x8D1F;&#xFF0C;&#x6240;&#x4EE5;&#xFF0C;&#x5FC5;&#x987B;&#x5BFB;&#x627E;&#x6700;&#x8D1F;&#x7684;&#xFF0C;&#x4EE5;&#x5C06;&#x6240;&#x6709;&#x56FE;&#x50CF;&#x62AC;&#x9AD8;&#x4E00;&#x4E2A;&#x53F0;&#x9636;&#x53BB;&#x663E;&#x793A;  </span>
    <span class="hljs-keyword">double</span> min_val=<span class="hljs-number">0</span>;  
    <span class="hljs-keyword">double</span> max_val=<span class="hljs-number">0</span>;  
    cvMinMaxLoc( mosaicVertical1, &amp;min_val, &amp;max_val,<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span> );  
    <span class="hljs-keyword">if</span> ( min_val&lt;<span class="hljs-number">0.0</span> )  
        cvAddS( mosaicVertical1, cvScalarAll( (-<span class="hljs-number">1.0</span>)*min_val ), mosaicVertical1, <span class="hljs-literal">NULL</span> );  
    mosaic2 = cvCreateImage(cvSize(mosaicVertical1-&gt;width, mosaicVertical1-&gt;height),  IPL_DEPTH_8U,<span class="hljs-number">1</span>);  
    cvConvertScale( mosaicVertical1, mosaicVertical1, <span class="hljs-number">255.0</span>/(max_val-min_val), <span class="hljs-number">0</span> );  
    cvConvertScaleAbs( mosaicVertical1, mosaic2, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> );  

    <span class="hljs-comment">//  cvSaveImage(&quot;DOGPyramid of me.jpg&quot;,mosaic2);  </span>
    cvNamedWindow(<span class="hljs-string">&quot;mosaic1&quot;</span>,<span class="hljs-number">1</span>);  
    cvShowImage(<span class="hljs-string">&quot;mosaic1&quot;</span>, mosaic2);  
    cvWaitKey(<span class="hljs-number">0</span>);  

    <span class="hljs-comment">//SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E09;&#x6B65;&#xFF1A;&#x7279;&#x5F81;&#x70B9;&#x4F4D;&#x7F6E;&#x68C0;&#x6D4B;&#xFF0C;&#x6700;&#x540E;&#x786E;&#x5B9A;&#x7279;&#x5F81;&#x70B9;&#x7684;&#x4F4D;&#x7F6E;  </span>
    <span class="hljs-keyword">int</span> keycount=DetectKeypoint(numoctaves, Gaussianpyr);  
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the keypoints number are %d ;/n&quot;</span>, keycount);  
    cvCopy(src,image1,<span class="hljs-literal">NULL</span>);  
    DisplayKeypointLocation( image1 ,Gaussianpyr);  

    cvPyrUp( image1, DoubleSizeImage, CV_GAUSSIAN_5x5 );  
    cvNamedWindow(<span class="hljs-string">&quot;image1&quot;</span>,<span class="hljs-number">1</span>);  
    cvShowImage(<span class="hljs-string">&quot;image1&quot;</span>, DoubleSizeImage);  
    cvWaitKey(<span class="hljs-number">0</span>);    
    cvDestroyWindow(<span class="hljs-string">&quot;image1&quot;</span>);  

    <span class="hljs-comment">//SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x56DB;&#x6B65;&#xFF1A;&#x8BA1;&#x7B97;&#x9AD8;&#x65AF;&#x56FE;&#x50CF;&#x7684;&#x68AF;&#x5EA6;&#x65B9;&#x5411;&#x548C;&#x5E45;&#x503C;&#xFF0C;&#x8BA1;&#x7B97;&#x5404;&#x4E2A;&#x7279;&#x5F81;&#x70B9;&#x7684;&#x4E3B;&#x65B9;&#x5411;  </span>
    ComputeGrad_DirecandMag(numoctaves, Gaussianpyr);  
    AssignTheMainOrientation( numoctaves, Gaussianpyr,mag_pyr,grad_pyr);  
    cvCopy(src,image1,<span class="hljs-literal">NULL</span>);  
    DisplayOrientation ( image1, Gaussianpyr);  

    <span class="hljs-comment">//  cvPyrUp( image1, DoubleSizeImage, CV_GAUSSIAN_5x5 );  </span>
    cvNamedWindow(<span class="hljs-string">&quot;image1&quot;</span>,<span class="hljs-number">1</span>);  
    <span class="hljs-comment">//  cvResizeWindow(&quot;image1&quot;, 2*(image1-&gt;width), 2*(image1-&gt;height) );  </span>
    cvShowImage(<span class="hljs-string">&quot;image1&quot;</span>, image1);  
    cvWaitKey(<span class="hljs-number">0</span>);  

    <span class="hljs-comment">//SIFT&#x7B97;&#x6CD5;&#x7B2C;&#x4E94;&#x6B65;&#xFF1A;&#x62BD;&#x53D6;&#x5404;&#x4E2A;&#x7279;&#x5F81;&#x70B9;&#x5904;&#x7684;&#x7279;&#x5F81;&#x63CF;&#x8FF0;&#x5B57;  </span>
    ExtractFeatureDescriptors( numoctaves, Gaussianpyr);  
    cvWaitKey(<span class="hljs-number">0</span>);  

    <span class="hljs-comment">//&#x9500;&#x6BC1;&#x7A97;&#x53E3;  </span>
    cvDestroyWindow(<span class="hljs-string">&quot;image1&quot;</span>);  
    cvDestroyWindow(<span class="hljs-string">&quot;mosaic1&quot;</span>);  
    <span class="hljs-comment">//&#x91CA;&#x653E;&#x56FE;&#x50CF;  </span>
    cvReleaseImage(&amp;image1);  
    cvReleaseImage(&amp;grey_im1);  
    cvReleaseImage(&amp;mosaic1);  
    cvReleaseImage(&amp;mosaic2);  
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}
</code></pre>
<p>&#x6700;&#x540E;&#xFF0C;&#x518D;&#x770B;&#x4E00;&#x4E0B;&#xFF0C;&#x8FD0;&#x884C;&#x6548;&#x679C;&#xFF08;&#x56FE;&#x4E2D;&#x7F8E;&#x5973;&#x4E3A;&#x8001;&#x4E61;+&#x670B;&#x53CB;&#xFF0C;&#x4F55;&#x59D0;08&#x5E74;&#x7167;&#xFF09;&#xFF1A;</p>
<p><img src="../images/10/10.1.3/10.1.3.1.jpg" alt=""></p>
<p><img src="../images/10/10.1.3/10.1.3.2.jpg" alt=""></p>
<p><img src="../images/10/10.1.3/10.1.3.3.jpg" alt=""></p>
<p><img src="../images/10/10.1.3/10.1.3.4.jpg" alt=""></p>
<p><img src="../images/10/10.1.3/10.1.3.5.jpg" alt=""></p>
<p>&#x5B8C;&#x3002;</p>
<p><strong>updated</strong></p>
<p>&#x6709;&#x5F88;&#x591A;&#x670B;&#x53CB;&#x90FD;&#x5728;&#x672C;&#x6587;&#x8BC4;&#x8BBA;&#x4E0B;&#x8981;&#x6C42;&#x8981;&#x672C;&#x7A0B;&#x5E8F;&#x7684;&#x5B8C;&#x6574;&#x6E90;&#x7801;&#x5305;&#xFF08;&#x6CE8;&#xFF1A;&#x672C;&#x6587;&#x4EE3;&#x7801;&#x672A;&#x8D34;&#x5168;&#xFF0C;&#x590D;&#x5236;&#x7C98;&#x8D34;&#x7F16;&#x8BD1;&#x80AF;&#x5B9A;&#x8BF8;&#x591A;&#x9519;&#x8BEF;&#xFF09;&#xFF0C;&#x4F46;&#x7531;&#x4E8E;&#x65F6;&#x9694;&#x592A;&#x4E45;&#xFF0C;&#x8FD9;&#x4EFD;&#x4EE3;&#x7801;&#x6211;&#x81EA;&#x5DF1;&#x4E5F;&#x627E;&#x4E0D;&#x5230;&#x4E86;&#xFF0C;&#x4E0D;&#x8FC7;&#xFF0C;&#x6211;&#x53EF;&#x4EE5;&#x63D0;&#x4F9B;&#x4E00;&#x4EFD;sift + KD + BBF&#xFF0C;&#x4E14;&#x53EF;&#x4EE5;&#x7F16;&#x8BD1;&#x6B63;&#x786E;&#x7684;&#x4EE3;&#x7801;&#x4F9B;&#x5927;&#x5BB6;&#x53C2;&#x8003;&#x5B66;&#x4E60;&#xFF0C;&#x6709;pudn&#x5E10;&#x53F7;&#x7684;&#x670B;&#x53CB;&#x53EF;&#x4EE5;&#x524D;&#x53BB;&#x4E0B;&#x8F7D;&#xFF1A;<a href="tp://www.pudn.com/downloads340/sourcecode/graph/texture_mapping/detail1486667.html" target="_blank">http://www.pudn.com/downloads340/sourcecode/graph/texture_mapping/detail1486667.html </a>&#xFF08;&#x6CA1;&#x6709;pudn&#x8D26;&#x53F7;&#x7684;&#x540C;&#x5B66;&#x8BF7;&#x52A0;&#x7FA4;&#xFF1A;169056165&#xFF0C;&#x9A8C;&#x8BC1;&#x4FE1;&#x606F;&#xFF1A;sift&#xFF0C;&#x81F3;&#x7FA4;&#x5171;&#x4EAB;&#x4E0B;&#x8F7D;&#xFF09;&#xFF0C;&#x7136;&#x540E;&#x7528;&#x4E24;&#x5E45;&#x4E0D;&#x540C;&#x7684;&#x56FE;&#x7247;&#x505A;&#x4E86;&#x4E0B;&#x5339;&#x914D;&#xFF08;&#x5F53;&#x7136;&#xFF0C;&#x8FD0;&#x884C;&#x7ED3;&#x679C;&#x663E;&#x793A;&#x662F;&#x4E0D;&#x5339;&#x914D;&#x7684;&#xFF09;&#xFF0C;&#x6548;&#x679C;&#x8FD8;&#x4E0D;&#x9519;&#xFF1A;<a href="">http://weibo.com/1580904460/yDmzAEwcV#1348475194313</a>! July&#x3001;&#x4E8C;&#x96F6;&#x4E00;&#x4E8C;&#x5E74;&#x5341;&#x6708;&#x5341;&#x4E00;&#x65E5;&#x3002;</p>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="./10.01.02.html" class="navigation navigation-prev " aria-label="Previous page: 教你一步一步用c语言实现sift算法、上"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="./part4.html" class="navigation navigation-next " aria-label="Next page: 其它"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="gitbook/app.js"></script>

    
    <script src="gitbook/plugins/gitbook-plugin-comment/plugin.js"></script>
    

    
    <script src="gitbook/plugins/gitbook-plugin-search/lunr.min.js"></script>
    

    
    <script src="gitbook/plugins/gitbook-plugin-search/search.js"></script>
    

    
    <script src="gitbook/plugins/gitbook-plugin-sharing/buttons.js"></script>
    

    
    <script src="gitbook/plugins/gitbook-plugin-fontsettings/buttons.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"comment":{"highlightCommented":true},"autocover":{},"highlight":{},"search":{"maxIndexSize":1000000},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
