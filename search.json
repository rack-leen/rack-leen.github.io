[{"title":"postgresql的存储过程","url":"%2F2020%2F08%2F09%2FPostgresql%2Fpostgresql%E7%9A%84%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%2F"},{"title":"redis的零拷贝","url":"%2F2020%2F08%2F05%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FC%2Fredis%2Fredis%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%2F","content":"\n# redis的零拷贝","tags":["零拷贝技术"],"categories":["零拷贝技术"]},{"title":"mq的零拷贝","url":"%2F2020%2F08%2F05%2FJava%2FJava%E6%A1%86%E6%9E%B6%2Fmq%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%2F","tags":["mq"]},{"title":"kafka的零拷贝","url":"%2F2020%2F08%2F05%2F%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%2Fkafka%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%2F"},{"title":"jvm的零拷贝","url":"%2F2020%2F08%2F05%2FJava%2Fjvm%2Fjvm%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%2F","content":"\n# jvm的零拷贝","tags":["零拷贝技术"],"categories":["零拷贝技术"]},{"title":"libevent的零拷贝","url":"%2F2020%2F08%2F05%2FC%2Flibevent%2Flibevent%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%2F","content":"\n# libevent的零拷贝\n","tags":["零拷贝技术"],"categories":["零拷贝技术"]},{"title":"netty的零拷贝","url":"%2F2020%2F08%2F05%2FJava%2FJava%E6%A1%86%E6%9E%B6%2Fnetty%2Fnetty%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%2F","content":"\n## netty的零拷贝\n\n### netty逻辑层面的零拷贝","tags":["Netty"]},{"title":"linux五种IO模型","url":"%2F2020%2F08%2F04%2FLinux%2FLinux%E8%BF%90%E7%94%A8%E6%8A%80%E6%9C%AF%2Flinux%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%2F","tags":["IO模型"]},{"title":"1-绪论","url":"%2F2020%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88%2F1-%E7%BB%AA%E8%AE%BA%2F"},{"title":"Linux的用户态与核心态","url":"%2F2020%2F06%2F26%2FLinux%2FLinux%E8%BF%90%E7%94%A8%E6%8A%80%E6%9C%AF%2FLinux%E7%9A%84%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%80%81%2F"},{"title":"select-poll和epoll多路复用(事件驱动)技术","url":"%2F2020%2F06%2F26%2FLinux%2FLinux%E8%BF%90%E7%94%A8%E6%8A%80%E6%9C%AF%2Fselect-poll%E5%92%8Cepoll%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-%E6%8A%80%E6%9C%AF%2F","content":"\n# select-poll和epoll多路复用(事件驱动)技术\n> linux内核集成了select,poll和epoll三种NIO多路复用技术(多路复用使用事件驱动模型作为编程范式),多路复用技术可以一个进程同时监视多个文件描述符，在大并发条件下可以提高线程利用率，减少线程资源浪费。\n## select\n### 原理解析\n### 函数解析\n```c\n/* According to POSIX.1-2001, POSIX.1-2008 */\n#include <sys/select.h>\n/* According to earlier standards */\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\nvoid FD_CLR(int fd, fd_set *set);\nint  FD_ISSET(int fd, fd_set *set);\nvoid FD_SET(int fd, fd_set *set);\nvoid FD_ZERO(fd_set *set);\n\n#include <sys/select.h>\n\n/*   \n    Feature Test Macro Requirements for glibc (see feature_test_macros(7)):\n        pselect(): _POSIX_C_SOURCE >= 200112L\n*/\nint pselect(int nfds, fd_set *readfds, fd_set *writefds,\n                   fd_set *exceptfds, const struct timespec *timeout,\n                   const sigset_t *sigmask);\n```\n### 实际运用\n## poll \n### 原理解析\n### 函数解析\n```c\n#include <poll.h>\n\nint poll(struct pollfd *fds, nfds_t nfds, int timeout);\n\n/* See feature_test_macros(7) */\n#define _GNU_SOURCE\n#include <signal.h>\n#include <poll.h>\n\nint ppoll(struct pollfd *fds, nfds_t nfds, const struct timespec *tmo_p, const sigset_t *sigmask);\n\n```\n### 实际运用\n## epoll\n### 原理解析\n### 函数解析\n```c\n#include <sys/epoll.h>\nint epoll_create(int size);\nint epoll_create1(int flags);\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);\nint epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout, const sigset_t *sigmask);\n```\n### 实际运用\n","tags":["多路复用"]},{"title":"零拷贝技术","url":"%2F2020%2F06%2F26%2FLinux%2FLinux%E8%BF%90%E7%94%A8%E6%8A%80%E6%9C%AF%2F%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%2F","content":"\n# 零拷贝技术\n\n> 零拷贝技术是linux下避免在内核态和用户态之间来回拷贝数据的技术。\n> 零拷贝技术在系统层面有两种实现方式，一个是面向socket(网络数据的拷贝)，一个面向文件系统(文件间的数据拷贝)。\n\n## 零拷贝的优点\n  + 减少cpu拷贝\n  + 减少内存带宽占用\n  + 减少用户空间和内核空间之间的上下文切换\n\n## \n## 零拷贝与多路复用(NIO)\n> 事件驱动模型是多路复用IO使用的编程范式\n> 多路复用IO的高效是由零拷贝技术实现的,需要传输的数据使用零拷贝技术被更快的拷贝到socket上,通过多路复用IO建立的网络通信进行传输\n\n## 零拷贝原理\n> linux上零拷贝主要是减少数据的额外拷贝次数以及避免在内核态和用户态之间切换，因为普通状态下数据拷贝需要在内核态和用户态之间切换，不仅会增加数据拷贝次数，还会因为空间切换耗费额外性能。\n\n### 用户态与核心态\nlinux系统分为两个空间，用户空间和内核空间。内核空间主要驻留系统进程，用户空间驻留用户进程。用户进程要切换进内核态需要调用系统调用。\n[Linux的用户态和内核态](/2020/06/26/Linux/Linux运用技术/Linux的用户态与核心态/)\n\n## 操作系统层面的零拷贝\n\n### sendfile\n> 在两个文件描述符之间拷贝数据，面向socket网络传输的零拷贝系统调用,只适用于将数据从文件拷贝到socket上。\n\n#### 原理解析\n\n#### 函数解析\n```c\n#include <sys/sendfile.h>\nssize_t sendfile (int __out_fd, int __in_fd, off_t *__offset, size_t __count) __THROW;\nssize_t sendfile64 (int __out_fd, int __in_fd, __off64_t *__offset, size_t __count) __THROW;\n\n```\n#### 实际运用\n\n### mmap\n> 面向文件系统拷贝数据的系统调用\n> 用于申请内存空间，这个内存空间可以作为进程间通信的共享内存，拷贝文件时可以将文件映射到共享内存，不用在内核空间与用户空间之间切换。\n#### 原理解析\n\n#### 函数解析\n```c\n#include <sys/mman.h>\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);\nint munmap(void *addr, size_t length);\n```\n#### 实际运用\n### splice\n> 适用于两个文件描述符之间移动数据，splice利用linux的管道缓冲机制，需要一个文件描述符是表示管道设备。\n#### 原理解析\n\n#### 函数解析\n```c\n/* See feature_test_macros(7) */\n#define _GNU_SOURCE\n#include <fcntl.h>\nssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);\n```\n#### 实际运用\n### tee\n> linux种的管道命令，适用于管道描述符之间数据传输。\n\n#### 原理解析\n#### 实际运用\n\n## 零拷贝技术的应用\n[jvm层面的零拷贝](/2020/08/05/Java/jvm/jvm的零拷贝/)\n[libevent的零拷贝](/2020/08/05/C/libevent/libevent的零拷贝/)\n[netty的零拷贝](/2020/08/05/Java/Java框架/netty/netty的零拷贝/)\n[kafka的零拷贝](/2020/08/05/工具安装与部署/kafka的零拷贝/)\n[mq的零拷贝](/2020/08/05/Java/Java框架/mq的零拷贝/)\n[redis的零拷贝](/2020/08/05/源码阅读/C/redis/redis的零拷贝/)\n\n\n## 参考文献\n1. [Linux 中的零拷贝技术，第 1 部分](https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/index.html)\n2. [漫谈Java IO之 Netty与NIO服务器](https://www.cnblogs.com/xing901022/p/8678869.html)\n3. [深入理解Linux, NIO和Netty中的零拷贝(Zero-Copy)](https://blog.csdn.net/u010793917/article/details/106659380)\n4. [Netty常见面试题总结](https://baijiahao.baidu.com/s?id=1669639041722396699&wfr=spider&for=pc)\n5. [Related articles](https://netty.io/wiki/related-articles.html)\n6. [Java NIO（一）select 和 epoll底层实现原理](https://www.jianshu.com/p/37a2bb9d1cae)\n7. [Select、poll、Epoll、KQueue区别](https://wenchao.ren/2019/07/Select%E3%80%81Epoll%E3%80%81KQueue%E5%8C%BA%E5%88%AB/)\n8. [Netty零拷贝之CompositeByteBuf实际用法](https://blog.csdn.net/youxijishu/article/details/104815309/)\n9. [Netty专栏 （ 三）——— Netty的ByteBuf](https://blog.csdn.net/thinking_fioa/article/details/80795673)\n10. [Netty-内存池化](https://www.jianshu.com/p/2652686a43eb)\n11. [彻底理解Netty](https://juejin.im/post/6844903703183360008)\n12. [netty内存分配总览](https://www.jianshu.com/p/1ce3bc2d7c5e)\n13. [Netty中的装饰者模式](http://www.manongjc.com/detail/9-kyookzrhqhdwnos.html)\n14. [操作系统层面聊聊BIO，NIO和AIO (epoll)](https://www.cnblogs.com/twoheads/p/10712094.html)\n15. [linux网络编程：splice函数和tee( )函数高效的零拷贝](https://www.cnblogs.com/kex1n/p/7446291.html)\n16. [sendfile man](https://www.man7.org/linux/man-pages/man2/sendfile.2.html)\n17. [mmap man](https://man7.org/linux/man-pages/man2/mmap.2.html)\n18. [splice man](https://man7.org/linux/man-pages/man2/splice.2.html)","tags":["零拷贝技术"],"categories":["零拷贝技术"]},{"title":"字段(Field)","url":"%2F2020%2F01%2F21%2FJava%2Fjvm%2Fclass%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%2F%E5%AD%97%E6%AE%B5-Field%2F","content":"\n## Field(字段)\n每个字段都是由一个field_info结构体来描述。在一个class文件中不可能有两个相同字段名和描述符的字段。\n\nfield_info结构体格式：\n```Java\nfield_info {\n u2 access_flags;           // 访问修饰符标志(public , protected,private等)\n u2 name_index;             // 在常量池中字段名所在的索引\n u2 descriptor_index;       // 在常量池中字段描述符所在的索引\n u2 attributes_count;       // 属性计数\n attribute_info attributes[attributes_count];   // 属性数组\n}\n```\n\n### access_flags\n字段的访问修饰符标志有以下这些：\n![field_access_flags](field_access_flags.png)\n  1. 一个类的字段可能有ACC_PUBLIC,ACC_PRIVATE,ACC_PROTECTED三种中的一种访问标志，并且必不可能有ACC_FINAL和ACC_VOLATILE访问标志。\n  2. 一个接口的字段必须有ACC_PUBLIC,ACC_STATIC,ACC_FINAL三个访问标志被设置，并且ACC_SYNTHEIC可能会被设置，其他的访问标志必不可能被设置。\n  3. ACC_SYNTHEIC访问标志显示了这个字段是由编译器生成的，并且不会在写在源码中。\n  4. ACC_ENUM访问标志显示了这个字段是一个枚举类型的一个元素。\n  5. 在以上表中未分配的访问标志项的所有位以待将来使用。它们在一个class文件中被设置为0，而且java虚拟机实现会忽视它们。\n### name_index\nname_index的值必须是是常量池表中一个有效索引。这个常量池索引指向的常量池项必须是一个代表一个有效unqualified名的CONTSANT_Utf-8_info结构体，这个结构体表示的就是这个字段。\n### descriptor_index\ndescriptor_index的值必须是常量池表中的一个有效索引。这个索引指向的常量池项必须是一个CONTSANT_Utf-8_info结构体，这个结构体代表一个有效的字段描述符。\n### attribute_count\nattribute_count的值表示这个字段的附加属性的数量。\n### attributes[attributes_count]\n  1. 这个属性表的每个值必须是一个attribute_info结构体。以下就是attribute_info结构体：  \n```\nattribute_info {\n u2 attribute_name_index;\n u4 attribute_length;\n u1 info[attribute_length];\n}\n```\n  2. 一个字段可能有与它有关联的一些可选属性。\n  3. 这些属性的规范定义在以下field_info结构体的属性表中表示：\n![attribute_spec](attribute_spec.png)\n  4. 查看属性表的详情请点击[这里]()\n"},{"title":"方法(Method)","url":"%2F2020%2F01%2F21%2FJava%2Fjvm%2Fclass%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%2F%E6%96%B9%E6%B3%95-Method%2F","content":"\n## 方法(Method)\n每个方法，包括实例初始化方法和类或者接口初始化方法，它们都由method_info结构体来描述。\n在一个class文件中不能有两个方法的方法名和方法描述符相同。\n以下是方法结构体的格式：\n```Java\nmethod_info {\n u2 access_flags;       // 方法修饰符\n u2 name_index;         // 方法名在常量池中的索引\n u2 descriptor_index;   // 描述符在常量池中的索引\n u2 attributes_count;   // 属性计数\n attribute_info attributes[attributes_count];   // 方法需要到的属性\n}\n```\n\n### access_flags\n以下表是方法需要的访问修饰符：\n![method_access_flags](method_access_flags.png)\n  1. 一个类的每个方法可能有 ACC_PUBLIC, ACC_PRIVATE和ACC_PROTECTED之中的一个访问修饰符。\n  2. 一个接口的方法可能有在上面的表中除了ACC_PROTECTED, ACC_FINAL, ACC_SYNCHRONIZED和ACC_NATIVE外的一些访问修饰符。\n  3. 在一个版本号小于52.0(jdk8)的class文件中,一个接口的每个方法必须有ACC_PUBLIC和ACC_NATIVE访问修饰符被设置。\n  4. 在一个版本号大等于52.0的class文件中，一个接口的每个方法必须有ACC_PUBLIC和ACC_PRIVATE中的一个访问修饰符被设置。\n  5. 如果一个类或者接口的一个方法有ACC_ABSTRACT访问修饰符，那么 ACC_PRIVATE, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED,ACC_NATIVE或者ACC_STRICT都不能被设置。\n  6. 每个实例初始化方法能够有ACC_PUBLIC,ACC_PRIVATE,ACC_PROTECTED其中一个访问修饰符被设置，并且也能设置 ACC_VARARGS, ACC_STRICT和ACC_SYNTHETIC这三个标志，但是不能设置这个表中的其他标志。\n  7. 类和接口的初始化方法会被java虚拟机调用。它们的access_flags值除了设置的ACC_STRICT标志的值都会被忽略。\n  8. ACC_BRIDGE访问修饰符被用来表示一个由编译器生成的bridge method。\n  9. ACC_VARAGES标志用来表示这个方法在源码级别采用可变数量参数。\n  10. 如果一个方法被声明为有可变数量的参数，则这个方法的ACC_VARAGES值被设置为1，如果是固定参数则设置为0。\n  11. ACC_SYNTHETIC标志表示这个方法由编译器生成并且不会在源码中显示，除非这个方法是在属性表的Synthetic属性中命名的方法之一。\n  12. 在access_flags其他的没有提到的修饰符的所有位不会被分配，它们在class文件中都会被设置为0，并且被java虚拟机忽略。\n### name_index\n  1. name_index的值必须是常量池表中的一个有效索引。这个索引指向的常量池项必须是一个CONSTANT_Utf8_info结构体，这个结构体用来表示特殊的方法名<init>或<clinit>或一个有效的方法名中的一个。\n### descriptor_index\n  1. descriptor_index的值必须是常量池中的一个有效索引。这个索引指向的常量池项必须是一个CONSTANT_Utf8_info结构体,这个结构体用来表示一个有效的方法描述符。\n  2. 如果方法的access_flags中的ACC_VARAGES标志被设置，那这个方法描述符的最后一个参数描述符需要是一个数组类型。\n### attributes_count\n  1. attributes_count的值表示这个方法的附加属性的数量。\n### attributes[attributes_count]\n  1. 属性表的每个值必须是一个attribute_info结构体。\n```\nattribute_info {\n u2 attribute_name_index;\n u4 attribute_length;\n u1 info[attribute_length];\n}\n```\n  2. 一个字段可能有与它有关联的一些可选属性。\n  3. 这些属性的规范定义在以下field_info结构体的属性表中表示：\n![attribute_spec](attribute_spec.png)\n  4. 查看属性表的详情请点击[这里]()\n"},{"title":"属性(Attributes)","url":"%2F2020%2F01%2F21%2FJava%2Fjvm%2Fclass%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%2F%E5%B1%9E%E6%80%A7-Attributes%2F","content":"\n## 属性(Attributes)\n属性被用在ClassFile,field_info,method_info和Code_attribute结构体中。\n以下是所有属性的结构格式：\n```Java\nattribute_info {\n u2 attribute_name_index;\n u4 attribute_length;\n u1 info[attribute_length];\n}\n```\n  1. 对于所有的属性，attribute_name_index必须是这个类中的常量池中的一个有效的无符号16位索引；这个索引对应的常量池项必须是一个CONSTANT_Utf8_info结构体,它代表的是这个属性名。  \n  2. attribute_length表示的是除了attribute_name_index和attribute_length(u2+u4=6个字节)所占长度之外的这个结构体所占的长度，也就是info[attribute_length]所占长度。\n"},{"title":"常量池","url":"%2F2020%2F01%2F18%2FJava%2Fjvm%2Fclass%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%2F%E5%B8%B8%E9%87%8F%E6%B1%A0%2F","content":"\n## 常量池\n\n> java虚拟机指令依赖在常量池表中的符号信息，而不是类，接口，类实例或者数组的运行时布局。\n\n所有的常量池项都遵循以下格式:\n```Java\ncp_info {\n\tu1 tag;\n\tu1 info[];\n}\n```\n  1. 在常量池表中的每个元素都有这个cp_info形式的结构，tag是一个元素的开始字段，占1位，用来表示cp_info这个结构是哪种结构(CONTSANT_Class_info等结构)。\n  2. info数组是tag表示的结构组成的数组。\n以下就是tag与cp_info结构对应关系。value项就是常量类型在tag中的标志。当tag=7时，info里面就存储一个CONTSANT_Class类型的数组。\n![contant_pool_tag](contant_pool_tag.png)\n\n### CONSTANT_Class_info结构体\n\n### CONSTANT_Fieldref_info, CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info结构体\n\n### CONSTANT_String_info 结构体\n\n### CONSTANT_Integer_info和CONSTANT_Float_info结构体\n\n### CONSTANT_Long_info和CONSTANT_Double_info结构体\n### CONSTANT_NameAndType_info结构体\n\n### CONSTANT_Utf8_info结构体\n\n### CONSTANT_MethodHandle_info结构体\n\n### CONSTANT_MethodType_info结构体\n\n### CONSTANT_InvokeDynamic_info结构体\n","tags":["Class文件格式"],"categories":["Class文件格式"]},{"title":"描述符","url":"%2F2020%2F01%2F17%2FJava%2Fjvm%2Fclass%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%2F%E6%8F%8F%E8%BF%B0%E7%AC%A6%2F","content":"\n## 描述符\n\n### 定义\n> 一个描述符是一个表示一个字段或者方法类型的字符串。描述符通常是在class文件中用UTF-8的字符串来表示。\n\n### 描述符的语法符号\n描述符用一种语法来进行规范。描述符的这种语法是一组形成各种语法正确的描述符的字符序列。\n\n### 描述符分类\n\n#### 字段描述符(Field Descriptors)\n字段描述符用来表示一个类，实例或者局部变量。以下就是所有的字段描述符：\n![field_desc](field_desc.png)\n  1. B C D F I J S Z 都是基本类型在class文件中的表现形式。\n  2. \"Ljava/lang/String;\"则是String类型在class文件中的表现形式,L表示其后的字符串是一个类名，以\";\"结尾。\n  3. 数组在java中也是一个引用类型，数组在class文件中的表现形式为\"[\",一个double\\[\\]\\[\\]在class文件中的表现形式为\\[\\[D,\\[后面可以跟其他的字段描述符。\n#### 方法描述符(Method Descriptors)\n一个方法描述符包含0个或者多个参数描述符(参数都是字段描述符),它表现形式为：({ParameterDescriptor}) ReturnDescriptor。\n  1. 一般情况下，一个有返回值的方法表现为:({ParameterDescriptor}) ReturnDescriptor。\n```\njava方法：String test(int i , double d , String s)\nclass形式：(IDLjava/lang/String;)Ljava/lang/String;\nint i      对应 I\ndouble d   对应 D\nString s   对应 Ljava/lang/String;\n返回值String对应 Ljava/lang/String;\n```\n  2. 如果是无返回值的方法，则表现为:({ParameterDescriptor}) V\n```\njava方法：void test(int i , double d , String s)\nclass形式：(IDLjava/lang/String;)V\nint i      对应 I\ndouble d   对应 D\nString s   对应 Ljava/lang/String;\n无返回值    对应 V\n```\n  3. 如果方法参数总长度在255之内(这个长度包括了实例的this或接口方法调用,long和double占2个长度,其他的占一个长度)，则判定一个方法描述符是有效的。\n  4. 无论是一个类方法还是一个实例方法，方法相同的话，塔就是同一个方法描述符。虽然一个实例方法传递了this这个本对象引用，但是这个this不会在方法描述符中反映。这个this引用是通过java虚拟机的用来调用实例方法的指令来传递的。\n\n### 代码举例\n  1. 下面是我们需要的代码\n```Java\npublic class Test {\n  public static void main(String[] args){\n    System.out.println(\"Hello world\") ;\n  }\n}\n```\n  2. 代码编译后，我们通过javap命令，获取class文件的详细信息\n```Java\njavac Test.java\njavap -v Test\n\nClassfile /home/share/Public/blog/source/_posts/Java/jvm/Test.class\n  Last modified 2020-1-17; size 413 bytes\n  MD5 checksum adae6df967b28789efc582efe75101db\n  Compiled from \"Test.java\"\npublic class Test\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #6.#15         // java/lang/Object.\"<init>\":()V\n   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;\n   #3 = String             #18            // Hello world\n   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V\n   #5 = Class              #21            // Test\n   #6 = Class              #22            // java/lang/Object\n   #7 = Utf8               <init>\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               main\n  #12 = Utf8               ([Ljava/lang/String;)V\n  #13 = Utf8               SourceFile\n  #14 = Utf8               Test.java\n  #15 = NameAndType        #7:#8          // \"<init>\":()V\n  #16 = Class              #23            // java/lang/System\n  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;\n  #18 = Utf8               Hello world\n  #19 = Class              #26            // java/io/PrintStream\n  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V\n  #21 = Utf8               Test\n  #22 = Utf8               java/lang/Object\n  #23 = Utf8               java/lang/System\n  #24 = Utf8               out\n  #25 = Utf8               Ljava/io/PrintStream;\n  #26 = Utf8               java/io/PrintStream\n  #27 = Utf8               println\n  #28 = Utf8               (Ljava/lang/String;)V  // 这个方法描述符表示:void func(String s)\n{\n  public Test();\n    descriptor: ()V                           // 这个方法描述符表示：void func() 这个方法描述符描述的是Test这个类\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 1: 0\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V       // 这个方法描述符表示：void func(String[] s) 这个方法描述符描述的是main这个主函数\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         3: ldc           #3                  // String Hello world\n         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n         8: return\n      LineNumberTable:\n        line 3: 0\n        line 4: 8\n}\nSourceFile: \"Test.java\"\n```\n\n  3. \n### 文献引用\n\n  1. [JNI字段描述符](https://www.cnblogs.com/ynxf/p/8214100.html)\n","tags":["Class文件格式"],"categories":["Class文件格式"]},{"title":"names的内部形式","url":"%2F2020%2F01%2F15%2FJava%2Fjvm%2Fclass%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%2Fnames%E7%9A%84%E5%86%85%E9%83%A8%E5%BD%A2%E5%BC%8F%2F","content":"\n## names的内部形式\n\n### 二进制类和接口的name\n  1. 由于历史原因，在class文件中的二进制文件名书写语法与java文件的二进制文件名语法不同。\n  2. 在Java文件中，我们一般将类和接口的名字写作为com.example.Text,用\".\"来进行分隔。\n  3. 在class文件中，我们则用com/example/Text这种形式，我们需要将\".\"替换为\"/\"。\n  4. 在class文件格式的描述符中使用的内部形式中，对类Text名称的引用被用CONSTANT_Utf-8_info结构表示字符串com/example/Text来实现。\n  \n### unqualified names\n  1. 方法名，字段名，本地变量名，和形参都作为unqualified name被存储。\n  2. 一个unqualified name必须包含至少一个unicode编码点，并且不能包含任何一个ASCII编码字符串(.;[/)。\n  3. 方法名必须要有约束，如果有特殊的方法名(比如<init>和<clint>)将会抛出异常。\n  4. 方法名必须不能包含ASCII字符<或者>。\n  5. 一个字段名或者接口方法名可能会是<ciinit>或者<init>,但是没有方法调用指令去引用<clinit>方法，并且只有invokespecial指令可能会引用<cinit>方法。\n","tags":["Class文件格式"],"categories":["Class文件格式"]},{"title":"spring-core模块源码阅读准备","url":"%2F2020%2F01%2F13%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FJava%2FSpring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2Fspring-core%2Fspring-core%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%87%86%E5%A4%87%2F","content":"\n## spring-core模块源码阅读准备\n\n### 模块组成\n  1. asm\n  2. cglib\n  3. core\n  4. lang\n  5. objenesis\n  6. util\n \n### 模块详解\n\n#### asm\n##### asm是什么？\n  1. asm是一个java字节码操控框架(修改字节码),它能被用来动态生成或者增强现有类的功能,是cglib技术的基础。\n  2. asm使用**访问者模式**实现，java类作为需要访问的元素，而asm框架定义java类的访问者，所有的对java类的操作都在访问者这里完成。\n##### ASM与APT、aspectJ、Javassit\n![aop](aop.webp)\n  1. APT\n\tAPT(Annotation Processing Tool),是一个注解处理器，是javac的一个工具，在编译时扫描和处理注解，可以在代码编译期解释注解，并且生成新的Java文件，减少手动输入代码。\n  2. aspectJ\n\t是一个面向切面的框架，aspectJ定义了AOP语法，它用专门的编译器生成java字节码文件。它可以在某一个方法的前后插入部分代码，也就是在生成class时动态织入代码。\n  3. Javassit\n\t是一个开源的分析，编辑和创建Java字节码的类库。\nAPT是在源码阶段修改java文件，aspectJ是在生成class时修改class,ASM与Javassit差不多，都是修改已经生成的class文件。\n#### cglib\n##### cglib是什么?\n  1. cglib(code generator library),是一个高性能的代码生成库。\n  2. cglib基于asm技术，可以对字节码(class)进行操作，因此被广泛应用于AOP，将方法动态织入class中。\n  3. 它也是spring实现的一种动态代理技术，它也被用在Hibernate框架中。\n##### cglib动态代理与jdk动态代理\n  1. cglib动态代理是使用asm技术实现，将代理对象类的class字节码文件加载进来，通过修改其字节码生成子类。cglib只能针对类实现代理。\n  2. jdk动态代理是使用反射技术实现，利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。jdk动态代理只能对实现相同接口的类生成代理。\n#### core\n  1. core是spring-core模块的核心实现代码，其他的包(asm,objenesis,cglib)都是spring-core引入的依赖库。\n#### lang\n  1. lang包中提供spring中定义注解元素不为空的注解类。\n#### objenesis\n##### objenesis是什么?\n  1. [objenesis](http://objenesis.org/),是一个用来实例化一些特殊类的新对象的java库。\n  2. java支持使用Class.newInstance()进行动态实例化，但是它只是适用于适当的构造器。当类中包含需要参数的构造器，有副作用的构造器以及抛出异常的构造器时，java提供的动态实例化就不再适用。\n  3. 在库中常见的限制是类必须要默认构造函数，objenesis旨在绕过对象实例化的构造函数来克服这些限制。\n##### objenesis使用场景\nobjenesis一般使用在不需要调用构造函数就能实例化对象的场景。\n  1. 序列化(Serialization)，远程调用(Remoting)和持久化(Persistence)。要求对象需要被实例化并还原到特定状态，而不需要调用代码。\n  2. 代理(Proxies)，面向切面编程(AOP)和模拟对象(Mock Objects)。类可以被子类化，而不需要担心super()构造器。\n  3. 容器框架(Container Frameworks)。在非标准的情况下类被动态实例化。\n#### util\n  1. 工具类，提供一些必要的工具。\n\n\n### spring-core模块功能\nBeanFactory是spring最核心的组件，而spring-core则为BeanFactory的定义提供基础服务。spring-core中最核心的部分则是core中的代码。其他部分的代码都是为core中的代码服务。\n\n### 文献引用\n  1. [ASM](https://www.jianshu.com/p/a1e6b3abd789)\n  2. [从零开始造Spring04---补充之ASM的原理以及在Spring中的应用](https://blog.csdn.net/u014534808/article/details/81071452)\n  3. [AOP：APT,AspectJ,Javassist/Asm](https://www.jianshu.com/p/44d39585fc20)\n  4. [CGLIB原理及实现机制](https://blog.csdn.net/gyshun/article/details/81000997)\n  5. [Spring的两种动态代理：Jdk和Cglib 的区别和实现](https://www.cnblogs.com/leifei/p/8263448.html)\n  \n","tags":["spring-core"],"categories":["spring-core"]},{"title":"spring-core模块(asm)","url":"%2F2020%2F01%2F13%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FJava%2FSpring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2Fspring-core%2Fspring-core%E6%A8%A1%E5%9D%97(asm)%2F","content":"\n## spring-core模块(asm)\n\n### asm代码结构\n![asm源码视图](asm源码视图.png)\n","tags":["spring-core"],"categories":["spring-core"]},{"title":"spring-instrument源码阅读","url":"%2F2020%2F01%2F13%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FJava%2FSpring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2Fspring-instrument%2Fspring-instrument%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F","content":"\n## spring-instrument源码阅读\n\n### spring-instrument模块功能\n  1. instrument提供了允许java通过代理服务来检测运行在jvm上的程序，可以对方法的字节码进行修改，实现虚拟机级别的aop\n  2. instrument功能是在java se5中加入的，instrument要求在运行前用命令行或系统参数来设置代理类.也就是在运行前设置代理类\n  3. 在java se6中加入了动态控制的代理的能力\n  4. 监控和控制虚拟机的行为。\n  \n### asm与instrument\n  1. asm与instrument一样，都能操作字节码。但是instrument是在整个虚拟机上挂了一个钩子函数，每次装入一个新类，都必须执行这个函数，如果是用在改造类上，会造成很大的资源浪费。instrument更适合与监控和控制虚拟机的行为。\n  2. asm和instrument的侧重点不同，asm侧重改造字节码，实现动态代理;instrument侧重监控和控制虚拟机。\n\n### spring-instrument代码结构\n![spring-instrument](spring-instrument.png)\n\n### spring-instrument源码\n#### InstrumentationSavingAgent\n```Java\n/*\n * Copyright 2002-2018 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.instrument;\n\nimport java.lang.instrument.Instrumentation;\n\n/**\n * Java agent that saves the {@link Instrumentation} interface from the JVM\n * for later use.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 2.0\n * @see org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver\n */\n\n/**\n * https://www.cnblogs.com/yelao/p/9841810.html\n * https://blog.csdn.net/jiangtianjiao/article/details/88093825\n * https://www.ibm.com/developerworks/cn/java/j-lo-jpda2/index.html\n * instrument提供了允许java通过代理服务来检测运行在jvm上的程序，可以对方法的字节码进行修改，实现虚拟机级别的aop\n * instrument功能是在java se5中加入的，instrument要求在运行前用命令行或系统参数来设置代理类.也就是在运行前设置代理类\n * 在java se6中加入了动态控制的代理的能力\n *\n * 下面的实现就是为spring项目提供一个java动态代理的接口\n */\npublic final class InstrumentationSavingAgent {\n\n\tprivate static volatile Instrumentation instrumentation;\n\n\n\tprivate InstrumentationSavingAgent() {\n\t}\n\n\t/**\n\t * 下面这两个方法都是直接使用的jdk中的instrument\n\t */\n\n\t/**\n\t * Save the {@link Instrumentation} interface exposed by the JVM.\n\t * 这个方法是在程序运行前进行代理,也就是在main函数运行之前的一些操作(main执行之前的修改)\n\t */\n\tpublic static void premain(String agentArgs, Instrumentation inst) {\n\t\tinstrumentation = inst;\n\t}\n\n\t/**\n\t * Save the {@link Instrumentation} interface exposed by the JVM.\n\t * 这个方法是在运行时动态代理(控制类运行的行为)\n\t * This method is required to dynamically load this Agent with the Attach API.\n\t */\n\tpublic static void agentmain(String agentArgs, Instrumentation inst) {\n\t\tinstrumentation = inst;\n\t}\n\n\t/**\n\t * Return the {@link Instrumentation} interface exposed by the JVM.\n\t * <p>Note that this agent class will typically not be available in the classpath\n\t * unless the agent is actually specified on JVM startup. If you intend to do\n\t * conditional checking with respect to agent availability, consider using\n\t * {@link org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver#getInstrumentation()}\n\t * instead - which will work without the agent class in the classpath as well.\n\t * @return the {@code Instrumentation} instance previously saved when\n\t * the {@link #premain} or {@link #agentmain} methods was called by the JVM;\n\t * will be {@code null} if this class was not used as Java agent when this\n\t * JVM was started or it wasn't installed as agent using the Attach API.\n\t * @see org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver#getInstrumentation()\n\t *\n\t * 不管是使用运行前代理还是动态代理，都会产生一个instrumentation对象，这个方法就是为spring项目提供这个对象\n\t */\n\tpublic static Instrumentation getInstrumentation() {\n\t\treturn instrumentation;\n\t}\n\n}\n```\n### 文献引用\n  1. [AOP之利器：ASM介绍](https://www.jianshu.com/p/b5dc9c316f27)\n  2. [冷门instrument包，功能d炸天](http://www.imooc.com/article/290000)\n","tags":["spring-instrument"],"categories":["spring-instrument"]},{"title":"spring-jcl模块源码阅读","url":"%2F2020%2F01%2F13%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FJava%2FSpring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2Fspring-jcl%2Fspring-jcl%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F","content":"\n## spring-jcl模块源码阅读\n\n### spring-jcl模块功能\nspring-jcl是spring实现的日志模块，它为spring提供了一个适配四种日志类的统一日志接口,只要spring加载了四种模块中的哪一个，spring-jcl模块就能为spring提供一个统一的日志对象。\nspring-jcl适配的四种日志类:\n  1. org.apache.logging.log4j.spi.ExtendedLogger\n  2. org.apache.logging.slf4j.SLF4JProvider\n  3. org.slf4j.spi.LocationAwareLogger\n  4. org.slf4j.Logger\n### spring-jcl使用的设计模式\n  1. 工厂模式,LogFactory使用工厂模式，用来创建日志对象。\n  2. 适配器模式，LogAdapter使用适配器模式，用来适配加载的日志类。\n### spring-jcl代码结构\n![spring-jcl](spring-jcl.png)\nLogFactory是一个抽象类，也是spring-jcl模块暴露出来的接口，LogFactoryService是LogFactory的实现类，用来生产日志对象,它依赖LogAdapter,需要让LogAdapter提供日志对象。\nLogAdapter用来适配四种日志类，将四种不同的日志类与spring兼容，提供统一的日志对象。\nLog是一个接口，提供日志等级，默认有trace，debug，info，warn，error，fatal六种等级。NoOpLog与SimpleLog实现Log接口。\n### spring-jcl实现流程\n![spring-jcl结构](spring-jcl结构.png)\n\n### spring源码\n#### LogFactory\n```Java\n/*\n * Copyright 2002-2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.logging;\n\n/**\n * A minimal incarnation of Apache Commons Logging's {@code LogFactory} API,\n * providing just the common {@link Log} lookup methods. This is inspired\n * by the JCL-over-SLF4J bridge and should be source as well as binary\n * compatible with all common use of the Commons Logging API (in particular:\n * with {@code LogFactory.getLog(Class/String)} field initializers).\n *\n * <p>This implementation does not support Commons Logging's original provider\n * detection. It rather only checks for the presence of the Log4j 2.x API\n * and the SLF4J 1.7 API in the Spring Framework classpath, falling back to\n * {@code java.util.logging} if none of the two is available. In that sense,\n * it works as a replacement for the Log4j 2 Commons Logging bridge as well as\n * the JCL-over-SLF4J bridge, both of which become irrelevant for Spring-based\n * setups as a consequence (with no need for manual excludes of the standard\n * Commons Logging API jar anymore either). Furthermore, for simple setups\n * without an external logging provider, Spring does not require any extra jar\n * on the classpath anymore since this embedded log factory automatically\n * delegates to {@code java.util.logging} in such a scenario.\n *\n * <p><b>Note that this Commons Logging variant is only meant to be used for\n * infrastructure logging purposes in the core framework and in extensions.</b>\n * It also serves as a common bridge for third-party libraries using the\n * Commons Logging API, e.g. Apache HttpClient, and HtmlUnit, bringing\n * them into the same consistent arrangement without any extra bridge jars.\n *\n * <p><b>For logging need in application code, prefer direct use of Log4j 2.x\n * or SLF4J or {@code java.util.logging}.</b> Simply put Log4j 2.x or Logback\n * (or another SLF4J provider) onto your classpath, without any extra bridges,\n * and let the framework auto-adapt to your choice.\n *\n * @author Juergen Hoeller (for the {@code spring-jcl} variant)\n * @since 5.0\n */\n\n/**\n * 使用了工厂模式\n * 这个工厂用来生产jcl日志对象，需要用适配器适配对应的日志类，从而创建对象的日志对象\n */\npublic abstract class LogFactory {\n\n\t/**\n\t * Convenience method to return a named logger.\n\t * 输入Class，通过Class获取类名，输入进需要调用的下面那个重载方法，获取对应的日志对象\n\t * @param clazz containing Class from which a log name will be derived\n\t */\n\tpublic static Log getLog(Class<?> clazz) {\n\t\treturn getLog(clazz.getName());\n\t}\n\n\t/**\n\t * Convenience method to return a named logger.\n\t * 输入类名，使用适配器获取对应日志对象\n\t * @param name logical name of the <code>Log</code> instance to be returned\n\t */\n\tpublic static Log getLog(String name) {\n\t\treturn LogAdapter.createLog(name);\n\t}\n\n\n\t/**\n\t * This method only exists for compatibility with unusual Commons Logging API\n\t * usage like e.g. {@code LogFactory.getFactory().getInstance(Class/String)}.\n\t * @see #getInstance(Class)\n\t * @see #getInstance(String)\n\t * @deprecated in favor of {@link #getLog(Class)}/{@link #getLog(String)}\n\t */\n\t@Deprecated\n\tpublic static LogFactory getFactory() {\n\t\treturn new LogFactory() {};\n\t}\n\n\n\t/**\n\t * 下面这两个方法是提供给外界的接口，用来获取工厂生产的对象\n\t */\n\n\t/**\n\t * Convenience method to return a named logger.\n\t * 调用getLog(Class<?> clazz)函数,返回日志对象\n\t * <p>This variant just dispatches straight to {@link #getLog(Class)}.\n\t * @param clazz containing Class from which a log name will be derived\n\t * @deprecated in favor of {@link #getLog(Class)}\n\t */\n\t@Deprecated\n\tpublic Log getInstance(Class<?> clazz) {\n\t\treturn getLog(clazz);\n\t}\n\n\t/**\n\t * Convenience method to return a named logger.\n\t * 调用getLog(String name)，获取日志对象\n\t * <p>This variant just dispatches straight to {@link #getLog(String)}.\n\t * @param name logical name of the <code>Log</code> instance to be returned\n\t * @deprecated in favor of {@link #getLog(String)}\n\t */\n\t@Deprecated\n\tpublic Log getInstance(String name) {\n\t\treturn getLog(name);\n\t}\n\n}\n```\n\n#### LogFactoryService\n```Java\n/*\n * Copyright 2002-2018 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.logging;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * A minimal subclass of the standard Apache Commons Logging's {@code LogFactory} class,\n * overriding the abstract {@code getInstance} lookup methods. This is just applied in\n * case of the standard {@code commons-logging} jar accidentally ending up on the classpath,\n * with the standard {@code LogFactory} class performing its META-INF service discovery.\n * This implementation simply delegates to Spring's common {@link Log} factory methods.\n *\n * @author Juergen Hoeller\n * @since 5.1\n * @deprecated since it is only meant to be used in the above-mentioned fallback scenario\n */\n\n/**\n * 这个类继承抽象类LogFactory\n */\n@Deprecated\npublic class LogFactoryService extends LogFactory {\n\n\t/**\n\t * 这个是用来存储存在的日志类名\n\t * jcl定义了四种日志类，这个集合最多能存放四个日志类名，使用ConcurrentHashMap保证在并发状态下的线程安全\n\t */\n\tprivate final Map<String, Object> attributes = new ConcurrentHashMap<>();\n\n\n\t@Override\n\tpublic Log getInstance(Class<?> clazz) {\n\t\treturn getInstance(clazz.getName());\n\t}\n\n\t@Override\n\tpublic Log getInstance(String name) {\n\t\treturn LogAdapter.createLog(name);\n\t}\n\n\n\t/**\n\t * 对加载进spring的日志类的操作，包括对加载删除，获取，设置等操作\n\t */\n\t// Just in case some code happens to call uncommon Commons Logging methods...\n\n\tpublic void setAttribute(String name, Object value) {\n\t\tif (value != null) {\n\t\t\tthis.attributes.put(name, value);\n\t\t}\n\t\telse {\n\t\t\tthis.attributes.remove(name);\n\t\t}\n\t}\n\n\tpublic void removeAttribute(String name) {\n\t\tthis.attributes.remove(name);\n\t}\n\n\tpublic Object getAttribute(String name) {\n\t\treturn this.attributes.get(name);\n\t}\n\n\tpublic String[] getAttributeNames() {\n\t\treturn this.attributes.keySet().toArray(new String[0]);\n\t}\n\n\tpublic void release() {\n\t}\n\n}\n```\n\n#### LogAdapter\n```Java\n/*\n * Copyright 2002-2018 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.logging;\n\nimport java.io.Serializable;\nimport java.util.logging.LogRecord;\n\nimport org.apache.logging.log4j.Level;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.spi.ExtendedLogger;\nimport org.apache.logging.log4j.spi.LoggerContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * Spring's common JCL adapter behind {@link LogFactory} and {@link LogFactoryService}.\n * Detects the presence of Log4j 2.x / SLF4J, falling back to {@code java.util.logging}.\n *\n * @author Juergen Hoeller\n * @since 5.1\n */\n\n/**\n * spring为兼容四种日志所做的适配器\n * 使用的是适配器模式，适配者是四种日志，适配器是这个适配器类，最终创建一个适配spring框架的日志对象\n */\nfinal class LogAdapter {\n\n\t/**\n\t * 是四种日志类名\n\t */\n\tprivate static final String LOG4J_SPI = \"org.apache.logging.log4j.spi.ExtendedLogger\";\n\n\tprivate static final String LOG4J_SLF4J_PROVIDER = \"org.apache.logging.slf4j.SLF4JProvider\";\n\n\tprivate static final String SLF4J_SPI = \"org.slf4j.spi.LocationAwareLogger\";\n\n\tprivate static final String SLF4J_API = \"org.slf4j.Logger\";\n\n\n\t/* LogApi是一个枚举类，用来枚举上面的四种日志类名 */\n\tprivate static final LogApi logApi;\n\n\t/**\n\t * 静态代码块，在这个类加载人虚拟机时执行，并且只执行一次。\n\t * 判断哪个日志类被加载，然后返回对应枚举中的枚举值(这个枚举值是1,2,3等),这个枚举值用来判断需要使用哪个日志类\n\t */\n\tstatic {\n\t\t/* 这里判断哪个日志类被加载 */\n\t\tif (isPresent(LOG4J_SPI)) {\n\t\t\tif (isPresent(LOG4J_SLF4J_PROVIDER) && isPresent(SLF4J_SPI)) {\n\t\t\t\t// log4j-to-slf4j bridge -> we'll rather go with the SLF4J SPI;\n\t\t\t\t// however, we still prefer Log4j over the plain SLF4J API since\n\t\t\t\t// the latter does not have location awareness support.\n\t\t\t\tlogApi = LogApi.SLF4J_LAL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Use Log4j 2.x directly, including location awareness support\n\t\t\t\tlogApi = LogApi.LOG4J;\n\t\t\t}\n\t\t}\n\t\telse if (isPresent(SLF4J_SPI)) {\n\t\t\t// Full SLF4J SPI including location awareness support\n\t\t\tlogApi = LogApi.SLF4J_LAL;\n\t\t}\n\t\telse if (isPresent(SLF4J_API)) {\n\t\t\t// Minimal SLF4J API without location awareness support\n\t\t\tlogApi = LogApi.SLF4J;\n\t\t}\n\t\telse {\n\t\t\t// java.util.logging as default\n\t\t\tlogApi = LogApi.JUL;\n\t\t}\n\t}\n\n\n\tprivate LogAdapter() {\n\t}\n\n\n\t/**\n\t * Create an actual {@link Log} instance for the selected API.\n\t * 创建一个日志实例\n\t * 这里拿到flag，然后通过switch语句选择需要的创建日志对象的方法\n\t * 这些创建对象的方法是下面存在的静态内部类(静态内部类也只会产生一个实例)\n\t * @param name the logger name\n\t */\n\tpublic static Log createLog(String name) {\n\t\tswitch (logApi) {\n\t\t\tcase LOG4J:\n\t\t\t\treturn Log4jAdapter.createLog(name);\n\t\t\tcase SLF4J_LAL:\n\t\t\t\treturn Slf4jAdapter.createLocationAwareLog(name);\n\t\t\tcase SLF4J:\n\t\t\t\treturn Slf4jAdapter.createLog(name);\n\t\t\tdefault:\n\t\t\t\t// Defensively use lazy-initializing adapter class here as well since the\n\t\t\t\t// java.logging module is not present by default on JDK 9. We are requiring\n\t\t\t\t// its presence if neither Log4j nor SLF4J is available; however, in the\n\t\t\t\t// case of Log4j or SLF4J, we are trying to prevent early initialization\n\t\t\t\t// of the JavaUtilLog adapter - e.g. by a JVM in debug mode - when eagerly\n\t\t\t\t// trying to parse the bytecode for all the cases of this switch clause.\n\t\t\t\treturn JavaUtilAdapter.createLog(name);\n\t\t}\n\t}\n\n\t/**\n\t * 这个就是用来判断输入的类名是否被加载，也就是是否存在\n\t * @param className\n\t * @return\n\t */\n\tprivate static boolean isPresent(String className) {\n\t\ttry {\n\t\t\tClass.forName(className, false, LogAdapter.class.getClassLoader());\n\t\t\treturn true;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* 这个就是上面需要的枚举类 */\n\tprivate enum LogApi {LOG4J, SLF4J_LAL, SLF4J, JUL}\n\n\n\t/**\n\t * 下面三个adapter就是四种日志的适配器,以静态内部类的形式\n\t */\n\n\t/* 1.第一个日志适配器 */\n\tprivate static class Log4jAdapter {\n\n\t\tpublic static Log createLog(String name) {\n\t\t\treturn new Log4jLog(name);\n\t\t}\n\t}\n\n\n\t/* 2. 这里包含两个日志的适配器 */\n\tprivate static class Slf4jAdapter {\n\n\t\tpublic static Log createLocationAwareLog(String name) {\n\t\t\t// 先从日志工厂中获取日志对象\n\t\t\t// 为什么需要通过日志工厂调用我们这个适配器类，创建日志对象再判断这个日志对象？\n\t\t\t// 是因为LocationAwareLogger和Logger都属于slf4，我们需要这样来区别这两个日志类\n\t\t\tLogger logger = LoggerFactory.getLogger(name);\n\t\t\t// 然后判断这个日志实例是不是我们需要的，如果是就将这个日志实例再封装为我们需要对象;如果不是，就重新创建一个对象\n\t\t\treturn (logger instanceof LocationAwareLogger ?\n\t\t\t\t\tnew Slf4jLocationAwareLog((LocationAwareLogger) logger) : new Slf4jLog<>(logger));\n\t\t}\n\n\t\tpublic static Log createLog(String name) {\n\t\t\treturn new Slf4jLog<>(LoggerFactory.getLogger(name));\n\t\t}\n\t}\n\n\t/* 3. 这里是最后一个日志适配器 */\n\tprivate static class JavaUtilAdapter {\n\n\t\tpublic static Log createLog(String name) {\n\t\t\treturn new JavaUtilLog(name);\n\t\t}\n\t}\n\n\n\t/**\n\t * 下面是四个适配器需要的四个适配者\n\t * 我们在spring中调用的日志对象需要的方法都是从四个日志类中获取的\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class Log4jLog implements Log, Serializable {\n\n\t\tprivate static final String FQCN = Log4jLog.class.getName();\n\n\t\tprivate static final LoggerContext loggerContext =\n\t\t\t\tLogManager.getContext(Log4jLog.class.getClassLoader(), false);\n\n\t\tprivate final ExtendedLogger logger;\n\n\t\tpublic Log4jLog(String name) {\n\t\t\tthis.logger = loggerContext.getLogger(name);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isFatalEnabled() {\n\t\t\treturn this.logger.isEnabled(Level.FATAL);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isErrorEnabled() {\n\t\t\treturn this.logger.isEnabled(Level.ERROR);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isWarnEnabled() {\n\t\t\treturn this.logger.isEnabled(Level.WARN);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isInfoEnabled() {\n\t\t\treturn this.logger.isEnabled(Level.INFO);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isDebugEnabled() {\n\t\t\treturn this.logger.isEnabled(Level.DEBUG);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isTraceEnabled() {\n\t\t\treturn this.logger.isEnabled(Level.TRACE);\n\t\t}\n\n\t\t@Override\n\t\tpublic void fatal(Object message) {\n\t\t\tlog(Level.FATAL, message, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic void fatal(Object message, Throwable exception) {\n\t\t\tlog(Level.FATAL, message, exception);\n\t\t}\n\n\t\t@Override\n\t\tpublic void error(Object message) {\n\t\t\tlog(Level.ERROR, message, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic void error(Object message, Throwable exception) {\n\t\t\tlog(Level.ERROR, message, exception);\n\t\t}\n\n\t\t@Override\n\t\tpublic void warn(Object message) {\n\t\t\tlog(Level.WARN, message, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tlog(Level.WARN, message, exception);\n\t\t}\n\n\t\t@Override\n\t\tpublic void info(Object message) {\n\t\t\tlog(Level.INFO, message, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tlog(Level.INFO, message, exception);\n\t\t}\n\n\t\t@Override\n\t\tpublic void debug(Object message) {\n\t\t\tlog(Level.DEBUG, message, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic void debug(Object message, Throwable exception) {\n\t\t\tlog(Level.DEBUG, message, exception);\n\t\t}\n\n\t\t@Override\n\t\tpublic void trace(Object message) {\n\t\t\tlog(Level.TRACE, message, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic void trace(Object message, Throwable exception) {\n\t\t\tlog(Level.TRACE, message, exception);\n\t\t}\n\n\t\tprivate void log(Level level, Object message, Throwable exception) {\n\t\t\tif (message instanceof String) {\n\t\t\t\t// Explicitly pass a String argument, avoiding Log4j's argument expansion\n\t\t\t\t// for message objects in case of \"{}\" sequences (SPR-16226)\n\t\t\t\tif (exception != null) {\n\t\t\t\t\tthis.logger.logIfEnabled(FQCN, level, null, (String) message, exception);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.logger.logIfEnabled(FQCN, level, null, (String) message);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.logger.logIfEnabled(FQCN, level, null, message, exception);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class Slf4jLog<T extends Logger> implements Log, Serializable {\n\n\t\tprotected final String name;\n\n\t\tprotected transient T logger;\n\n\t\tpublic Slf4jLog(T logger) {\n\t\t\tthis.name = logger.getName();\n\t\t\tthis.logger = logger;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isFatalEnabled() {\n\t\t\treturn isErrorEnabled();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isErrorEnabled() {\n\t\t\treturn this.logger.isErrorEnabled();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isWarnEnabled() {\n\t\t\treturn this.logger.isWarnEnabled();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isInfoEnabled() {\n\t\t\treturn this.logger.isInfoEnabled();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isDebugEnabled() {\n\t\t\treturn this.logger.isDebugEnabled();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isTraceEnabled() {\n\t\t\treturn this.logger.isTraceEnabled();\n\t\t}\n\n\t\t@Override\n\t\tpublic void fatal(Object message) {\n\t\t\terror(message);\n\t\t}\n\n\t\t@Override\n\t\tpublic void fatal(Object message, Throwable exception) {\n\t\t\terror(message, exception);\n\t\t}\n\n\t\t@Override\n\t\tpublic void error(Object message) {\n\t\t\tif (message instanceof String || this.logger.isErrorEnabled()) {\n\t\t\t\tthis.logger.error(String.valueOf(message));\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void error(Object message, Throwable exception) {\n\t\t\tif (message instanceof String || this.logger.isErrorEnabled()) {\n\t\t\t\tthis.logger.error(String.valueOf(message), exception);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void warn(Object message) {\n\t\t\tif (message instanceof String || this.logger.isWarnEnabled()) {\n\t\t\t\tthis.logger.warn(String.valueOf(message));\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tif (message instanceof String || this.logger.isWarnEnabled()) {\n\t\t\t\tthis.logger.warn(String.valueOf(message), exception);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void info(Object message) {\n\t\t\tif (message instanceof String || this.logger.isInfoEnabled()) {\n\t\t\t\tthis.logger.info(String.valueOf(message));\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tif (message instanceof String || this.logger.isInfoEnabled()) {\n\t\t\t\tthis.logger.info(String.valueOf(message), exception);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void debug(Object message) {\n\t\t\tif (message instanceof String || this.logger.isDebugEnabled()) {\n\t\t\t\tthis.logger.debug(String.valueOf(message));\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void debug(Object message, Throwable exception) {\n\t\t\tif (message instanceof String || this.logger.isDebugEnabled()) {\n\t\t\t\tthis.logger.debug(String.valueOf(message), exception);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void trace(Object message) {\n\t\t\tif (message instanceof String || this.logger.isTraceEnabled()) {\n\t\t\t\tthis.logger.trace(String.valueOf(message));\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void trace(Object message, Throwable exception) {\n\t\t\tif (message instanceof String || this.logger.isTraceEnabled()) {\n\t\t\t\tthis.logger.trace(String.valueOf(message), exception);\n\t\t\t}\n\t\t}\n\n\t\tprotected Object readResolve() {\n\t\t\treturn Slf4jAdapter.createLog(this.name);\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class Slf4jLocationAwareLog extends Slf4jLog<LocationAwareLogger> implements Serializable {\n\n\t\tprivate static final String FQCN = Slf4jLocationAwareLog.class.getName();\n\n\t\tpublic Slf4jLocationAwareLog(LocationAwareLogger logger) {\n\t\t\tsuper(logger);\n\t\t}\n\n\t\t@Override\n\t\tpublic void fatal(Object message) {\n\t\t\terror(message);\n\t\t}\n\n\t\t@Override\n\t\tpublic void fatal(Object message, Throwable exception) {\n\t\t\terror(message, exception);\n\t\t}\n\n\t\t@Override\n\t\tpublic void error(Object message) {\n\t\t\tif (message instanceof String || this.logger.isErrorEnabled()) {\n\t\t\t\tthis.logger.log(null, FQCN, LocationAwareLogger.ERROR_INT, String.valueOf(message), null, null);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void error(Object message, Throwable exception) {\n\t\t\tif (message instanceof String || this.logger.isErrorEnabled()) {\n\t\t\t\tthis.logger.log(null, FQCN, LocationAwareLogger.ERROR_INT, String.valueOf(message), null, exception);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void warn(Object message) {\n\t\t\tif (message instanceof String || this.logger.isWarnEnabled()) {\n\t\t\t\tthis.logger.log(null, FQCN, LocationAwareLogger.WARN_INT, String.valueOf(message), null, null);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tif (message instanceof String || this.logger.isWarnEnabled()) {\n\t\t\t\tthis.logger.log(null, FQCN, LocationAwareLogger.WARN_INT, String.valueOf(message), null, exception);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void info(Object message) {\n\t\t\tif (message instanceof String || this.logger.isInfoEnabled()) {\n\t\t\t\tthis.logger.log(null, FQCN, LocationAwareLogger.INFO_INT, String.valueOf(message), null, null);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tif (message instanceof String || this.logger.isInfoEnabled()) {\n\t\t\t\tthis.logger.log(null, FQCN, LocationAwareLogger.INFO_INT, String.valueOf(message), null, exception);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void debug(Object message) {\n\t\t\tif (message instanceof String || this.logger.isDebugEnabled()) {\n\t\t\t\tthis.logger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, String.valueOf(message), null, null);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void debug(Object message, Throwable exception) {\n\t\t\tif (message instanceof String || this.logger.isDebugEnabled()) {\n\t\t\t\tthis.logger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, String.valueOf(message), null, exception);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void trace(Object message) {\n\t\t\tif (message instanceof String || this.logger.isTraceEnabled()) {\n\t\t\t\tthis.logger.log(null, FQCN, LocationAwareLogger.TRACE_INT, String.valueOf(message), null, null);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void trace(Object message, Throwable exception) {\n\t\t\tif (message instanceof String || this.logger.isTraceEnabled()) {\n\t\t\t\tthis.logger.log(null, FQCN, LocationAwareLogger.TRACE_INT, String.valueOf(message), null, exception);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected Object readResolve() {\n\t\t\treturn Slf4jAdapter.createLocationAwareLog(this.name);\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class JavaUtilLog implements Log, Serializable {\n\n\t\tprivate String name;\n\n\t\tprivate transient java.util.logging.Logger logger;\n\n\t\tpublic JavaUtilLog(String name) {\n\t\t\tthis.name = name;\n\t\t\tthis.logger = java.util.logging.Logger.getLogger(name);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isFatalEnabled() {\n\t\t\treturn isErrorEnabled();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isErrorEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.SEVERE);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isWarnEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.WARNING);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isInfoEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.INFO);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isDebugEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.FINE);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isTraceEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.FINEST);\n\t\t}\n\n\t\t@Override\n\t\tpublic void fatal(Object message) {\n\t\t\terror(message);\n\t\t}\n\n\t\t@Override\n\t\tpublic void fatal(Object message, Throwable exception) {\n\t\t\terror(message, exception);\n\t\t}\n\n\t\t@Override\n\t\tpublic void error(Object message) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic void error(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, exception);\n\t\t}\n\n\t\t@Override\n\t\tpublic void warn(Object message) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, exception);\n\t\t}\n\n\t\t@Override\n\t\tpublic void info(Object message) {\n\t\t\tlog(java.util.logging.Level.INFO, message, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.INFO, message, exception);\n\t\t}\n\n\t\t@Override\n\t\tpublic void debug(Object message) {\n\t\t\tlog(java.util.logging.Level.FINE, message, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic void debug(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINE, message, exception);\n\t\t}\n\n\t\t@Override\n\t\tpublic void trace(Object message) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic void trace(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, exception);\n\t\t}\n\n\t\tprivate void log(java.util.logging.Level level, Object message, Throwable exception) {\n\t\t\tif (this.logger.isLoggable(level)) {\n\t\t\t\tLogRecord rec;\n\t\t\t\tif (message instanceof LogRecord) {\n\t\t\t\t\trec = (LogRecord) message;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trec = new LocationResolvingLogRecord(level, String.valueOf(message));\n\t\t\t\t\trec.setLoggerName(this.name);\n\t\t\t\t\trec.setResourceBundleName(logger.getResourceBundleName());\n\t\t\t\t\trec.setResourceBundle(logger.getResourceBundle());\n\t\t\t\t\trec.setThrown(exception);\n\t\t\t\t}\n\t\t\t\tlogger.log(rec);\n\t\t\t}\n\t\t}\n\n\t\tprotected Object readResolve() {\n\t\t\treturn new JavaUtilLog(this.name);\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class LocationResolvingLogRecord extends LogRecord {\n\n\t\tprivate static final String FQCN = JavaUtilLog.class.getName();\n\n\t\tprivate volatile boolean resolved;\n\n\t\tpublic LocationResolvingLogRecord(java.util.logging.Level level, String msg) {\n\t\t\tsuper(level, msg);\n\t\t}\n\n\t\t@Override\n\t\tpublic String getSourceClassName() {\n\t\t\tif (!this.resolved) {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t\treturn super.getSourceClassName();\n\t\t}\n\n\t\t@Override\n\t\tpublic void setSourceClassName(String sourceClassName) {\n\t\t\tsuper.setSourceClassName(sourceClassName);\n\t\t\tthis.resolved = true;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getSourceMethodName() {\n\t\t\tif (!this.resolved) {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t\treturn super.getSourceMethodName();\n\t\t}\n\n\t\t@Override\n\t\tpublic void setSourceMethodName(String sourceMethodName) {\n\t\t\tsuper.setSourceMethodName(sourceMethodName);\n\t\t\tthis.resolved = true;\n\t\t}\n\n\t\tprivate void resolve() {\n\t\t\tStackTraceElement[] stack = new Throwable().getStackTrace();\n\t\t\tString sourceClassName = null;\n\t\t\tString sourceMethodName = null;\n\t\t\tboolean found = false;\n\t\t\tfor (StackTraceElement element : stack) {\n\t\t\t\tString className = element.getClassName();\n\t\t\t\tif (FQCN.equals(className)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\telse if (found) {\n\t\t\t\t\tsourceClassName = className;\n\t\t\t\t\tsourceMethodName = element.getMethodName();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetSourceClassName(sourceClassName);\n\t\t\tsetSourceMethodName(sourceMethodName);\n\t\t}\n\n\t\t@SuppressWarnings(\"deprecation\")  // setMillis is deprecated in JDK 9\n\t\tprotected Object writeReplace() {\n\t\t\tLogRecord serialized = new LogRecord(getLevel(), getMessage());\n\t\t\tserialized.setLoggerName(getLoggerName());\n\t\t\tserialized.setResourceBundle(getResourceBundle());\n\t\t\tserialized.setResourceBundleName(getResourceBundleName());\n\t\t\tserialized.setSourceClassName(getSourceClassName());\n\t\t\tserialized.setSourceMethodName(getSourceMethodName());\n\t\t\tserialized.setSequenceNumber(getSequenceNumber());\n\t\t\tserialized.setParameters(getParameters());\n\t\t\tserialized.setThreadID(getThreadID());\n\t\t\tserialized.setMillis(getMillis());\n\t\t\tserialized.setThrown(getThrown());\n\t\t\treturn serialized;\n\t\t}\n\t}\n\n}\n```\n","tags":["spring-jcl"],"categories":["spring-jcl"]},{"title":"备忘录模式","url":"%2F2020%2F01%2F04%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F","content":"\n## 备忘录模式\n### 定义\n> Without violating encapsulation,capture and externalize an object's internal state so that the object can be restored to this state later.\n> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态\n\n### 代码实现\n#### 准备\n我们可以用备忘录模式来模拟游戏，游戏开始之后就开始备份游戏开始状态，当游戏失败，游戏结束，我们需要会到游戏开始就需要游戏开始的备份。\n#### 备份\n  1. 备忘录管理员\n```Java\npackage org.example.memento;\n\n/**\n * 备忘录管理员\n */\npublic class Caretaker {\n    private Memento memento ;\n    public Memento getMemento(){\n        return this.memento ;\n    }\n    public void setMemento(Memento memento){\n        this.memento = memento ;\n    }\n}\n```\n  2. 备忘录\n```Java\npackage org.example.memento;\n\n/**\n * 备忘录类，用来备份状态\n */\npublic class Memento {\n    private String state = \"\";\n    /* 初始化备份的状态 */\n    public Memento(String state){\n        this.state = state ;\n    }\n    public String getState(){\n        return this.state ;\n    }\n\n    public void setState(String state){\n        this.state = state ;\n    }\n}\n```\n#### 游戏\n```Java\npackage org.example.memento;\n\n/**\n * 现在我们开始玩一个游戏，游戏中途失败，然后需要重新开始，就需要备份开始阶段，然后从开始阶段重新开始\n * 游戏备份\n */\npublic class Game {\n    /* 状态 */\n    private String state = \"\" ;\n\n    /* 用来改变状态 */\n    public void changeState(){\n        this.state = \"游戏结束\";\n    }\n\n    /* 获取当前状态 */\n    public String getState(){\n        return this.state ;\n    }\n\n    /* 设置当前状态 */\n    public void setState(String state){\n        this.state = state ;\n    }\n\n    /* 创建当前状态的备份 */\n    public Memento createMemento(){\n        return new Memento(this.state);\n    }\n\n    /* 将当备份的状态恢复为当前状态 */\n    public void restoreMemento(Memento memento){\n        this.setState(memento.getState());\n    }\n}\n```\n#### 场景实现\n```Java\npublic class App {\n    /**\n     * 备忘录模式\n     * @param args\n     */\n    public static void main(String[] args) {\n        /* 创建一个游戏 */\n        Game game = new Game();\n\n        /* 开始游戏 */\n        game.setState(\"游戏开始\");\n        System.out.println(\"=======游戏开始状态=======\");\n        System.out.println(game.getState());\n\n        /* 创建游戏备份 */\n        Caretaker caretaker = new Caretaker();\n        caretaker.setMemento(game.createMemento());\n        /* 游戏结束 */\n        game.changeState();\n        System.out.println(\"=======游戏失败状态=======\");\n        System.out.println(game.getState());\n\n        /* 使用游戏备份，会到游戏开始 */\n        game.restoreMemento(caretaker.getMemento());\n        System.out.println(\"=======游戏恢复状态=======\");\n        System.out.println(game.getState());\n    }\n}\n```\n### 备忘录的扩展\n\n### 应用实现\n  1. 需要保存和恢复数据的相关场景。\n  2. 提供回滚操作，包括文本回退等。\n  3. 需要监控的副本场景中，这个需要监控的场景不复杂，可以直接备份。\n  4. 数据库连接的事务管理就是使用备忘录模式。\n### 注意事项\n  1. 备忘录的生命周期。备忘录创建后就要在最近就使用，不能拖的太长。\n  2. 备忘录的性能。不要频繁的使用备忘录。每次创建一个备份都要消耗资源。\n","tags":["行为型模式"],"categories":["行为型模式"]},{"title":"中介者模式","url":"%2F2020%2F01%2F04%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F","content":"\n## 中介者模式\n\n### 定义\n> Define an object that encapsulates how a set of objects interact.Mediator promotes loose coupling by keeping objects from referring to each other explicitly,and it lets you vary their interaction independently.\n> 用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n\n### 代码实现\n#### 中介者\n  1. 抽象中介者\n```Java\npackage org.example.mediator;\n\n/**\n * 抽象中介者\n */\npublic abstract class Mediator {\n    protected ConcreteColleague1 concreteColleague1 ;\n    protected ConcreteColleague2 concreteColleague2 ;\n\n    /**\n     * 中介者模式的中介者需要得到需要中介的对象\n     */\n    public ConcreteColleague1 getConcreteColleague1(){\n        return this.concreteColleague1 ;\n    }\n\n    public void setConcreteColleague1(ConcreteColleague1 concreteColleague1){\n        this.concreteColleague1 = concreteColleague1 ;\n    }\n\n    public ConcreteColleague2 getConcreteColleague2(){\n        return this.concreteColleague2 ;\n    }\n\n    public void setConcreteColleague2(ConcreteColleague2 concreteColleague2){\n        this.concreteColleague2 = concreteColleague2 ;\n    }\n\n    /**\n     * 中介者模式的业务逻辑\n     */\n    public abstract void execute();\n    public abstract void doSomething1();\n    public abstract void doSomething2();\n}\n```\n  2. 具体中介者\n```Java\npackage org.example.mediator;\n\n/**\n * 具体中介者\n */\npublic class ConcreteMediator extends Mediator {\n    @Override\n    public void execute() {\n        doSomething1();\n        doSomething2();\n    }\n\n    @Override\n    public void doSomething1() {\n        System.out.println(\"中介者处理的业务逻辑1\");\n        this.concreteColleague1.selfMethod1();\n        this.concreteColleague2.selfMethod1();\n    }\n\n    @Override\n    public void doSomething2() {\n        System.out.println(\"中介者处理的业务逻辑2\");\n        this.concreteColleague1.selfMethod1();\n        this.concreteColleague2.selfMethod1();\n    }\n}\n```\n#### 同事角色\n  1. 抽象同事角色\n```Java\npackage org.example.mediator;\n\n/**\n * 抽象同事类，所有的同事类都会集成这个抽象类，并与中介者是一对一关系\n */\npublic abstract class Colleague {\n    // 委托中介者对象，表示与中介者是一对一关系\n    protected Mediator mediator ;\n    public Colleague(Mediator mediator){\n        this.mediator = mediator ;\n    }\n}\n```\n  2. 具体同事角色1\n```Java\npackage org.example.mediator;\n\n/**\n * 具体同事类，继承抽象同事类\n */\npublic class ConcreteColleague1 extends Colleague {\n\n    public ConcreteColleague1(Mediator mediator) {\n        super(mediator);\n    }\n\n    /**\n     * 同事类自己特有的业务逻辑\n     */\n    public void selfMethod1(){\n        System.out.println(\"同事类1处理自己的业务逻辑\");\n    }\n\n    /**\n     * 这个同事类与其他同事类有联系的业务逻辑就需要通过中介者来管理\n     */\n    public void depMethod1(){\n        /* 其他不能处理的业务逻辑交给中介者处理 */\n        this.mediator.execute();\n    }\n}\n```\n  3. 具体同事角色2\n```Java\npackage org.example.mediator;\n\npublic class ConcreteColleague2 extends Colleague {\n    public ConcreteColleague2(Mediator mediator) {\n        super(mediator);\n    }\n\n    /**\n     * 同事类自己特有的业务逻辑\n     */\n    public void selfMethod1(){\n        System.out.println(\"同事类2处理自己的业务逻辑\");\n    }\n\n    /**\n     * 这个同事类与其他同事类有联系的业务逻辑就需要通过中介者来管理\n     */\n    public void depMethod1(){\n        /* 其他公共的业务逻辑让中介者代替处理 */\n        super.mediator.execute();\n    }\n}\n```\n#### 场景实现\n```Java\npublic class App {\n    /**\n     * 中介者模式\n     * @param args\n     */\n    public static void main(String[] args) {\n        /* 创建中介者 */\n        Mediator mediator = new ConcreteMediator();\n        /* 创建两个同事角色 */\n        ConcreteColleague1 colleague1 = new ConcreteColleague1(mediator);\n        ConcreteColleague2 colleague2 = new ConcreteColleague2(mediator);\n        /* 将两个同事对象设置入中介对象中，让中介对象中的业务逻辑与同事对象的业务逻辑融合 */\n        mediator.setConcreteColleague1(colleague1);\n        mediator.setConcreteColleague2(colleague2);\n        /* 让同事对象调用融合后的业务逻辑 */\n        colleague1.depMethod1();\n        colleague2.depMethod1();\n    }\n}\n```\n### 应用场景\n  1. 中介者模式适用于多个对象紧密耦合(蜘蛛网状关系)的情况，让其变为星型。\n  2. 中介者模式也叫调停者模式，用来调节多个对象之间的混乱关系。\n  3. 机场调度中心,MVC框架，媒体网关，中介服务都需要使用中介者模式。\n### 中介者模式的优缺点\n#### 优点\n  1. 减少依赖，把原有的一对多的依赖变为一对一的依赖(一个同事对一个中介者)。\n#### 缺点\n  1. 对应的同事太多，中介者类会膨胀。同事类越多，中介者的逻辑就越复杂。\n","tags":["行为型模式"],"categories":["行为型模式"]},{"title":"观察者模式","url":"%2F2020%2F01%2F04%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F","content":"\n## 观察者模式\n\n### 定义\n> Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically.\n> 定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。\n\n### 解释\n观察者模式主要有两个角色，一个被观察者，多个观察者，这个被观察者是与多个观察者关联在一起的。\n当这个被观察者执行任务后，数据会被更新，所有观察者会被唤醒，自动更新被监控观察者的信息。\n### 代码实现\n#### 准备\n现在我们输入一个十进制数字，它会被存入被观察者实体中，而这时会将转换为二进制，八进制，十六进制的观察者唤醒。这样输入一个数字，就回打印出这个数字对应的二进制，八进制，十六进制。\n#### 被观察者\n  1. Subject类\n```Java\npackage org.example.observer;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 被观察者实体类\n */\npublic class Subject {\n    private List<Observer> observers = new ArrayList<>();\n    private int state ;\n\n    public int getState(){\n        return state ;\n    }\n\n    /**\n     * 这是被观察者需要做的动作\n     * @param state\n     */\n    public void setState(int state){\n        System.out.println(\"输入数字:\" + state);\n        this.state = state ;\n        notifyAllObservers(); // 这个是当被观察者开始有动作了，那就自动更新所有的观察者\n    }\n\n    /**\n     * 将观察者加入观察者列表中，这里就包含了所有监控被观察者的观察者。\n     * @param observer\n     */\n    public void attach(Observer observer){\n        observers.add(observer);\n    }\n\n    /**\n     * 唤醒观察者，让观察者自动更新信息\n     */\n    public void notifyAllObservers(){\n        for (Observer observer : observers){\n            observer.update();\n        }\n    }\n}\n\n```\n#### 观察者\n  1. 观察者抽象类\n```Java\npackage org.example.observer;\n\n/**\n * 观察者抽象类\n */\npublic abstract class Observer {\n    protected Subject subject ;\n    public abstract void update();\n}\n```\n  2. 转换为二进制的观察者\n```Java\npackage org.example.observer;\n\npublic class BinaryObserver extends Observer{\n    public BinaryObserver(Subject subject){\n        this.subject = subject ;\n        // 将当前观察者加入被观察者的观察者列表中\n        this.subject.attach(this);\n    }\n    @Override\n    public void update() {\n        System.out.println(\"输入数字的二进制：\"+Integer.toBinaryString(this.subject.getState()));\n    }\n}\n```\n  3. 转换为八进制的观察者\n```Java\npackage org.example.observer;\n\npublic class OctalObserver extends Observer {\n    public  OctalObserver(Subject subject){\n        this.subject = subject ;\n        // 将当前观察者加入被观察者的观察者列表中\n        this.subject.attach(this);\n    }\n    @Override\n    public void update() {\n        System.out.println(\"输入数字的八进制：\"+Integer.toOctalString(this.subject.getState()));\n    }\n}\n```\n  4. 转换为十六进制的观察者\n```Java\npackage org.example.observer;\n\npublic class HexObserver extends Observer{\n    public HexObserver(Subject subject){\n        this.subject = subject ;\n        // 将当前观察者加入被观察者的观察者列表中\n        this.subject.attach(this);\n    }\n    @Override\n    public void update() {\n        System.out.println(\"输入数字的十六进制：\"+Integer.toHexString(this.subject.getState()));\n    }\n}\n```\n#### 场景实现\n```Java\npublic class App {\n    /**\n     * 观察者模式\n     * @param args\n     */\n    public static void main(String[] args) {\n        // 创建一个被观察者\n        Subject subject = new Subject();\n\n        // 创建三个观察者，这三个被观察者实例会被放入被观察者的观察者列表中\n        new HexObserver(subject);\n        new OctalObserver(subject);\n        new BinaryObserver(subject);\n\n        // 当被观察者开始执行，所有的观察者会被唤醒，自动更新\n        subject.setState(10);\n        System.out.println();\n        subject.setState(20);\n    }\n}\n```\n\n### 观察者模式扩展\n被观察者可以被抽象出来，使得其具有良好的扩展性。\n\n### 应用场景\n  1. 关联行为场景，每个行为之间是关联的。一个行为的触发会影响其他行为。\n  2. 事件的多级触发。\n  3. 跨系统的消息交换。比如远程调用就需要观察者模式。\n### 观察者模式优缺点\n#### 优点\n  1. 观察者和被观察者之间是抽象耦合的，这使得观察者和被观察者都很容易的扩展。\n  2. 观察者模式建立了一套触发机制，观察者模式每个观察者与被观察者都遵循单一职责，当被观察者被执行，就回触发观察者，这就形成一个触发链。\n#### 缺点\n  1. 观察者模式需要考虑开发效率和运行效率。java中消息通知是顺序执行，一个观察者失败会影响整体效率，一般采用异步。\n#### 注意事项\n  1. 广播链问题。观察者模型形成的触发链不能太长，如果太长，触发链中的一个产生错误，整个触发链就毁了。因此在一个观察者模式中最多出现一个对象既是观察者又是被观察者，也就是消息最多转发一次(传递两次)。\n  2. 异步处理需要考虑线程安全和队列问题。\n","tags":["行为型模式"],"categories":["行为型模式"]},{"title":"状态模式","url":"%2F2020%2F01%2F04%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F"},{"title":"命令模式","url":"%2F2020%2F01%2F04%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F","content":"\n## 命令模式\n\n### 定义\n> Encapsulate a request as an object,thereby letting you parameterize clients with different requests,queue or log requests,and support undoable operations.\n> 将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。\n\n### 命令模式的示意图\n\n### 代码实现\n#### 接收者\n> 客户最终调用的角色\n  1. 抽象接收者\n```Java\npackage org.example.command;\n\n/**\n * 抽象接收者\n */\npublic abstract class Receiver {\n    /* 接收者需要处理的业务逻辑 */\n    public abstract void receive();\n}\n```\n  2. 具体接收者\n```Java\npackage org.example.command;\n\n/**\n * 具体接收者，接收者是命令模式的主体，命令模式最终调用的还是接收者，获取接收者的信息\n */\npublic class ConcreteRecevier1 extends Receiver {\n    @Override\n    public void receive() {\n        System.out.println(\"需要执行的命令需求\");\n    }\n}\n```\n#### 命令\n> 调用接收者\n  1. 抽象命令\n```Java\npackage org.example.command;\n/**\n * 抽象命令\n */\npublic abstract class Command {\n    /* 执行接收者 */\n    public abstract void execute();\n}\n```\n  2. 具体命令\n```Java\npackage org.example.command;\n\n/**\n * 具体命令，是用来执行接收者，获取接收者信息的\n */\npublic class ConcreteCommand1 extends Command {\n    private Receiver receiver ;\n    /* 初始化接收者 */\n    public ConcreteCommand1(Receiver receiver){\n        this.receiver = receiver ;\n    }\n\n    /**\n     * 执行接收者\n     */\n    @Override\n    public void execute() {\n        this.receiver.receive();\n    }\n}\n```\n#### 调用者\n> 调用命令\n```Java\npackage org.example.command;\n\n/**\n * 调用者，是调用命令，最终我们需要使用调用者来调用命令，而调用接收者\n */\npublic class Invoker {\n    private Command command ;\n\n    /* 接受命令 */\n    public void setCommand(Command command){\n        this.command = command ;\n    }\n\n    /* 执行命令 */\n    public void action(){\n        this.command.execute();\n    }\n}\n```\n#### 场景实现\n```Java\npublic class App {\n    /**\n     * 命令模式\n     * @param args\n     */\n    public static void main(String[] args) {\n        /* 创建接收者 */\n        Receiver receiver = new ConcreteRecevier1();\n        /* 创建命令,用来调用接收者 */\n        Command command = new ConcreteCommand1(receiver);\n\n        /* 创建调用者，用来调用命令 */\n        Invoker invoker = new Invoker();\n\n        /* 设置命令 */\n        invoker.setCommand(command);\n\n        /* 执行命令 */\n        invoker.action();\n    }\n}\n```\n\n### 应用场景\n  1. 在gui开发中可以采用命令模式。一个按钮点击就是一个命令。\n  2. 模拟dos和shell命令也可以采用命令模式。\n### 命令模式的优缺点\n#### 优点\n  1. 类间解耦。各个角色之间没有依赖关系。\n  2. 可扩展性强，命令和接收者都可以扩展。\n  3. 命令模式可以与其他模式结合使用。比如结合责任链模式实现命令族解析，结合模板方法模式减少类膨胀问题。\n#### 缺点\n  1. 有类膨胀问题。命令和接收者虽然可以无限扩展，但会出现类膨胀。\n","tags":["行为型模式"],"categories":["行为型模式"]},{"title":"模板方法模式","url":"%2F2020%2F01%2F04%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F","content":"\n## 模板方法模式\n\n### 定义\n> Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.\n> 定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n### 代码实现\n#### 准备\n我们先抽象出一个汽车类，将汽车需要的动作都抽象进来，然后定义一个算法骨架，将这些抽象的动作组织起来，形成一个动作流程。由于这些动作是抽象的，我们需要具体实现这些动作，当我们创建一个实现类的对象，我们就会继承这个算法骨架，这就让我们的实现类只需要实现动作就行了，不需要再自定义动作流程。\n\n#### 模板方法模式\n  1. 创建一个汽车抽象类，抽象出所有汽车都需要的共同动作，并将所有共同动作组织成一个使用流程。\n```Java\n/**\n * 我们可以将汽车类中的方法分为动作流程方法和各个动作方法\n * 汽车抽象类定义了一个算法框架，各个抽象动作方法就是抽象出来的各个需要使用的动作,动作流程方法run就是一个算法骨架，用来描述动作流程。\n * 当各个抽象的动作方法被子类实现，run这个算法骨架就能执行相应的子类的动作\n *\n * 也就是说，相关动作被抽象出来，延迟到子类实现，而调用这些动作的算法骨架就在抽象类中，我们创建一个子类对象时，我们就能直接使用抽象类中定义的算法骨架，这个算法骨架就是模板\n */\npublic abstract class Car {\n\n    /**\n     * 汽车动作被设计为protected,只需要被子类访问，外界不能访问，这样就只将run方法暴露\n     */\n    \n    /* 汽车启动 */\n    protected abstract void start();\n\n    /* 汽车停止 */\n    protected abstract void stop();\n\n    /* 按喇叭 */\n    protected abstract void alarm();\n\n    /* 汽车引擎启动 */\n    protected abstract void engineBoom();\n\n    /* 汽车运行过程模板 */\n    public void run(){\n        /* 汽车启动起来 */\n        this.start();\n        /* 汽车引擎开始启动，汽车开始运行 */\n        this.engineBoom();\n        /* 然后就开始跑了，遇到障碍，就按喇叭 */\n        this.alarm();\n        /* 于是停止下来 */\n        this.stop();\n    }\n}\n```\n  2. 然后实现一个东风汽车这个实现类，这个实现类只需要实现汽车抽象类的抽象动作。我们使用东风汽车时需要调用的使用方法就通过继承汽车抽象类继承下来了。\n```Java\n\n/**\n * 东风汽车是汽车的一个具体实现，汽车这个抽象类为东风汽车这个具体类提供了一个模板。\n */\npublic class DongFeng extends Car {\n    @Override\n    public void start() {\n        System.out.println(\"东风启动起来了\");\n    }\n\n    @Override\n    public void stop() {\n        System.out.println(\"东风停下来了\");\n    }\n\n    @Override\n    public void alarm() {\n        System.out.println(\"东风拉起汽笛\");\n    }\n\n    @Override\n    public void engineBoom() {\n        System.out.println(\"东风引擎启动起来了\");\n    }\n}\n```\n\n  3. 场景实现类,我们只需要创建东风汽车这个对象，就能调用汽车抽象类中的run方法。\n```Java\npublic class App { \n    /**\n     * 模板方法场景类\n     * @param args\n     */\n    public static void main(String[] args) {\n        DongFeng dongFeng = new DongFeng();\n        dongFeng.run();\n    }\n}\n```\n#### 模板方法模式的扩展\n> 在抽象类中实现一个钩子函数，这个钩子函数能够被子类重写，我们通过更改子类重写的钩子函数结果，覆盖父类的钩子函数结果，从而改变父类中的动作逻辑，改变结果。\n  1. 创建一个汽车抽象类，这个抽象类中有一个钩子函数实现。在实现逻辑中加入了一个判断，通过判断钩子函数的结果走不同的逻辑。\n```Java\n/**\n * 我们可以将汽车类中的方法分为动作流程方法和各个动作方法\n * 汽车抽象类定义了一个算法框架，各个抽象动作方法就是抽象出来的各个需要使用的动作,动作流程方法run就是一个算法骨架，用来描述动作流程。\n * 当各个抽象的动作方法被子类实现，run这个算法骨架就能执行相应的子类的动作\n *\n * 也就是说，相关动作被抽象出来，延迟到子类实现，而调用这些动作的算法骨架就在抽象类中，我们创建一个子类对象时，我们就能直接使用抽象类中定义的算法骨架，这个算法骨架就是模板\n */\npublic abstract class Car {\n\n    /**\n     * 汽车动作被设计为protected,只需要被子类访问，外界不能访问，这样就只将run方法暴露\n     */\n\n    /* 汽车启动 */\n    protected abstract void start();\n\n    /* 汽车停止 */\n    protected abstract void stop();\n\n    /* 按喇叭 */\n    protected abstract void alarm();\n\n    /* 汽车引擎启动 */\n    protected abstract void engineBoom();\n\n    /* 汽车运行过程模板 */\n    public void run(){\n        /* 汽车启动起来 */\n        this.start();\n        /* 汽车引擎开始启动，汽车开始运行 */\n        this.engineBoom();\n        /* 然后就开始跑了，遇到障碍，就按喇叭 */\n        if (isAlarm()){\n            this.alarm();\n        }\n        /* 于是停止下来 */\n        this.stop();\n    }\n\n    /**\n     * 在这里定义一个钩子函数，钩子函数能影响模板方法的执行\n     * 这个函数能被子类覆盖，设置为子类的值\n     * 子类能通过该钩子函数影响父类，从影响最终执行结果\n     * @return\n     */\n    protected boolean isAlarm(){\n        return true ;\n    }\n}\n```\n  2. 创建一个子类实现，这个子类将父类的钩子函数重写，并让我们能更改钩子函数的结果。\n```Java\n/**\n * 东风汽车是汽车的一个具体实现，汽车这个抽象类为东风汽车这个具体类提供了一个模板。\n */\npublic class DongFeng extends Car {\n    private boolean alarmFlag = true ;\n\n    @Override\n    public void start() {\n        System.out.println(\"东风启动起来了\");\n    }\n\n    @Override\n    public void stop() {\n        System.out.println(\"东风停下来了\");\n    }\n\n    @Override\n    public void alarm() {\n        System.out.println(\"东风拉起汽笛\");\n    }\n\n    @Override\n    public void engineBoom() {\n        System.out.println(\"东风引擎启动起来了\");\n    }\n\n    /**\n     * 这个就是子类重写的父类方法\n     * @return\n     */\n    protected boolean isAlarm(){\n        return this.alarmFlag ;\n    }\n\n    /**\n     * 我们可以通过这个方法来影响执行结果\n     * @param flag\n     */\n    public void setAlarm(boolean flag){\n        this.alarmFlag = flag ;\n    }\n}\n```\n\n  3. 最后的场景实现类,我们能通过set方法更改父类中的逻辑，从而改变结果。\n```Java\npublic class App { \n    /**\n     * 模板方法扩展\n     * @param args\n     */\n    public static void main(String[] args) {\n        DongFeng dongFeng = new DongFeng();\n        dongFeng.setAlarm(false);\n        dongFeng.run();\n    }\n}\n```\n### 应用场景\n  1. 多个子类共有方法时，并且逻辑相同。\n  2. 重要、复杂的核心算法设计为模板在父类实现，细节部分有子类实现。\n  3. \n### 模板方法模式优缺点\n#### 优点\n  1. 封装不变部分，扩展可变部分；就是将不变部分封装到抽象类中，可变部分就通过继承来继续扩展。不变部分能被继承子类调用。\n  2. 提取公共代码，便于维护。子类继承的是每个子类的特性，而每个子类都需要的公共代码就封装在抽象类中。\n  3. 行为由父类控制，子类实现。父类将行为抽象，让子类具体按照自己的特征实现。\n#### 缺点\n  1. 模板方法模式颠倒了子类和父类的作用。父类本来只负责声明抽象的部分，子类实现这些抽象部分，其他具体实现由子类自己实现，子类不会对父类产生影响。但是模板方法下，父类不仅需要声明抽象行为，还有具体实现，子类只需要实现抽象部分，这样子类会对父类产生影响。\n","tags":["行为型模式"],"categories":["行为型模式"]},{"title":"组合模式","url":"%2F2020%2F01%2F04%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F","content":"\n## 组合模式\n\n### 定义\n> Compose objects into tree structures to represent part-whole hierarchies.Composite lets clients treat individual objects and compositions of objects uniformly.\n> 将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性\n","tags":["结构型模式"],"categories":["结构型模式"]},{"title":"享元模式","url":"%2F2020%2F01%2F04%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F","content":"\n## 享元模式\n\n### 定义\n> Use sharing to support large numbers of fine-grained objects efficiently.\n> 使用共享对象可有效地支持大量的细粒度的对象\n","tags":["结构型模式"],"categories":["结构型模式"]},{"title":"外观模式","url":"%2F2020%2F01%2F04%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F","content":"\n## 外观模式\n\n### 定义\n> Provide a unified interface to a set of interfaces in a subsystem.Facade defines a higher-level interface that makes the subsystem easier to use.\n> 要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。\n\n### 代码实现\n#### 准备\n\n#### 子系统\n#### 门面对象\n#### 场景实现\n","tags":["结构型模式"],"categories":["结构型模式"]},{"title":"装饰模式","url":"%2F2020%2F01%2F04%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F","content":"\n## 装饰模式\n\n### 定义\n> Attach additional responsibilities to an object dynamically keeping the same interface.Decorators provide a flexible alternative to subclassing for extending functionality.\n> 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。\n\n\n","tags":["结构型模式"],"categories":["结构型模式"]},{"title":"桥接模式","url":"%2F2020%2F01%2F04%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F"},{"title":"代理模式","url":"%2F2020%2F01%2F04%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F"},{"title":"工厂模式","url":"%2F2020%2F01%2F04%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F","content":"\n## 工厂模式\n\n### 定义\n#### 工厂方法定义\n> Define an interface for creating an object,but let subclasses decide which class to instantiate.Factory Method lets a class defer instantiation to subclasses.\n> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。\n#### 抽象工厂定义\n> Provide an interface for creating families of related or dependent objects without specifying their concrete classes.\n> 为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类。\n### 工厂模式种类\n 1. 简单工厂(静态工厂)\n 2. 工厂方法\n 3. 多工厂方法\n 4. 单例工厂\n 5. 抽象工厂\n工厂模式主要分为工厂方法模式和抽象工厂模式。其他的模式是工厂方法的延伸。\n\n工厂模式的多个种类可以看作是一个升级路线: 简单工厂-->工厂方法-->多工厂方法-->抽象方法\n简单方法是工厂类没有抽象工厂。不能进行扩展，并且创建方法是静态方法。\n工厂方法是简单工厂的升级版，增加了抽象工厂类，创建方法也是成员方法。工厂方法只能生产一类的产品。\n多工厂方法是工厂方法的升级版，多工厂方法能够生产多个种类的产品，但是每个种类的产品都需要创建一个匹配的工厂。\n抽象工厂则是工厂方法的升级版，抽象工厂能将多个种类的产品放在一个工厂中生产。\n\n### 工厂模式实现\n现在我们需要创建尼安德特人，直立人和智人三个人种。\n按照工厂模式，我们需要抽象人，具体人种，抽象工厂，具体工厂四个类。\n使用简单工厂，不需要抽象工厂，直接通过具体工厂的静态方法生产出对应人种。\n使用工厂方法，通过实现抽象工厂，为每个人种创建对应的工厂，每个工厂创建一个种类。\n使用抽象方法，通过实现抽象工厂，为多个具有相同特征的人种建立一个工厂，创建一条生产线，直接生产出需要的人种族。\n\n### 代码实现\n#### 产品准备\n  1. 抽象出人出来\n```Java\n/**\n * 这是所有人种的能力\n */\npublic interface Human {\n    /* 人能说 */\n    public void talk();\n\n    /* 人能使用工具 */\n    public void useTools();\n\n    /* 人能双脚走路 */\n    public void walkOnTwoFeet();\n}\n```\n  2. 尼安德特人类\n```Java\n/**\n * 尼安德特人，从12万年前开始生活在欧洲，亚洲西部以及非洲北部，在2.4万年前消失了，有学者认为他们是被智人(现代人)灭绝的\n */\npublic class HomoNeanderthalensis implements Human{\n  @Override\n    public void talk() {\n      System.out.println(\"尼安德特人能说话\");\n    }\n\n  @Override\n    public void useTools() {\n      System.out.println(\"尼安德特人能使用工具\");\n    }\n\n  @Override\n    public void walkOnTwoFeet() {\n      System.out.println(\"尼安德特人能用两只脚走路\");\n    }\n}\n```\n  3. 直立人\n```Java\n/**\n * 直立人，生活在距今180万-300万年的非洲、欧洲、和亚洲的人种\n */\npublic class HomoErectus implements Human{\n  @Override\n    public void talk() {\n      System.out.println(\"直立人能说话\");\n    }\n\n  @Override\n    public void useTools() {\n      System.out.println(\"直立人能使用工具\");\n    }\n\n  @Override\n    public void walkOnTwoFeet() {\n      System.out.println(\"直立人能用两只脚走路\");\n    }\n}\n```\n  4. 智人\n```Java\n/**\n * 智人，现代人种的祖先，距今25万-4万年前。与尼安德特人，直立人同属于人属的人种\n */\npublic class HomoSapiens implements Human{\n  @Override\n    public void talk() {\n      System.out.println(\"智人能说话\");\n    }\n\n  @Override\n    public void useTools() {\n      System.out.println(\"智人能使用工具\");\n    }\n\n  @Override\n    public void walkOnTwoFeet() {\n      System.out.println(\"智人能用两只脚走路\");\n    }\n}\n```\n#### 简单工厂\n  1. 创建一个简单工厂\n```Java\n/**\n * 简单工厂模式\n * 前面已经有了三个人种类\n * 这里有一个工厂，用来创建人种。现在我们需要获取我们需要的人种对象，直接通过工厂来进行创建\n * 这个工厂使用反射来创建对象实例\n *\n * 工厂方法与简单工厂之间区别就是，简单工厂没有父类，不能进行扩展。并且创建方法是静态方法，简化了类的创建过程\n */\npublic class SimpleFactory {\n  public static <T extends Human> T createHuman(Class<T> c) {\n    Human human = null ;\n    try {\n      human = (Human)Class.forName(c.getName()).newInstance();\n    } catch (Exception e) {\n      System.out.println(\"人种生成错误\");\n    }\n    return (T) human ;\n  }\n}\n```\n#### 工厂方法\n  1. 创建一个抽象工厂\n```Java\n/**\n * 创建一个抽象工厂\n */\npublic abstract class AbstractHumanFactory {\n    public abstract <T extends Human> T createHuman(Class<T> c);\n}\n```\n  2. 创建一个具体工厂\n```Java\n/**\n * 工厂方法模式\n */\npublic class MethodFactory extends AbstractHumanFactory{\n  @Override\n    public <T extends Human> T createHuman(Class<T> c) {\n      Human human = null ;\n      try {\n        human = (Human) Class.forName(c.getName()).newInstance();\n      } catch (Exception e) {\n        System.out.println(\"人种生成错误\");\n      }\n      return (T) human ;\n    }\n}\n```\n#### 多工厂方法\n  1. 创建一个抽象工厂\n```Java\npublic abstract class AbstractHumanFactory1 {\n    public abstract Human createHuman();\n}\n```\n  2. 为各个人种(产品)创建各自的工厂\n直立人\n```Java\npublic class HomoErectusFactory extends AbstractHumanFactory1 {\n  @Override\n    public Human createHuman() {\n      return new HomoErectus();\n    }\n}\n```\n尼安德特人\n```Java\npublic class HomoNeanderthalensisFactory extends AbstractHumanFactory1 {\n  @Override\n    public Human createHuman() {\n      return new HomoNeanderthalensis();\n    }\n}\n```\n智人\n```Java\npublic class HomoSapiensFactory extends AbstractHumanFactory1 {\n  @Override\n    public Human createHuman() {\n      return new HomoSapiens();\n    }\n}\n```\n#### 单例工厂\n  1. 创建人\n```Java\npublic class SingleTonHuman implements Human {\n  private SingleTonHuman(){\n\n  }\n\n  @Override\n    public void talk() {\n      System.out.println(\"人能说话\");\n    }\n\n  @Override\n    public void useTools() {\n      System.out.println(\"人能使用工具\");\n    }\n\n  @Override\n    public void walkOnTwoFeet() {\n      System.out.println(\"人能用两只脚走路\");\n    }\n}\n```\n  2. 创建单例工厂\n```Java\npublic class SingleTonHumanFactory {\n  private static SingleTonHuman singleTonHuman ;\n  static {\n    try {\n      Class c = Class.forName(SingleTonHuman.class.getName());\n      Constructor constructor = c.getDeclaredConstructor();\n      constructor.setAccessible(true);\n      singleTonHuman = (SingleTonHuman)constructor.newInstance();\n    } catch (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {\n      e.printStackTrace();\n    }\n  }\n\n  public SingleTonHuman getInstance(){\n    return singleTonHuman ;\n  }\n}\n```\n#### 抽象工厂\n  1. 创建一个抽象工厂，其中定义了一个产品族(生产线)\n```Java\npublic interface AbstractFactory {\n    public HomoSapiens createHomoSapiens();\n    public HomoErectus createHomoErectus();\n    public HomoNeanderthalensis createHomoNeanderthalensis();\n}\n```\n  2. 创建一个产品线工厂\n```Java\npublic class HumanFactory implements AbstractFactory {\n    @Override\n    public HomoSapiens createHomoSapiens() {\n            return new HomoSapiens();\n        }\n\n    @Override\n    public HomoErectus createHomoErectus() {\n            return new HomoErectus();\n        }\n\n    @Override\n    public HomoNeanderthalensis createHomoNeanderthalensis() {\n            return new HomoNeanderthalensis();\n        }\n}\n```\n\n#### 各个工厂的场景实现\n```Java\npublic class App\n{\n  /**\n   * 简单工厂\n   */\n  /*public static void main( String[] args )\n    {\n    Human human = SimpleFactory.createHuman(HomoErectus.class);\n    human.talk();\n    human.useTools();\n    }*/\n\n  /**\n   * 工厂方法\n   * 一个工厂生产一个产品\n   */\n  /*public static void main(String[] args) {\n    MethodFactory factory = new MethodFactory();\n    HomoSapiens human = factory.createHuman(HomoSapiens.class);\n    human.talk();\n    human.useTools();\n    human.walkOnTwoFeet();\n    }*/\n\n  /**\n   * 多工厂\n   * 工厂方法的延伸，多个工厂生产多个产品\n   * @param args\n   */\n  /*public static void main(String[] args) {\n    Human homoErectus = new HomoErectusFactory().createHuman();\n    homoErectus.useTools();\n    homoErectus.talk();\n    homoErectus.walkOnTwoFeet();\n\n    Human homoSapiens = new HomoSapiensFactory().createHuman();\n    homoSapiens.useTools();\n    homoSapiens.talk();\n    homoSapiens.walkOnTwoFeet();\n\n    Human homoNeanderthalensis = new HomoNeanderthalensisFactory().createHuman();\n    homoNeanderthalensis.useTools();\n    homoNeanderthalensis.talk();\n    homoNeanderthalensis.walkOnTwoFeet();\n    }*/\n\n  /**\n   * 单例工厂\n   * @param args\n   */\n  /*public static void main(String[] args) {\n    SingleTonHumanFactory factory = new SingleTonHumanFactory();\n    SingleTonHuman instance = factory.getInstance();\n    instance.useTools();\n    instance.talk();\n    instance.walkOnTwoFeet();\n    }*/\n\n  /**\n   * 抽象工厂\n   * 一个共产能生产多个产品\n   * @param args\n   */\n  public static void main(String[] args) {\n    /* 建设人类生产线 */\n    HumanFactory humanFactory = new HumanFactory();\n\n    /**\n     * 抽象工厂只需要一个工厂就能生产出需要的所有人种，而工厂方法如果想要生产人种，需要为每个人种创建一个工厂来进行生产\n     * 抽象工厂将需要的产品创建方法抽象出来，之后只需要创建一个实体工厂就能创建需要的产品族\n     */\n    /* 创建一个人种 */\n    HomoErectus homoErectus = humanFactory.createHomoErectus();\n    homoErectus.useTools();\n    homoErectus.talk();\n    homoErectus.walkOnTwoFeet();\n\n    HomoNeanderthalensis homoNeanderthalensis = humanFactory.createHomoNeanderthalensis();\n    homoNeanderthalensis.useTools();\n    homoNeanderthalensis.talk();\n    homoNeanderthalensis.walkOnTwoFeet();\n\n    HomoSapiens homoSapiens = humanFactory.createHomoSapiens();\n    homoSapiens.useTools();\n    homoSapiens.talk();\n    homoSapiens.walkOnTwoFeet();\n\n  }\n}\n```\n\n### 应用场景\n#### 工厂方法模式\n  1. 工厂方法模式可以作为new一个对象的替代品。\n  2. 工厂方法可以用在需要灵活的、可扩展框架的地方。\n  3. 工厂方法也可以用在异构项目中。\n  4. 可以用在驱动开发的框架下。\n#### 抽象工厂模式\n  1. 对一个对象族都有相同的约束。\n### 工厂模式优缺点\n#### 工厂方法模式优缺点\n##### 优点\n  1. 良好的封装性，代码结构清晰。\n  2. 工厂方法模式的扩展性很好。\n  3. 可以屏蔽产品类，我们只需要让工厂帮我们生产产品就行了。\n  4. 工厂方法是典型的解耦。\n#### 抽象工厂模式优缺点\n##### 优点\n  1. 封装性，我们只需要关心接口就行了，不关心产品是怎样创建的，工厂帮我们创建。\n  2. 产品族内的约束为非公开约束，我们不需要知道知道这个约束，我们只需要得到产品就可以了。\n##### 缺点\n  1. 抽象工厂可以生产一个产品族，但是产品族的扩展很困难。\n","tags":["创建型模式"],"categories":["创建型模式"]},{"title":"jvm内存模型","url":"%2F2019%2F12%2F31%2FJava%2Fjvm%2Fclass%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%2FClassFile%E7%BB%93%E6%9E%84%2F","content":"\n## ClassFile结构\n\n### ClassFile结构体\n一个class文件由一个ClassFile结构组成。\n```Java\nClassFile {\n u4 magic;                                      // class文件的魔数，用来验证class文件的格式是否正确，它的值为0xCAFEBABE\n u2 minor_version;                              // class文件的小版本号\n u2 major_version;                              // class文件的大版本号\n u2 constant_pool_count;                        // 常量池索引数\n cp_info constant_pool[constant_pool_count-1];  // 常量池数组，存储所有常量\n u2 access_flags;                               // 访问修饰符标志(public,final,super,interface,abstract, synthetic,annotation,enum)\n u2 this_class;                                 // 当前类，这个值必须是在constant_pool表中一个有效索引，这个索引下的值必须是一个CONSTANT_Class_info结构，它表示class文件中类或接口被定义\n u2 super_class;                                // 父类，这个值必须为0或者必须是在constant_pool表中一个有效索引，当为0时，class表示为一个没有父类的类对象；是常量池索引时，表示class文件定义的类的直接父类\n u2 interfaces_count;                           // 接口数，表示这个类或接口直接父接口数量\n u2 interfaces[interfaces_count];               // 接口数组，表示这个类所有的直接父接口\n u2 fields_count;                               // 字段数(字段包括类变量，实例变量，申明类或接口的类型)\n field_info fields[fields_count];               // class中所有的字段\n u2 methods_count;                              // 方法数\n method_info methods[methods_count];            // class中所有的方法\n u2 attributes_count;                           // 属性数\n attribute_info attributes[attributes_count];   // class中所以有的属性\n}\n```\n#### magic\n魔数，是class文件的第一个字段，主要用来识别class文件是否能被jvm虚拟机识别。\n魔数值为：0xCAFEBABE\n使用魔数而不是扩展名进行识别主要是基于安全考虑，因为扩展名容易被改动。\n#### minor_version与major_version\nminor_version与major_version一起组成class文件的版本号，这个版本号能可以让我们知道class文件是哪个版本的jvm编译的。\n  1. jdk与major对应版本\n```Java\nJ2SE 8      = 52\nJ2SE 7      = 51\nJ2SE 6.0    = 50\nJ2SE 5.0    = 49\nJDK 1.4     = 48\nJDK 1.3     = 47\nJDK 1.2     = 46\nJDK 1.1     = 45\n```\n\n  2. 使用javap获取class文件信息\n```Java\nE:\\code\\test\\target\\classes\\com\\example\\test\\test>javap -v TestApplication.class\nClassfile /E:/code/test/target/classes/com/example/test/test/TestApplication.class\n  Last modified 2020-1-2; size 743 bytes\n  MD5 checksum dc0a6ae2f5edfed8ea91866691b95593\n  Compiled from \"TestApplication.java\"\npublic class com.example.test.test.TestApplication\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #4.#21         // java/lang/Object.\"<init>\":()V\n   #2 = Class              #22            // com/example/test/test/TestApplication\n   #3 = Methodref          #23.#24        // org/springframework/boot/SpringApplication.run:(Ljava/lang/Class;[Ljava/lang/String;)Lorg/springframework/context/ConfigurableApplicationContext;\n   #4 = Class              #25            // java/lang/Object\n   #5 = Utf8               <init>\n   #6 = Utf8               ()V\n   #7 = Utf8               Code\n   #8 = Utf8               LineNumberTable\n   #9 = Utf8               LocalVariableTable\n  #10 = Utf8               this\n  #11 = Utf8               Lcom/example/test/test/TestApplication;\n  #12 = Utf8               main\n  #13 = Utf8               ([Ljava/lang/String;)V\n  #14 = Utf8               args\n  #15 = Utf8               [Ljava/lang/String;\n  #16 = Utf8               MethodParameters\n  #17 = Utf8               SourceFile\n  #18 = Utf8               TestApplication.java\n  #19 = Utf8               RuntimeVisibleAnnotations\n  #20 = Utf8               Lorg/springframework/boot/autoconfigure/SpringBootApplication;\n  #21 = NameAndType        #5:#6          // \"<init>\":()V\n  #22 = Utf8               com/example/test/test/TestApplication\n  #23 = Class              #26            // org/springframework/boot/SpringApplication\n  #24 = NameAndType        #27:#28        // run:(Ljava/lang/Class;[Ljava/lang/String;)Lorg/springframework/context/ConfigurableApplicationContext;\n  #25 = Utf8               java/lang/Object\n  #26 = Utf8               org/springframework/boot/SpringApplication\n  #27 = Utf8               run\n  #28 = Utf8               (Ljava/lang/Class;[Ljava/lang/String;)Lorg/springframework/context/ConfigurableApplicationContext;\n{\n  public com.example.test.test.TestApplication();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 7: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Lcom/example/test/test/TestApplication;\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: ldc           #2                  // class com/example/test/test/TestApplication\n         2: aload_0\n         3: invokestatic  #3                  // Method org/springframework/boot/SpringApplication.run:(Ljava/lang/Class;[Ljava/lang/String;)Lorg/springframework/context/ConfigurableApplicationContext;\n         6: pop\n         7: return\n      LineNumberTable:\n        line 10: 0\n        line 11: 7\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       8     0  args   [Ljava/lang/String;\n    MethodParameters:\n      Name                           Flags\n      args\n}\nSourceFile: \"TestApplication.java\"\nRuntimeVisibleAnnotations:\n  0: #20()\n```\n#### constant_pool_count\n常量池元素数等于常量池表最大索引值加1。如果一个常量池索引值大于0，小于constant_pool_count，那它是有效的索引。\n#### constant_pool[constant_pool_count-1]\n常量池数组，这是一个包含多种结构的表，它表示在ClassFile结构和它的子结构中的多种string常量，class和interface名，字段名和其他的常量。\n每个常量表项通过第一个tag字节表示一个格式。\n这个常量池表的最大索引值为constant_pool_count-1\n#### access_flags\n访问标志，用来确定类或者接口的访问权限和属性。 \n![access_flag](access_flag.png)\n##### 接口通过设置ACC_INTERFACE标志来被区分\n  1. 如果ACC_INTERFACE标志被设置，则ACC_ABTRACT标志必须也被设置，这个class将被定义为一个接口，并且ACC_FINAL,ACC_SUPER,ACC_ENUM将不会被设置(因为final修饰不能被继承或实现，super表示有父类，接口没有父类，enum是一个枚举类型，与类和接口不一样)。\n  2. 如果ACC_INTERFACE标志没有被设置，这个class将被定义为一个类而不是接口,除了ACC_ANNOTATION外，其他的标志都可能会被设置(因为只有接口才能成为注解);如果这个类是一个实体类，ACC_ABTRACT将不会被设置;如果设置ACC_FINAL,表示这个类不能被继承。\n##### ACC_SUPER\n  1. 如果ACC_SUPER出现在类或者接口中，invokespecial指令被调用，ACC_SUPER有两种语义被表示。\n  2. 在早期编译器中，ACC_SUPER会被忽略掉，但是在java 8 及以上版本的编译器则会在每个类中设置ACC_SUPER标志。\n  3. ACC_SUPER用来表示如何调用父类，早期版本编译器使用invokenonvirtual指令(invokespecial前身，未设置ACC_SUPER)来调用父类方法，这个指令是编译时绑定，当编译后父类被更改，但不重新编译，这时依然会运行之前绑定的方法；但是使用invokespecial指令(设置了ACC_SUPER)则会搜索类层次，找到最近一个父类进行方法调用，得到正确结果。\n##### ACC_SYNTHETIC\n  1. 这个标志表示这个类或者接口通过编译器被生成，并且不会出现在源代码中。\n##### ACC_ENUM\n  1. 这个标志表示这个类或者它的子类被定义为一个枚举类型。\n#### this_class\n  1. this_class元素的值必须是在常量池表中的一个有效索引，这个索引对应的常量池项必须是一个CONSTANT_Class_info结构(类结构),表示在class文件中一个类或者接口被定义。\n#### super_class\n对于一个类\n  1. super_class元素的值被设置为0或者其值是在常量池中的一个有效索引。\n  2. 如果super_class的值不为0，那么这个值在常量池中对应的索引对应的常量池项是一个CONSTANT_Class_info结构，它被表示class文件定义了这个类的直接父类。\n  3. 如果这个类没有一个或者多个直接父类，那么这个类可能被设置ACC_FINAL标志。\n  4. 如果super_class元素值为0，这个class文件必须表示为这个类对象本身，并且这个类或者接口没有一个直接父类。\n  5. 对于一个接口，super_class的值必须总是在常量池中的一个有效值。这个索引对应的常量池项必须是一个CONSTANT_Class_info结构，它表示这个类对象本身。\n#### interfaces_count\n  1. 接口数，表示这个类或者接口的直接父接口数量。\n#### interfaces[interfaces_count]\n  1. 在interfaces数组中的值都是在常量池中的一个有效索引。\n  2. 每个有效索引对应的常量池项必须是一个CONSTANT_Class_info结构，它表示为这个类或接口的一个直接父接口。interfaces中索引从小到大表示一个类的接口从左到右。\n#### fields_count\n  1. fields_count的值表示在字段表中的field_info结构数量。\n  2. field_info结构表示所有的字段，包括类变量，实例变量，申明类或接口的类型。\n#### fields[fields_count]\n  1. 在字段表中的每个值必须是一个field_info结构，它是在一个类或者接口中一个字段的完整描述。\n  2. 这个字段表包括了在这个类或者接口中被申明的所有字段。\n  3. 这个字段表不包括从父类或父接口继承的字段。\n#### methods_count\n  1. methods_count元素的值表示在methods表中的method_info结构数量。\n#### methods[methods_count]\n  1. 在methods表中的每个值是一个method_info结构，它是在这个类或接口中的一个方法的完整描述。\n  2. 如果在一个method_info结构中的access_flags中ACC_NATIVE和ACC_ABSTRACT标志都没被设置(表示这个方法不是本地方法，也不是抽象方法)，java虚拟机提供了实现该方法的指令。\n  3. method_info结构表示在类或者接口中被申明的所有方法，包括实例方法，类方法，实例初始化方法和一些类或接口的初始化方法。\n  4. 这个方法表不包括从父类或者父接口继承的方法。\n#### attributes_count\n  1. attributes_count元素的值表示在attributes表中的属性数\n#### attributes[attributes_count]\n  1. 在属性表中的每个值都是一个attribute_info结构。\n##### 被定义的属性\n![attributes](attributes.png)\n##### 属性结构定义\n```Java\nattribute_info {\n u2 attribute_name_index;\n u4 attribute_length;\n u1 info[attribute_length];\n}\n```\n\n### 文献引用\n[ACC_SUPER和早期的invokespecial](https://blog.csdn.net/xinaij/article/details/38872851)\n","tags":["Class文件格式"],"categories":["Class文件格式"]},{"title":"jvm内存模型","url":"%2F2019%2F12%2F31%2FJava%2Fjvm%2Fjvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F","content":"\n## jvm内存模型\n\n### java内存结构\n#### 内存结构图\n以下是两个java内存结构图\n![java内存结构1](jvm内存结构.webp)\n![java内存结构2](java内存结构.png)\n#### 内存结构详解\n##### 方法区\n  1. 方法区是被java虚拟机线程共享，它被用来存储每个加载进入的类的结构，包括运行时常量池，字段，方法数据，方法代码和构造器。\n  2. 方法区是在虚拟机启动就创建，虽然方法区逻辑上是属于堆的一部分，但是它不被垃圾回收器回收或者是压缩。\n  3. 方法区可以是大小固定，也可以根据需要进行扩展或者收缩。\n  4. 如果java虚拟机不能为方法区分配足够的内存，会出现OutOfMemoryError内存溢出异常。\n  5. 方法区中的运行时常量池。一个运行时常量池是一个class文件被装载后，class中的常量池被载入内存，并保存到方法区。每个运行时常量池在java虚拟机的方法区被分配，当一个类或者接口被创建时，相应的运行时常量池也会被创建。\n##### java堆\n  1. java堆是被所有java虚拟机线程共享的。堆在运行时内存区，类实例对象和数组将会在这里被分配内存。\n  2. 堆在虚拟机启动时就被创建。堆中存储的对象会被gc回收。对象从不显示的释放。\n##### java栈\n  1. java虚拟机栈是线程私有的，每个线程都会创建一个自己的虚拟机栈。\n  2. java栈中存储有栈帧，栈帧存储了方法的局部变量表(local variables)，操作数栈，动态连接和方法返回地址。\n  3. 栈帧除了入栈帧和出栈帧外，从不直接操作，因此可以对帧进行堆分配。\n  4. 局部变量表: \n\t  局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量,它是一个变量数组。\n\t  在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。\n\t  单个局部变量能存储一个 boolean, byte, char, short, int,float, reference, 或者 returnAddress类型。一对局部变量能存储long或者double类型\n\t  第一个局部变量的索引为0，当一个整数小于当前本地变量数组的大小(差值在0到1之间),那这个整数才能作为这个局部变量数组的索引。\n\t  long或double类型的值占用两个连续的局部变量。java虚拟机可以不需要索引值n为偶数(索引值为偶数因为long或double占用两个连续的局部变量),因为long或double的值可以不用8字节对齐，可以将值所占空间根据大小进行压缩。\n    当调用方法时，java虚拟机使用局部变量用来传递参数。在调用方法时，以本地变量索引为0开始，通过连续的本地变量数组传递参数。在实例方法调用时，本地变量0总是用来传递对象引用(this)，其他的参数从本地变量索引为1开始，通过连续的本地变量数组传递。\n  5. 操作数栈: \n    操作数栈是一个LIFO栈(后进先出),在Java程序编译为Class文件时，就在方法表的Code属性的max stacks数据项中确定了该方法需要分配的操作数栈的容量。\n    当栈帧被创建时操作数栈是空的。java虚拟机提供指令从本地变量或字段中加载常量或者值到操作数栈中。\n    其他的虚拟机指令将从操作数栈中获取操作数，对其进行操作，并将返回的结果推入操作数栈中。操作数栈也被用来准备传递给方法的参数和接收方法结果。\n  6. 动态连接:\n    每个帧都包含对当前方法类型的运行时常量的引用，以支持方法代码的动态连接。\n    一个方法的class文件代码引用被调用的方法和被访问的本地变量需要用符号引用来进行。\n    动态连接将符号方法引用翻译成具体方法引用，根据需要加载类以解析尚未定义的符号，并将变量访问转换为与这些变量的运行时位置相关联的存储结构中的适当偏移量。\n\t  这种方法和变量的后期绑定使得方法使用的其他类中的更改不太可能破坏此代码。\n##### 本地方法栈\n  1. 本地方法栈又称为\"C栈\",它是用来支持用c/c++编写的本地方法。\n  2. 当java虚拟机使用本地方法时，就需要使用本地方法栈来将本地方法压栈。\n  3. java栈是java虚拟机的实现，不能被用来加载本地方法。\n  4. 如果本地方法被用，当每个线程被创建时本地方法栈将被分配到每个线程。\n  5. 如果本地方法栈大小被固定，则在创建本地方法栈时，可以独立选择每个本地方法栈的大小。\n  6. 如果计算出线程需要本地方法栈比被允许的还要大，会出现StackOverflowError栈溢出异常。\n  7. 如果本地方法栈能被动态扩展，但是可利用的内存不足，则会出现OutOfMemoryError内存溢出异常。\n### java内存模型\n![java内存模型](jvm内存模型.png)\n#### 程序计数器\n  1. java虚拟机支持同时执行许多线程。每个java虚拟机线程有自己的程序计数器。每个java虚拟机线程都在执行当前线程的方法。\n  2. 如果不是native方法,这个程序计数器将会存储当前被执行的java虚拟机指令的地址；如果是native方法，java虚拟机的程序计数器会未定义。\n  3. java虚拟机的程序计数器会足够的大，来存储returnAddress或者native指针。\n### 文献引用\n 1. [栈帧、局部变量表、操作数栈](https://www.cnblogs.com/minisculestep/articles/4934947.html)\n 2.  [本地方法栈](https://www.jianshu.com/p/014a57b06713)\n 3. [java内存区域及静态常量池、运行时常量池介绍](https://blog.csdn.net/qq_15037231/article/details/98373712)\n 4. [程序计数器](https://www.cnblogs.com/manayi/p/9290490.html)\n 5. [Java的堆,栈,方法区](https://blog.csdn.net/danny_idea/article/details/81137306)\n 6. [运行时数据区](https://www.cnblogs.com/chenpt/p/8953435.html)\n 7. [深入理解JVM-内存模型（jmm）和GC](https://www.jianshu.com/p/76959115d486)\n 8. [什么是Java内存模型](https://www.jianshu.com/p/bf158fbb2432)\n 9. [jvms8](https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf)\n \n","tags":["jvm内存模型"],"categories":["jvm内存模型"]},{"title":"gc回收机制","url":"%2F2019%2F12%2F31%2FJava%2Fjvm%2Fgc%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F","content":"\n## java garbage collection\n\n### 什么是garbage collection\n  1. 在c/c++中，程序员需要自己手动分配内存和释放内存，这样会让内存分配很困难。稍不注意没有回收内存，就会造成内存溢出。\n  2. 而java贴心的为程序员准备了自动回收垃圾的垃圾桶，当有对象不被需要了，gc就会识别不需要的对象，将其回收。gc回收器是一个在后台一直运行的守护线程，当jvm启动，gc跟着运行，jvm停止，gc跟着停止。\n### gc回收机制\n  1. mark(标记对象)\n\t![mark](mark.png)\n\t在堆中找到所有存活的对象，这个进程从'roots'开始，包括线程栈，静态变量，JNI代码的特殊引用以及其他的区域的存活对象将被找到。\n\t如果引用来自gc root,则对对象的引用只能阻止当前对象被垃圾回收。\n\t垃圾回收器将会标记可达的对象为存活对象(live)，标记不可达的对象为死亡对象。如果这些死亡对象(dead)仍然可达，它会导致内存泄漏。\n\t标记的工作与存活对象和引用的数量呈线性相关，与对象大小无关。将1000个10k的对象与1000个10m的对象标记所需时间是相同的。\n\t在并发标记中，所有可达的对象将标记为存活，并且这个对象图也会被改变，这会导致经典的并行标记竞赛。应用程序可能会将一个没有被发现的引用移动进已经被访问过的被标记的对象，使这个引用指向这个对象，这样会导致堆损坏。这个对象将会被垃圾回收，但是这个引用仍然会存在。\n\t以上并发标记问题可以通过'write barrier'来解决。'write barrier'会捕获可能会被标记错过的对象引用的改变，通过这个信息，标记会重新访问所有被改变的引用和跟踪新的改变。但是需要注意的是，垃圾收集器对改变很敏感，所做的工作会随着改变率的增加而增加。\n  2. sweep(清理)\n\t![sweep](sweep.png)\n\t垃圾收集器会扫描整个堆来验证死亡(dead)对象的位置和跟踪它们的位置。\n\t不像标记，sweep是与堆的大小呈线性相关，而不是存活集合的大小。如果应用程序使用一个存活对象很少的大的堆，sweep也会扫描整个堆。\n\tsweep会移除这些死亡对象，释放出内存。但是sweep只有清除，会让内存中出现很多碎片。分配内存每次是使用连续空间分配的内存，如果内存碎片很多，新的内存分配会变慢。\n  3. compact(压缩)\n\t![compact](compact.png)\n\tcompact会将存活的对象重新放入一个连续的空间中，随着对象被移动，垃圾收集器必须修理所有的在线程中的存活对象的引EW用。这个过程被称为'remapping'，这和存活对象集合的大小呈线性相关。\n\t增量压缩被用在Oracle G1 和 the Balanced Collector from IBM。这个技术假设某个内存区域比其他的更活跃，这个算法跟踪跨区域记忆集合(即哪个区域指向哪个区域).这允许垃圾收集器同一时刻只压缩单个区域，并且重新remapping潜在引用时只扫描它们指向的区域。大堆有很少的不活跃的区域，指向单个区域的区域数与堆大小呈线性相关,这种类型的压缩犯法能随着堆大小的平方而增长。\n\tcompact能将在清理死亡对象之前，将存活对象集中，这样清理死亡对象之后释放的内存是连续的，便于新的内存分配。\n  4. copy\n\t将内存划分为两块，每次只用一块。当前这一块内存用完了，就将存活对象移动到另一块，然后对当前这一块执行清理操作,这样内存释放也不会产生碎片。但是这样浪费了一半的内存空间，并且这种算法需要频繁gc。\n### gc回收算法\n  1. mark-sweep (标记-清理)\n\t先使用将死亡对象标记(mark)，然后清理对象(sweep)。\n  2. mark-compact (标记-压缩)\n\t先使用将死亡对象标记(mark),然后将存活对象压缩到一个连续的空间(compact),最后清理标记的对象。\n  3. mark-copying (复制)\n\t先将内存划分为两个区域，然后所有对象都在一个区域。标记死亡对象，将存活对象移动到另一个区域，最后清理这个区域中标记的对象。\n### gc的分代收集\n分代收集一般使用mark-compact回收算法。\n![hotsopt-gc](hotsopt-gc.png)\n  1. Young Generation(新生代)\n\t![survivor](survivor.png)\n\t这是所有新对象分配内存和老化的地方。\n\t新生代内存空间又被分为eden和survivor两个内存空间(eden:survivor = 8:2)。\n\teden(伊甸园),是新对象被创建的地方(分配内存)。\n\tsurvivor(幸存地)，其中分为大小一样的S0和S1，它们被用来替换使用。\n  2. Old Generation(老年代)\n\t老年代用于存放新生代多次回收依然存活的对象，如缓存对象。当老年代满了的时候就需要对老年代代进行回收，老年代代的垃圾回收称作Major GC。\n  3. Permanent Generation(永久代)\n\t类和方法的元数据就是存储在Permanent Generation区中的。如果类不常用，就有可能被垃圾回收。大多数JVM没有这一代。\n\n### gc分代回收过程\n首先，在eden区分配对象，survivor区的两个分区分别被标记为from和to,可以看出，已经有一次垃圾回收了。\n![1](1.png)\n当生成的对象占满新生代的空间时，此时Yong gc被称为Minor GC。这时就可以进行垃圾回收了。\n![2](2.png)\n第一次垃圾收集时，s0和s1都为空，将s0(s0为To Survivous,s1为From Survivous)作为To Survivous(存储eden中幸存的对象)。 \n对死亡对象进行标记，将存活对象移动到s0中。\n在一次垃圾收集后，eden中幸存的对象会被移动到s0中,s0和s1互换标签。\n![3](3.png)\n然后，当eden区域又一次满了，就开始第二次垃圾收集。\n这次垃圾收集波及到eden和survivor区，这两个区中的死亡对象会被标记。\n将第二次垃圾收集eden中幸存的对象和s0中幸存的对象(s0中幸存的对象再一次被垃圾回收)迁移到s1中,所有幸存对象年龄增加1岁(第一次幸存的对象年龄为1)，如果还有剩余的幸存对象s1放不下，将s1中剩余的对象放入Old Generation区中。\n然后将eden和s0清空，s0和s1再互换标签。\n![4](4.png)\n再进行一次垃圾回收，s0又成为新的To Survivous。\n又将eden和s1中幸存的对象移动到s0中，幸存对象年龄再增加1岁。\n![5](5.png)\n再经过一次垃圾回收后，s1中的有些幸存对象年龄已经很老了，需要移动到老年代中去。\n![6](6.png)\n随着minor GC持续进行，幸存对象年龄慢慢变老，更多的幸存对象被移动到老年代中去。\n![7](7.png)\n最终，对老年代的对象进行压缩。等老年代满了之后，触发Major GC\n![8](8.png)\n### hotspot四种垃圾回收器\n  1. Serial Garbage Collector(串行垃圾收集器)\n\t所有垃圾收集事件都在一个线程中串行进行。当这个gc运行时，会让应用程序线程阻塞，等垃圾回收完后才运行，对于多线程应用程序来说最好不要用它。\n\t对于那些对时间要求不高，又在客户端计算机上运行的应用程序来说确是首选垃圾回收器。它也可以用来理解垃圾收集器的工作原理。\n\t使用方法：\n```Java\njava -XX:+UseSerialGC -jar test.java\n```\n  2. Parallel Garbage Collector(并行垃圾收集器)\n\tMinor GC时使用多线程进行，Major GC和老年代压缩时使用单线程。Parallel的比较老的版本在Major GC和老年代压缩时使用多线程。\n\t这是JVM默认的GC，但是当执行GC也会阻塞其他应用程序线程。我们可以自定义垃圾收集器的最大线程数，暂停时间，吞吐量和占用空间(堆大小)。\n\t使用方法:\n```Java\n-XX:UseParallelGC  : 使用的垃圾收集器\n-XX:ParallelGCThreads=  : 垃圾收集器的最大线程数量\n-XX:MaxGCPauseMills=  : 垃圾收集器最大暂停时间\n-XX:GCTimeRatio=  : 垃圾收集器吞吐量\n-Xms : 堆大小\njava -XX:+UseParallelGC -XX:ParallelGCThreads= -XX:MaxGCPauseMills= -XX:GCTimeRatio= -Xms -jar test.java\n```\n  3. CMS Garbage Collector(Concurrent Mark Sweep)\n\t并行标记清理，与Parallel一样，在Minor GC时使用多线程，Major GC也是使用多线程。但是CMS是与应用程序并发运行，尽量减少垃圾收集时应用程序被停止的状况。它不使用mark-compact回收算法，而是使用mark-sweep回收算法。\n\t上面两个垃圾收集器开始GC时都会暂停应用程序线程，但是CMS就会让垃圾收集器与应用程序并行和并发。\n\t但是也会出现一些问题，执行垃圾收集器时，垃圾收集器的响应速度会比较慢，但是应用程序的响应也不会停。\n\t注意事项：当这个并发过程正在运行时，如果显示的调用GC(System.gc()),将会返回Concurrent Mode Failure / Interruption\n\t如果CMS垃圾回收器运行的时间花费了总时间的98%以上，而堆只有2%以下被回收，这将会抛出OutOfMemoryError异常。增加-XX:-UseGCOverheadLimit选项这个错误将被禁止。\n\t使用方法：\n```Java\n-XX:UseParNewGC  : 使用CMS垃圾收集器\n-XX:UserGCOverheadLimit : 取消垃圾回收器回收时间限制\njava -XX:+UseParNewGC -XX:UserGCOverheadLimit -jar test.java\n```\n  4. G1 Garbage Collector(Garbage First)\n\t这是CMS的扩展,它被设计用于大内存空间的运行在多处理器机器上的应用程序。在JDK7.4以后加入的。\n\t当需要性能高效时，它将被用来替换CMS垃圾收集器。\n\tG1 collector将堆分为大小相等的堆区的集合，每一个堆区拥有连续的虚拟内存范围。\n\t当执行垃圾回收时，G1显示了一个并发的全局标记阶段，以确定整个堆中对象的活动性。在标记完成之后，G1会知道哪些堆区大部分是空的，它会首先收集这些区域，通常会产生大量空闲空间。\n\t使用方法：\n```Java\njava -XX:+UseG1GC test.java\n```\n### 文献引用\n  1. [java7 gc](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)\n  2. [understand gc](https://www.azul.com/files/Understanding_Java_Garbage_Collection_v41.pdf)\n  3. [garbage-collection-java](https://www.geeksforgeeks.org/garbage-collection-java/)\n  4. [What is Java Garbage Collection](https://stackify.com/what-is-java-garbage-collection/)\n  5. [JVM Garbage Collectors](https://www.baeldung.com/jvm-garbage-collectors)\n  6. [深入探究 JVM | 初探 GC 算法](https://www.sczyh30.com/posts/Java/jvm-gc-method-types/)\n  7. [深入理解JVM的内存结构及GC机制](https://juejin.im/post/5a15be736fb9a044fc4464d6)\n  8. [How Garbage Collector works in Java](https://www.hackerearth.com/zh/practice/notes/how-garbage-collection-works-in-java/)\n  9. [Types of Java Garbage Collectors](https://javapapers.com/java/types-of-java-garbage-collectors/)\n  10. [JVM performance optimization, Part 3: Garbage collection](https://www.javaworld.com/article/2078645/jvm-performance-optimization-part-3-garbage-collection.html)\n  11. [Tuning Garbage Collection with the 5.0 JVM](https://www.oracle.com/technetwork/java/gc-tuning-5-138395.html)\n  12. [JVM GC原理](https://www.cnblogs.com/yy3b2007com/p/10975870.html)\n  13. [JVM内存结构--新生代及新生代里的两个Survivor区](https://blog.csdn.net/u012799221/article/details/73180509)\n\n","tags":["gc回收机制"],"categories":["gc回收机制"]},{"title":"redis源码阅读-util(类型转换工具)","url":"%2F2019%2F12%2F26%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FC%2Fredis%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-util-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%2F","content":"## redis源码阅读-util(类型转换工具)\n### util介绍\nutil中主要放置的是一些常用的类型转换函数，比如字符串转换为整型，也包含模式匹配，时间时区获取等工具函数。\n### util.h\n```C\n/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef __REDIS_UTIL_H\n#define __REDIS_UTIL_H\n\n#include <stdint.h>\n#include \"sds.h\"\n\n/* The maximum number of characters needed to represent a long double\n * as a string (long double has a huge range).\n * This should be the size of the buffer given to ld2string */\n// 一个long double作为一个字符串\n#define MAX_LONG_DOUBLE_CHARS 5*1024\n\n// 模式匹配，确定了需要匹配的字符串的长度\nint stringmatchlen(const char *p, int plen, const char *s, int slen, int nocase);\n// 包装上面那个函数\nint stringmatch(const char *p, const char *s, int nocase);\n// 测试模式匹配用的\nint stringmatchlen_fuzz_test(void);\n// 将1Gb转换为字节\nlong long memtoll(const char *p, int *err);\n//获取十进制数的位数\nuint32_t digits10(uint64_t v);\n// 无符号值的位数\nuint32_t sdigits10(int64_t v);\n// long long 转string\nint ll2string(char *s, size_t len, long long value);\n// string转long long\nint string2ll(const char *s, size_t slen, long long *value);\n// string 转long\nint string2l(const char *s, size_t slen, long *value);\n// string 转long double\nint string2ld(const char *s, size_t slen, long double *dp);\n// double转string\nint d2string(char *buf, size_t len, double value);\n// long double 转string\nint ld2string(char *buf, size_t len, long double value, int humanfriendly);\n// 获取绝对路径\nsds getAbsolutePath(char *filename);\n// 获取时区\nunsigned long getTimeZone(void);\n// 获取路径的第一个目录\nint pathIsBaseName(char *path);\n\n#ifdef REDIS_TEST\nint utilTest(int argc, char **argv);\n#endif\n\n#endif\n```\n### util.c\n```C\n/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"fmacros.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <float.h>\n#include <stdint.h>\n#include <errno.h>\n#include <time.h>\n\n#include \"util.h\"\n#include \"sha1.h\" /*提供加密算法原型*/\n\n/* Glob-style pattern matching. */\n/* 模式匹配\n\tconst char *pattern : 模式字符串 \n\tint patternLen : 模式字符串长度\n    const char *string : 需要匹配的字符串\n\tint stringLen : 需要匹配的字符串的长度\n\tint nocase :\n */\nint stringmatchlen(const char *pattern, int patternLen,\n        const char *string, int stringLen, int nocase)\n{\n\t// 当两个长度都不为0时循环\n    while(patternLen && stringLen) {\n\t\t// pattern是一个指针，其中游标位置表示其当前起始位置，而pattern[0]表示当前游标指向的位置的内容\n        switch(pattern[0]) {\n        case '*': // 表示匹配0个或多个，这里直接匹配所有\n            while (pattern[1] == '*') { // 如果第二个字符还是\"*\",就直接匹配\n                pattern++;\n                patternLen--;\n            }\n            if (patternLen == 1) // 如果模式匹配字符串长度为1，就表名只有\"*\"一个字符，表示已经匹配，直接返回1,表示匹配\n                return 1; /* match */\n            while(stringLen) { // 如果default块匹配成功,就直接返回匹配成功\n                if (stringmatchlen(pattern+1, patternLen-1,\n                            string, stringLen, nocase))\n                    return 1; /* match */\n                // 如果匹配失败，就再向后匹配\n                string++;\n                stringLen--;\n            }\n            return 0; /* no match */\n            break;\n        case '?': // 匹配一个或0个\n            if (stringLen == 0)\n                return 0; /* no match */\n            string++;\n            stringLen--;\n            break;\n        case '[': // 匹配[],用来匹配一个字符，这个字符在这个区间之内\n        {\n            int not, match;\n\n            pattern++; // 先将\"[\"忽略\n            patternLen--; // 需要匹配的长度减1\n            not = pattern[0] == '^'; // 如果第一个字符是'^'表示取反\n            if (not) {\n                pattern++;\n                patternLen--;\n            }\n            match = 0;\n            while(1) {\n                // 如果找到转义字符，并且后面需要的长度大于2，也就是\\\\%\n                if (pattern[0] == '\\\\' && patternLen >= 2) {\n                    pattern++; // 先让指针跳过'\\\\'\n                    patternLen--;\n                    if (pattern[0] == string[0]) // 如果转义后的字符等于字符串中的字符\n                        match = 1;\n                } else if (pattern[0] == ']') { // 遇到闭合符，跳出循环\n                    break;\n                } else if (patternLen == 0) { // 如果模式匹配字符串需要匹配的长度为0了\n                    pattern--;\n                    patternLen++;\n                    break;\n                } else if (pattern[1] == '-' && patternLen >= 3) { // 当前项的后一个字符是'-',并且长度大于等于3，相当于1-9这样\n                    int start = pattern[0]; // 第一个就是1，是开始字符\n                    int end = pattern[2]; // 第三个就是9，是结束字符\n                    int c = string[0]; // 需要匹配的字符\n                    if (start > end) { // 如果开始值大于结尾值,就让start=end\n                        int t = start;\n                        start = end;\n                        end = t;\n                    }\n                    if (nocase) { // 如果大小写不敏感,就将字符都转小写\n                        start = tolower(start);\n                        end = tolower(end);\n                        c = tolower(c);\n                    }\n                    pattern += 2; // 然后模式匹配位置向后偏移，到范围区间之后\n                    patternLen -= 2; // 长度同样减去\n                    if (c >= start && c <= end) // 判断字符是否在区间之内\n                        match = 1;\n                } else { // 如果不是特殊字符,就一个字符一个字符的比较\n                    if (!nocase) { // 大小写敏感\n                        if (pattern[0] == string[0])\n                            match = 1;\n                    } else { // 大小写不敏感\n                        if (tolower((int)pattern[0]) == tolower((int)string[0]))\n                            match = 1;\n                    }\n                }\n                pattern++; // 跳过']'\n                patternLen--;\n            }\n            if (not) // 如果not='^'\n                match = !match; //给匹配结果取反\n            if (!match) // \n                return 0; /* no match */\n            string++; // 最终需要匹配的字符串向后面移动\n            stringLen--;\n            break;\n        }\n        case '\\\\': // 如果是转义字符\n            if (patternLen >= 2) {\n                pattern++;\n                patternLen--;\n            }\n            /* fall through */\n        default: // 这里只有\"*\"使用了递归，因此这里主要是用来处理\"*\"后面的字符串\n\t\t\t// 这里用来匹配中\"*\"后面的模式匹配的第一个字符匹配的需要匹配的第一个字符在哪，如果没有匹配到就直接\n            if (!nocase) { // 是否大小写敏感\n                if (pattern[0] != string[0])\n                    return 0; /* no match */\n            } else {\n                if (tolower((int)pattern[0]) != tolower((int)string[0]))\n                    return 0; /* no match */\n            }\n            string++;\n            stringLen--;\n            break;\n        }\n        pattern++; //到达模式匹配结尾\n        patternLen--;\n        if (stringLen == 0) {\n            while(*pattern == '*') {\n                pattern++;\n                patternLen--;\n            }\n            break;\n        }\n    }\n    // 如果模式匹配长度和字符串长度都为0，表示都匹配成功\n    if (patternLen == 0 && stringLen == 0)\n        return 1;\n    return 0;\n}\n\n// 将上面的模式匹配函数包装了一下，只是将长度变量隐藏了，给了一个指定值\nint stringmatch(const char *pattern, const char *string, int nocase) {\n    return stringmatchlen(pattern,strlen(pattern),string,strlen(string),nocase);\n}\n\n/* Fuzz stringmatchlen() trying to crash it with bad input. */\nint stringmatchlen_fuzz_test(void) {\n    char str[32];\n    char pat[32];\n    int cycles = 10000000;\n    int total_matches = 0;\n    while(cycles--) {\n        int strlen = rand() % sizeof(str);\n        int patlen = rand() % sizeof(pat);\n        for (int j = 0; j < strlen; j++) str[j] = rand() % 128;\n        for (int j = 0; j < patlen; j++) pat[j] = rand() % 128;\n        total_matches += stringmatchlen(pat, patlen, str, strlen, 0);\n    }\n    return total_matches;\n}\n\n/* Convert a string representing an amount of memory into the number of\n * bytes, so for instance memtoll(\"1Gb\") will return 1073741824 that is\n * (1024*1024*1024).\n *\n * On parsing error, if *err is not NULL, it's set to 1, otherwise it's\n * set to 0. On error the function return value is 0, regardless of the\n * fact 'err' is NULL or not. */\n// 将\"1GB\"转换为字节数,如果解析错误返回0,err=1\nlong long memtoll(const char *p, int *err) {\n    const char *u;\n    char buf[128];\n    long mul; /* unit multiplier */\n    long long val;\n    unsigned int digits;\n\n    if (err) *err = 0;\n\n    /* Search the first non digit character. */\n    u = p;\n\t// 如果是\"-\",表示负数,游标向后移\n    if (*u == '-') u++;\n\t// 如果是数字，游标向后移\n    while(*u && isdigit(*u)) u++;\n\t// 搜索第一个不是数字的字符,都大小写不敏感\n\t// 如果没有字符，就默认该数字是字节\n    if (*u == '\\0' || !strcasecmp(u,\"b\")) {\n        mul = 1;\n\t// 如果是k，就转为1000b\n    } else if (!strcasecmp(u,\"k\")) {\n        mul = 1000;\n\t// 如果是kb,就转为1024b\n    } else if (!strcasecmp(u,\"kb\")) {\n        mul = 1024;\n\t// 如果是m,转为1000*1000b\n    } else if (!strcasecmp(u,\"m\")) {\n        mul = 1000*1000;\n    // 如果是mb,转为1024*1024b\n\t} else if (!strcasecmp(u,\"mb\")) {\n        mul = 1024*1024;\n\t// 如果是g,转为1000L*1000*1000b\n    } else if (!strcasecmp(u,\"g\")) {\n        mul = 1000L*1000*1000;\n    // 如果是gb,转为1024L*1024*1024b\n\t} else if (!strcasecmp(u,\"gb\")) {\n        mul = 1024L*1024*1024;\n    } else { // 否则就是其他字符，表示输入的是错误的字符，返回错误码\n        if (err) *err = 1;\n        return 0;\n    }\n\n    /* Copy the digits into a buffer, we'll use strtoll() to convert\n     * the digit (without the unit) into a number. */\n    digits = u-p; // u的游标移动到第一个字符处，p是起始位置，这样就能得到数字所占内存偏移量\n    if (digits >= sizeof(buf)) { // 如果字符所占内存大小大于缓存区，也输出错误码\n        if (err) *err = 1;\n        return 0;\n    }\n    memcpy(buf,p,digits); // 将从开始位置开始到数字所占内存的长度结束位置的内存区域复制给buf\n    buf[digits] = '\\0';//将其作为一个字符串，以空字符结尾\n\n    char *endptr;\n    errno = 0;\n    val = strtoll(buf,&endptr,10); // 将字符串转换为long long\n    if ((val == 0 && errno == EINVAL) || *endptr != '\\0') { // 如果转换出的值有问题\n        if (err) *err = 1;\n        return 0;\n    }\n    return val*mul; // 转换处的数字*字节数，就是总的内存字节数\n}\n\n/* Return the number of digits of 'v' when converted to string in radix 10.\n * See ll2string() for more information. */\n// 返回数值v的数字数量,就是表示数值是几位数,这是无符号值，也就是正数\nuint32_t digits10(uint64_t v) {\n    if (v < 10) return 1; //个位数\n    if (v < 100) return 2; // 十位数\n    if (v < 1000) return 3; // 百位数\n    if (v < 1000000000000UL) {\n        if (v < 100000000UL) {\n            if (v < 1000000) {\n                if (v < 10000) return 4;\n                return 5 + (v >= 100000);\n            }\n            return 7 + (v >= 10000000UL);\n        }\n        if (v < 10000000000UL) {\n            return 9 + (v >= 1000000000UL);\n        }\n        return 11 + (v >= 100000000000UL);\n    }\n    return 12 + digits10(v / 1000000000000UL);\n}\n\n/* Like digits10() but for signed values. */\n// 计算无符号值是几位数\nuint32_t sdigits10(int64_t v) {\n    if (v < 0) {\n        /* Abs value of LLONG_MIN requires special handling. */\n        uint64_t uv = (v != LLONG_MIN) ?\n                      (uint64_t)-v : ((uint64_t) LLONG_MAX)+1;\n        return digits10(uv)+1; /* +1 for the minus. */\n    } else {\n        return digits10(v);\n    }\n}\n\n/* Convert a long long into a string. Returns the number of\n * characters needed to represent the number.\n * If the buffer is not big enough to store the string, 0 is returned.\n *\n * Based on the following article (that apparently does not provide a\n * novel approach but only publicizes an already used technique):\n *\n * https://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920\n *\n * Modified in order to handle signed integers since the original code was\n * designed for unsigned integers. */\n// long long转string,返回的是字符数量,将输入的数值svalue转换为字符串，保存到dst中\nint ll2string(char *dst, size_t dstlen, long long svalue) {\n    static const char digits[201] =\n        \"0001020304050607080910111213141516171819\"\n        \"2021222324252627282930313233343536373839\"\n        \"4041424344454647484950515253545556575859\"\n        \"6061626364656667686970717273747576777879\"\n        \"8081828384858687888990919293949596979899\";\n    int negative;\n    unsigned long long value;\n\n    /* The main loop works with 64bit unsigned integers for simplicity, so\n     * we convert the number here and remember if it is negative. */\n\t // 如果输入的是负数，就将其转换为正数\n    if (svalue < 0) {\n\t\t// 如果负数在long的范围之内\n        if (svalue != LLONG_MIN) {\n            value = -svalue;\n        } else { // 如果没有在long范围之内，就是long long的最大值+1，因为value是unsigned long long,其最大值大于long long的最大值，所以在范围之内\n            value = ((unsigned long long) LLONG_MAX)+1;\n        }\n        negative = 1;\n    } else {\n        value = svalue;\n        negative = 0;\n    }\n\n    /* Check length. */\n    uint32_t const length = digits10(value)+negative; // 检查数字长度，negative表示符号(正号或者负号)\n    if (length >= dstlen) return 0;// 如果需要转换值的字符长度比目标长度还大，就表明转换失败\n\n    /* Null term. */\n    uint32_t next = length;\n    dst[next] = '\\0'; // 给字符串设置结尾空字符\n    next--; // 减一个长度\n    while (value >= 100) { // 乘以2是因为一个二位数是由两个数字组成，在digits数组中，想定位对应数字，需要乘以2\n        int const i = (value % 100) * 2;\n        value /= 100;\n\t\t// 获得两位数字,放入数组中;这个数组是由末尾向前填充，因为value值也是从数值的后面位向前获取\n        dst[next] = digits[i + 1];\n        dst[next - 1] = digits[i];\n        next -= 2;\n    }\n\n    /* Handle last 1-2 digits. */\n    if (value < 10) { // 如果得到的值是自然数，直接补0转换为字符串;如果不是自然数，也就是两位数，不需要补0，和上面一样\n        dst[next] = '0' + (uint32_t) value;\n    } else {\n        int i = (uint32_t) value * 2;\n        dst[next] = digits[i + 1];\n        dst[next - 1] = digits[i];\n    }\n\n    /* Add sign. */\n    if (negative) dst[0] = '-'; // 如果是负数，就将负号加入最前面\n    return length; // 这里就是总长度\n}\n\n/* Convert a string into a long long. Returns 1 if the string could be parsed\n * into a (non-overflowing) long long, 0 otherwise. The value will be set to\n * the parsed value when appropriate.\n *\n * Note that this function demands that the string strictly represents\n * a long long: no spaces or other characters before or after the string\n * representing the number are accepted, nor zeroes at the start if not\n * for the string \"0\" representing the zero number.\n *\n * Because of its strictness, it is safe to use this function to check if\n * you can convert a string into a long long, and obtain back the string\n * from the number without any loss in the string representation. */\n// 与上面的函数反过来，string转long long，输入字符串s转long long，保存到value中\nint string2ll(const char *s, size_t slen, long long *value) {\n    const char *p = s;\n    size_t plen = 0;\n    int negative = 0;\n    unsigned long long v;\n\n    /* A zero length string is not a valid number. */\n    if (plen == slen) // 如果字符串长度为0\n        return 0;\n\n    /* Special case: first and only digit is 0. */\n    if (slen == 1 && p[0] == '0') { // 如果字符串长度为1，并且字符串是\"0\"\n        if (value != NULL) *value = 0;\n        return 1;\n    }\n\n    /* Handle negative numbers: just set a flag and continue like if it\n     * was a positive number. Later convert into negative. */\n    if (p[0] == '-') { // 如果字符串的第一位是\"-\",表示负数\n        negative = 1;\n        p++; plen++;\n\n        /* Abort on only a negative sign. */\n        if (plen == slen) // 如果仅有一个负号\n            return 0;\n    }\n\n    /* First digit should be 1-9, otherwise the string should just be 0. */\n    if (p[0] >= '1' && p[0] <= '9') { // 如果第一个字符是1到9\n        v = p[0]-'0'; // 那么就转为数字\n        p++; plen++;\n    } else {\n        return 0;\n    }\n\n    /* Parse all the other digits, checking for overflow at every step. */\n\t// 解析其他所有字符串，检查是否溢出\n    while (plen < slen && p[0] >= '0' && p[0] <= '9') {\n        if (v > (ULLONG_MAX / 10)) /* Overflow. */\n            return 0;\n        v *= 10; // 正常情况就*10\n\n        if (v > (ULLONG_MAX - (p[0]-'0'))) /* Overflow. */\n            return 0;\n        v += p[0]-'0'; // 将个位数补齐\n\n        p++; plen++; // 一位一位的进行\n    }\n\n    /* Return if not all bytes were used. */\n    if (plen < slen)\n        return 0;\n\n    /* Convert to negative if needed, and do the final overflow check when\n     * converting from unsigned long long to long long. */\n    if (negative) { // 如果有负号，就让其成为负数\n        if (v > ((unsigned long long)(-(LLONG_MIN+1))+1)) /* Overflow. */\n            return 0;\n        if (value != NULL) *value = -v;\n    } else {\n        if (v > LLONG_MAX) /* Overflow. */\n            return 0;\n        if (value != NULL) *value = v;\n    }\n    return 1; // 转换成功返回1\n}\n\n/* Convert a string into a long. Returns 1 if the string could be parsed into a\n * (non-overflowing) long, 0 otherwise. The value will be set to the parsed\n * value when appropriate. */\n// string转换为long , 基本上是调用string2ll,只是转换后的值强制转换为long\nint string2l(const char *s, size_t slen, long *lval) {\n    long long llval;\n\n    if (!string2ll(s,slen,&llval))\n        return 0;\n\n    if (llval < LONG_MIN || llval > LONG_MAX)\n        return 0;\n\n    *lval = (long)llval;\n    return 1;\n}\n\n/* Convert a string into a double. Returns 1 if the string could be parsed\n * into a (non-overflowing) double, 0 otherwise. The value will be set to\n * the parsed value when appropriate.\n *\n * Note that this function demands that the string strictly represents\n * a double: no spaces or other characters before or after the string\n * representing the number are accepted. */\n // string 转换为 long double,主要使用stdlib库函数strtold\nint string2ld(const char *s, size_t slen, long double *dp) {\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    long double value;\n    char *eptr;\n\n    if (slen >= sizeof(buf)) return 0;\n    memcpy(buf,s,slen);\n    buf[slen] = '\\0';\n\n    errno = 0;\n    value = strtold(buf, &eptr); // 调用stdlib中的库函数\n\t// 判断是否合法\n    if (isspace(buf[0]) || eptr[0] != '\\0' ||\n        (errno == ERANGE &&\n            (value == HUGE_VAL || value == -HUGE_VAL || value == 0)) ||\n        errno == EINVAL ||\n        isnan(value))\n        return 0;\n\n    if (dp) *dp = value;\n    return 1;\n}\n\n/* Convert a double to a string representation. Returns the number of bytes\n * required. The representation should always be parsable by strtod(3).\n * This function does not support human-friendly formatting like ld2string\n * does. It is intended mainly to be used inside t_zset.c when writing scores\n * into a ziplist representing a sorted set. */\n// double转换为string,通过调用ll2string进行转换\nint d2string(char *buf, size_t len, double value) {\n    if (isnan(value)) { // 判断value是否是一个数值\n        len = snprintf(buf,len,\"nan\");\n    } else if (isinf(value)) { // 判断value是否是一个无理数\n        if (value < 0)\n            len = snprintf(buf,len,\"-inf\");\n        else\n            len = snprintf(buf,len,\"inf\");\n    } else if (value == 0) { // 如果value为0\n        /* See: http://en.wikipedia.org/wiki/Signed_zero, \"Comparisons\". */\n        if (1.0/value < 0)\n            len = snprintf(buf,len,\"-0\");\n        else\n            len = snprintf(buf,len,\"0\");\n    } else {\n#if (DBL_MANT_DIG >= 52) && (LLONG_MAX == 0x7fffffffffffffffLL)\n        /* Check if the float is in a safe range to be casted into a\n         * long long. We are assuming that long long is 64 bit here.\n         * Also we are assuming that there are no implementations around where\n         * double has precision < 52 bit.\n         *\n         * Under this assumptions we test if a double is inside an interval\n         * where casting to long long is safe. Then using two castings we\n         * make sure the decimal part is zero. If all this is true we use\n         * integer printing function that is much faster. */\n        double min = -4503599627370495; /* (2^52)-1 */\n        double max = 4503599627370496; /* -(2^52) */\n        if (value > min && value < max && value == ((double)((long long)value)))\n            len = ll2string(buf,len,(long long)value);\n        else\n#endif\n            len = snprintf(buf,len,\"%.17g\",value);\n    }\n\n    return len;\n}\n\n/* Convert a long double into a string. If humanfriendly is non-zero\n * it does not use exponential format and trims trailing zeroes at the end,\n * however this results in loss of precision. Otherwise exp format is used\n * and the output of snprintf() is not modified.\n *\n * The function returns the length of the string or zero if there was not\n * enough buffer room to store it. */\n // long double转换为string \nint ld2string(char *buf, size_t len, long double value, int humanfriendly) {\n    size_t l;\n\n    if (isinf(value)) { //如果value为无理数\n        /* Libc in odd systems (Hi Solaris!) will format infinite in a\n         * different way, so better to handle it in an explicit way. */\n        if (len < 5) return 0; /* No room. 5 is \"-inf\\0\" */ // 先判断目标字符串长度是否能容纳\n        if (value > 0) {\n            memcpy(buf,\"inf\",3);\n            l = 3;\n        } else {\n            memcpy(buf,\"-inf\",4);\n            l = 4;\n        }\n    } else if (humanfriendly) { // 如果需要转换为人类可读\n        /* We use 17 digits precision since with 128 bit floats that precision\n         * after rounding is able to represent most small decimal numbers in a\n         * way that is \"non surprising\" for the user (that is, most small\n         * decimal numbers will be represented in a way that when converted\n         * back into a string are exactly the same as what the user typed.) */\n        l = snprintf(buf,len,\"%.17Lf\", value); // 将value通过格式化转换为人类可读样式，再存入buf中，返回其长度\n        if (l+1 > len) return 0; /* No room. */ // 如果转换后的长度大于目标字符串buf的长度\n        /* Now remove trailing zeroes after the '.' */\n        if (strchr(buf,'.') != NULL) {// 如果'.'字符在buf中存在，表示它是一个浮点数\n            char *p = buf+l-1; // 指针p指向最末尾\n            while(*p == '0') { // 判断第一个不为0的数，然后就在将后面的0都清除 1.2000000 = 1.2\n                p--;\n                l--;\n            }\n            if (*p == '.') l--; // 如果直接到'.'都没有不为0的数，表示这个数为整数，就把'.'一起去掉\n        }\n    } else {\n        l = snprintf(buf,len,\"%.17Lg\", value); // 直接将数值打印出来，不考虑是否对人类友好\n        if (l+1 > len) return 0; /* No room. */\n    }\n    buf[l] = '\\0'; // 空字符结尾\n    return l; // 返回字符串长度\n}\n\n/* Get random bytes, attempts to get an initial seed from /dev/urandom and\n * the uses a one way hash function in counter mode to generate a random\n * stream. However if /dev/urandom is not available, a weaker seed is used.\n *\n * This function is not thread safe, since the state is global. */\n // 获取随机的字节\nvoid getRandomBytes(unsigned char *p, size_t len) {\n    /* Global state. */\n    static int seed_initialized = 0; // 被初始化的种子\n    static unsigned char seed[20]; /* The SHA1 seed, from /dev/urandom. */ // 从/dev/urandom中获取随机种子\n    static uint64_t counter = 0; /* The counter we hash with the seed. */ // 用种子计算hash值\n\n    if (!seed_initialized) {\n        /* Initialize a seed and use SHA1 in counter mode, where we hash\n         * the same seed with a progressive counter. For the goals of this\n         * function we just need non-colliding strings, there are no\n         * cryptographic security needs. */\n        FILE *fp = fopen(\"/dev/urandom\",\"r\"); // 打开/dev/urandom文件\n        if (fp == NULL || fread(seed,sizeof(seed),1,fp) != 1) {\n            /* Revert to a weaker seed, and in this case reseed again\n             * at every call.*/\n\t\t\t // sizeof(seed)获取的随机数数量\n            for (unsigned int j = 0; j < sizeof(seed); j++) {\n                struct timeval tv;\n                gettimeofday(&tv,NULL); // 获取天\n                pid_t pid = getpid(); // 获取pid号\n                seed[j] = tv.tv_sec ^ tv.tv_usec ^ pid ^ (long)fp;//秒^微秒^pid号^文件描述符号用来生成种子\n            }\n        } else { // 没有获取到随机数\n            seed_initialized = 1;\n        }\n        if (fp) fclose(fp);\n    }\n\n    while(len) {\n        unsigned char digest[20];\n        SHA1_CTX ctx;\n        unsigned int copylen = len > 20 ? 20 : len; // 让copylen长度在20以内\n\n\t\t// 使用sha1算法生成hash值digest\n        SHA1Init(&ctx); // 初始化sha1\n        SHA1Update(&ctx, seed, sizeof(seed)); \n        SHA1Update(&ctx, (unsigned char*)&counter,sizeof(counter));\n        SHA1Final(digest, &ctx);\n        counter++;\n\n        memcpy(p,digest,copylen);// 将值放到p处\n        len -= copylen;\n        p += copylen;\n    }\n}\n\n/* Generate the Redis \"Run ID\", a SHA1-sized random number that identifies a\n * given execution of Redis, so that if you are talking with an instance\n * having run_id == A, and you reconnect and it has run_id == B, you can be\n * sure that it is either a different instance or it was restarted. */\n// 获取随机的16进制字符\nvoid getRandomHexChars(char *p, size_t len) {\n    char *charset = \"0123456789abcdef\";\n    size_t j;\n\n    getRandomBytes((unsigned char*)p,len);\n    for (j = 0; j < len; j++) p[j] = charset[p[j] & 0x0F];\n}\n\n/* Given the filename, return the absolute path as an SDS string, or NULL\n * if it fails for some reason. Note that \"filename\" may be an absolute path\n * already, this will be detected and handled correctly.\n *\n * The function does not try to normalize everything, but only the obvious\n * case of one or more \"../\" appearing at the start of \"filename\"\n * relative path. */\n// 获取文件的绝对路径\nsds getAbsolutePath(char *filename) {\n    char cwd[1024];\n    sds abspath;\n    sds relpath = sdsnew(filename);\n\n    relpath = sdstrim(relpath,\" \\r\\n\\t\"); // 将多余字符去除\n    if (relpath[0] == '/') return relpath; /* Path is already absolute. */ // 如果第一个字符就是'/',表示就是绝对路径\n\n    /* If path is relative, join cwd and relative path. */\n    if (getcwd(cwd,sizeof(cwd)) == NULL) { // 获取绝对路径\n        sdsfree(relpath); // 将relpath这个中间变量释放\n        return NULL;\n    }\n    abspath = sdsnew(cwd); // 新创建一个sds字符串\n    if (sdslen(abspath) && abspath[sdslen(abspath)-1] != '/') // 如果是这样/home/myhome，就转换为/home/myhome/\n        abspath = sdscat(abspath,\"/\");\n\n    /* At this point we have the current path always ending with \"/\", and\n     * the trimmed relative path. Try to normalize the obvious case of\n     * trailing ../ elements at the start of the path.\n     *\n     * For every \"../\" we find in the filename, we remove it and also remove\n     * the last element of the cwd, unless the current cwd is \"/\". */\n    while (sdslen(relpath) >= 3 &&\n           relpath[0] == '.' && relpath[1] == '.' && relpath[2] == '/')\n    {\n        sdsrange(relpath,3,-1);\n        if (sdslen(abspath) > 1) {\n            char *p = abspath + sdslen(abspath)-2;\n            int trimlen = 1;\n\n            while(*p != '/') {\n                p--;\n                trimlen++;\n            }\n            sdsrange(abspath,0,-(trimlen+1));\n        }\n    }\n\n    /* Finally glue the two parts together. */\n    abspath = sdscatsds(abspath,relpath);\n    sdsfree(relpath);\n    return abspath;\n}\n\n/*\n * Gets the proper timezone in a more portable fashion\n * i.e timezone variables are linux specific.\n */\n// 获取时区\nunsigned long getTimeZone(void) {\n#ifdef __linux__\n    return timezone;\n#else\n    struct timeval tv;\n    struct timezone tz;\n\n    gettimeofday(&tv, &tz);\n\n    return tz.tz_minuteswest * 60UL;\n#endif\n}\n\n/* Return true if the specified path is just a file basename without any\n * relative or absolute path. This function just checks that no / or \\\n * character exists inside the specified path, that's enough in the\n * environments where Redis runs. */\n // 判断路径的根目录名\nint pathIsBaseName(char *path) {\n    return strchr(path,'/') == NULL && strchr(path,'\\\\') == NULL;\n}\n\n#ifdef REDIS_TEST\n#include <assert.h>\n\nstatic void test_string2ll(void) {\n    char buf[32];\n    long long v;\n\n    /* May not start with +. */\n    strcpy(buf,\"+1\");\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    /* Leading space. */\n    strcpy(buf,\" 1\");\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    /* Trailing space. */\n    strcpy(buf,\"1 \");\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    /* May not start with 0. */\n    strcpy(buf,\"01\");\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    strcpy(buf,\"-1\");\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == -1);\n\n    strcpy(buf,\"0\");\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == 0);\n\n    strcpy(buf,\"1\");\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == 1);\n\n    strcpy(buf,\"99\");\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == 99);\n\n    strcpy(buf,\"-99\");\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == -99);\n\n    strcpy(buf,\"-9223372036854775808\");\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == LLONG_MIN);\n\n    strcpy(buf,\"-9223372036854775809\"); /* overflow */\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    strcpy(buf,\"9223372036854775807\");\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == LLONG_MAX);\n\n    strcpy(buf,\"9223372036854775808\"); /* overflow */\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n}\n\nstatic void test_string2l(void) {\n    char buf[32];\n    long v;\n\n    /* May not start with +. */\n    strcpy(buf,\"+1\");\n    assert(string2l(buf,strlen(buf),&v) == 0);\n\n    /* May not start with 0. */\n    strcpy(buf,\"01\");\n    assert(string2l(buf,strlen(buf),&v) == 0);\n\n    strcpy(buf,\"-1\");\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == -1);\n\n    strcpy(buf,\"0\");\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == 0);\n\n    strcpy(buf,\"1\");\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == 1);\n\n    strcpy(buf,\"99\");\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == 99);\n\n    strcpy(buf,\"-99\");\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == -99);\n\n#if LONG_MAX != LLONG_MAX\n    strcpy(buf,\"-2147483648\");\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == LONG_MIN);\n\n    strcpy(buf,\"-2147483649\"); /* overflow */\n    assert(string2l(buf,strlen(buf),&v) == 0);\n\n    strcpy(buf,\"2147483647\");\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == LONG_MAX);\n\n    strcpy(buf,\"2147483648\"); /* overflow */\n    assert(string2l(buf,strlen(buf),&v) == 0);\n#endif\n}\n\nstatic void test_ll2string(void) {\n    char buf[32];\n    long long v;\n    int sz;\n\n    v = 0;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 1);\n    assert(!strcmp(buf, \"0\"));\n\n    v = -1;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 2);\n    assert(!strcmp(buf, \"-1\"));\n\n    v = 99;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 2);\n    assert(!strcmp(buf, \"99\"));\n\n    v = -99;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 3);\n    assert(!strcmp(buf, \"-99\"));\n\n    v = -2147483648;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 11);\n    assert(!strcmp(buf, \"-2147483648\"));\n\n    v = LLONG_MIN;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 20);\n    assert(!strcmp(buf, \"-9223372036854775808\"));\n\n    v = LLONG_MAX;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 19);\n    assert(!strcmp(buf, \"9223372036854775807\"));\n}\n\n#define UNUSED(x) (void)(x)\nint utilTest(int argc, char **argv) {\n    UNUSED(argc);\n    UNUSED(argv);\n\n    test_string2ll();\n    test_string2l();\n    test_ll2string();\n    return 0;\n}\n#endif\n```\n","tags":["源码阅读"],"categories":["工具类"]},{"title":"redis源码阅读-zipmap(压缩字典)","url":"%2F2019%2F12%2F26%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FC%2Fredis%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-zipmap-%E5%8E%8B%E7%BC%A9%E5%AD%97%E5%85%B8%2F","content":"\n## redis源码阅读-zipmap(压缩字典)\n\n### zipmap介绍\nzipmap,是redis定义的压缩字典，是用来保存键值对的数据结构。它保证hash表刚创建以及元素较少时，用更少的内存来存储，同时对查询效率没太大影响。\n### zipmap.h\n```C\n/* String -> String Map data structure optimized for size.\n *\n * See zipmap.c for more info.\n *\n * --------------------------------------------------------------------------\n *\n * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef _ZIPMAP_H\n#define _ZIPMAP_H\n\n// 创建一个压缩字典结构\nunsigned char *zipmapNew(void);\n// 将键值对设置进压缩字典\nunsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update);\n// 通过key删除压缩字典中的节点，并通过deleted标记是否被删除\nunsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted);\n// 重置游标到第一个节点的起始位置\nunsigned char *zipmapRewind(unsigned char *zm);\n// 迭代压缩字典，只迭代一次\nunsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen);\n// 通过key来获取value和vlen,返回0或1判断是否成功\nint zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen);\n// 返回0或1判断是否存在key\nint zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen);\n// 获取压缩字典中节点数\nunsigned int zipmapLen(unsigned char *zm);\n// 获取压缩字典总长度\nsize_t zipmapBlobLen(unsigned char *zm);\n\n// 以下两个函数都是用来测试的\nvoid zipmapRepr(unsigned char *p);\n\n#ifdef REDIS_TEST\nint zipmapTest(int argc, char *argv[]);\n#endif\n\n#endif\n```\n### zipmap.c\n```C\n/* String -> String Map data structure optimized for size.\n * This file implements a data structure mapping strings to other strings\n * implementing an O(n) lookup data structure designed to be very memory\n * efficient.\n *\n * The Redis Hash type uses this data structure for hashes composed of a small\n * number of elements, to switch to a hash table once a given number of\n * elements is reached.\n *\n * Given that many times Redis Hashes are used to represent objects composed\n * of few fields, this is a very big win in terms of used memory.\n *\n * --------------------------------------------------------------------------\n *\n * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* Memory layout of a zipmap, for the map \"foo\" => \"bar\", \"hello\" => \"world\":\n *\n * <zmlen><len>\"foo\"<len><free>\"bar\"<len>\"hello\"<len><free>\"world\"\n *\n * <zmlen> is 1 byte length that holds the current size of the zipmap.\n * When the zipmap length is greater than or equal to 254, this value\n * is not used and the zipmap needs to be traversed to find out the length.\n *\n * <len> is the length of the following string (key or value).\n * <len> lengths are encoded in a single value or in a 5 bytes value.\n * If the first byte value (as an unsigned 8 bit value) is between 0 and\n * 253, it's a single-byte length. If it is 254 then a four bytes unsigned\n * integer follows (in the host byte ordering). A value of 255 is used to\n * signal the end of the hash.\n *\n * <free> is the number of free unused bytes after the string, resulting\n * from modification of values associated to a key. For instance if \"foo\"\n * is set to \"bar\", and later \"foo\" will be set to \"hi\", it will have a\n * free byte to use if the value will enlarge again later, or even in\n * order to add a key/value pair if it fits.\n *\n * <free> is always an unsigned 8 bit number, because if after an\n * update operation there are more than a few free bytes, the zipmap will be\n * reallocated to make sure it is as small as possible.\n *\n * The most compact representation of the above two elements hash is actually:\n *\n * \"\\x02\\x03foo\\x03\\x00bar\\x05hello\\x05\\x00world\\xff\"\n *\n * Note that because keys and values are prefixed length \"objects\",\n * the lookup will take O(N) where N is the number of elements\n * in the zipmap and *not* the number of bytes needed to represent the zipmap.\n * This lowers the constant times considerably.\n */\n\n/**\n\t压缩字典结构:<zmlen><len>\"foo\"<len><free>\"bar\"<len>\"hello\"<len><free>\"world\"\n\tzmlen表示压缩字典的节点数，zmlen占1个字节，最大值254,当zmlen的节点数小于254，就用zmlen表示压缩字典节点数，如果zmlen大于254，zmlen作用失效，要知道节点数，需要遍历整个压缩字典\n\tlen表示key或者value的长度，所占字节数；当key或者value的长度小于254，len就只需要1个字节用来存储key或者value的长度；如果key或者value的长度大于等于254，就需要扩展为5个字节来表示长度\n\tfree在value数据的前面，一般用在通过key对value进行缩减，会出现剩余的空闲空间(比如\"foo\" -> \"bar\" 缩减为 \"foo\" -> \"b\",这时就会剩余2个字节),free的大小不能超过4个字节。free一般只需要8位，因为更新操作很多时候都只更新很少一部分\n\n\t上面的字典结构可以用以下表示：\n\t\\x02表示压缩字典节点数为2\n\t\\x03表示元素长度为3字节\n\t\\xff表示结束标志\n\t\"\\x02\\x03foo\\x03\\x00bar\\x05hello\\x05\\x00world\\xff\"\n */\n\n#include <stdio.h>\n#include <string.h>\n#include \"zmalloc.h\"\n#include \"endianconv.h\"\n\n#define ZIPMAP_BIGLEN 254 // 压缩字典最大长度在254之内，压缩列表head位能记录压缩字典长度,如果大于254，则不能再记录压缩字典长度(如果想计算需要遍历整个压缩字典)\n#define ZIPMAP_END 255 // 压缩列表的结尾，占一个8位，是压缩的结束标志\n\n/* The following defines the max value for the <free> field described in the\n * comments above, that is, the max number of trailing bytes in a value. */\n#define ZIPMAP_VALUE_MAX_FREE 4 // <free>字段最大字节数\n\n/* The following macro returns the number of bytes needed to encode the length\n * for the integer value _l, that is, 1 byte for lengths < ZIPMAP_BIGLEN and\n * 5 bytes for all the other lengths. */\n// 当输入的压缩字典长度时，如果压缩字典长度在ZIPMAP_BIGLEN之内，就只需要占用1字节，否则占用5字节\n#define ZIPMAP_LEN_BYTES(_l) (((_l) < ZIPMAP_BIGLEN) ? 1 : sizeof(unsigned int)+1)\n\n/* Create a new empty zipmap. */\n// 创建一个空的压缩字典\nunsigned char *zipmapNew(void) {\n    unsigned char *zm = zmalloc(2);// 先为压缩字典分配2个字节的内存，因为空的压缩字典只有头部的记录长度(记录长度默认是1字节，最大5字节)和尾部的结束标志(1字节的\\xff)\n\n    zm[0] = 0; /* Length */ // 就是头部记录长度的1字节位\n    zm[1] = ZIPMAP_END; // 尾部1字节的结束标志\n    return zm; // 压缩字典起始就是一个字符串\n}\n\n/* Decode the encoded length pointed by 'p' */\n// 从节点p中解码出编码长度\nstatic unsigned int zipmapDecodeLength(unsigned char *p) {\n    unsigned int len = *p; // p表示压缩字典中的每个节点的第一个区域，也就是1字节或者5字节的记录长度区，*p就是这个区的内容，也就是长度\n\n    if (len < ZIPMAP_BIGLEN) return len; // 如果长度小于254，就让其作为节点的长度\n\t// 下面就是len大于254，也就是其所占5个字节\n    memcpy(&len,p+1,sizeof(unsigned int)); // 为len再分配4个字节的内存,让其拥有5个字节的内存，有1个字节的内存刚开始就分配了\n    memrev32ifbe(&len); // 将其地址进行小端字节序转换\n    return len; // 获得地址里的内容\n}\n\n/* Encode the length 'l' writing it in 'p'. If p is NULL it just returns\n * the amount of bytes required to encode such a length. */\n // 将长度len编码进入p中(p为每个节点的第一个内存区，也就是1字节或者5字节的记录长度区);如果p为空，就返回编码len需要的字节数\nstatic unsigned int zipmapEncodeLength(unsigned char *p, unsigned int len) {\n    if (p == NULL) {\n        return ZIPMAP_LEN_BYTES(len); // 直接返回len需要编码的字节数\n    } else { // 不为空\n        if (len < ZIPMAP_BIGLEN) { // 判断len小于254\n            p[0] = len; // 只需要给len分配1个字节，也就是指针p指向的第0位\n            return 1; // 返回1字节\n        } else { // 如果len大于254\n            p[0] = ZIPMAP_BIGLEN; // 先将254给第1个字节的内存\n            memcpy(p+1,&len,sizeof(len)); // 然后再给它分配4个字节的内存\n            memrev32ifbe(p+1); // 转换为小端字节序\n            return 1+sizeof(len); // 返回5个字节\n        }\n    }\n}\n\n/* Search for a matching key, returning a pointer to the entry inside the\n * zipmap. Returns NULL if the key is not found.\n *\n * If NULL is returned, and totlen is not NULL, it is set to the entire\n * size of the zimap, so that the calling function will be able to\n * reallocate the original zipmap to make room for more entries. */\n // 通过key来搜索，返回在压缩字典中的节点，如果没有找到Key,返回NULL\n /*\n\tzm 表示压缩字典\n\tkey 表示压缩字典中一个节点中的key\n\tklen key的长度\n\ttotlen 压缩字典的总长度，当key没有查找到，就直接返回压缩字典的总长度\n  */\nstatic unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen) {\n    unsigned char *p = zm+1, *k = NULL; // p从压缩字典的第二位开始，也就是表示节点的位开始\n    unsigned int l,llen;\n\n    while(*p != ZIPMAP_END) { // 如果指针p指向的位置不在压缩字典的结尾标志，就表示还没有循环完\n        unsigned char free;\n\n        /* Match or skip the key */\n        l = zipmapDecodeLength(p); // 从p(节点的len字段)中解码出长度\n        llen = zipmapEncodeLength(NULL,l); // 然后获取长度所占字节数\n\t\t// 如果需要搜索的key不为null,并且匹配的k还没有，遍历到的节点的长度等于需要匹配节点的长度，并且指针P当前游标+llen位置的地址(len所在地址)与key地址匹配\n\t\t// 这旧表示匹配到相同的节点\n        if (key != NULL && k == NULL && l == klen && !memcmp(p+llen,key,l)) {\n            /* Only return when the user doesn't care\n             * for the total length of the zipmap. */\n            if (totlen != NULL) { // 如果总长不为空\n                k = p; // 让k指向指针p当前游标位置处\n            } else {\n                return p;\n            }\n        }\n        p += llen+l; // 指针跳过len和key所占区域，直接到value区\n        /* Skip the value as well */\n        l = zipmapDecodeLength(p); // 解码出value长度\n        p += zipmapEncodeLength(NULL,l); // 让指针p跳过value的长度所占区，直接到value的数据区\n        free = p[0]; // free区，一般1个字节\n        p += l+1+free; /* +1 to skip the free byte */ // 然后跳过free区\n    }\n\t// 这里是已经遍历完整个压缩字典，\n    if (totlen != NULL) *totlen = (unsigned int)(p-zm)+1; // p-zm回到起始点 (p-zm)+1表示压缩字典的长度区，获取压缩字典长度\n    return k; // 返回搜素到的节点\n}\n// 一个节点被需要的长度\n// klen表示key长度，vlen表示value长度\nstatic unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen) {\n    unsigned int l;\n\n    l = klen+vlen+3; // klen和vlen是key和value数据占的长度，3表示free以及两个数据区记录长度位\n    if (klen >= ZIPMAP_BIGLEN) l += 4; // 当klen大于等于254，就为长度扩容4字节\n    if (vlen >= ZIPMAP_BIGLEN) l += 4; // 与上面一样\n    return l; // 返回衣蛾节点需要的占用的长度\n}\n\n/* Return the total amount used by a key (encoded length + payload) */\n// 返回一个key所占用的总长度(len+key)\nstatic unsigned int zipmapRawKeyLength(unsigned char *p) {\n    unsigned int l = zipmapDecodeLength(p); // key长度\n    return zipmapEncodeLength(NULL,l) + l; //key长度+记录key长度的位的长度\n}\n\n/* Return the total amount used by a value\n * (encoded length + single byte free count + payload) */\n // 返回一个value所占用的总长度(len++free+key)\nstatic unsigned int zipmapRawValueLength(unsigned char *p) {\n    unsigned int l = zipmapDecodeLength(p); // value数据的长度\n    unsigned int used;\n\n    used = zipmapEncodeLength(NULL,l); // 编码len所占字节数\n    used += p[used] + 1 + l; // len的长度+free的长度+value的长度\n    return used; // 得到value需要的总长度\n}\n\n/* If 'p' points to a key, this function returns the total amount of\n * bytes used to store this entry (entry = key + associated value + trailing\n * free space if any). */\n // 返回节点所需总长度\nstatic unsigned int zipmapRawEntryLength(unsigned char *p) {\n    unsigned int l = zipmapRawKeyLength(p); // 先获得key的长度\n    return l + zipmapRawValueLength(p+l); // key的长度+value的长度\n}\n\n// inline 内联函数 调整压缩列表长度\nstatic inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len) {\n    zm = zrealloc(zm, len); //为zm扩展分配len长度的内存\n    zm[len-1] = ZIPMAP_END; // 重新设置结尾标志\n    return zm;\n}\n\n/* Set key to value, creating the key if it does not already exist.\n * If 'update' is not NULL, *update is set to 1 if the key was\n * already preset, otherwise to 0. */\n// 如果key不存在，就将key和value设置到压缩字典中。如果update不为NULL,如果需要输入的key已经被预设(也就是已经被找到)，则设为1\nunsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update) {\n    unsigned int zmlen, offset; // 压缩字典长度和偏移量\n    unsigned int freelen, reqlen = zipmapRequiredLength(klen,vlen); // 获取需要的key和value占用的长度\n    unsigned int empty, vempty;\n    unsigned char *p;\n\n    freelen = reqlen; // 让空闲长度等于请求长度\n    if (update) *update = 0; // 如果update不为NULL或者0，则让update为0\n    p = zipmapLookupRaw(zm,key,klen,&zmlen); // 判断压缩字典中有没有需要设置的key和value\n    if (p == NULL) { // 如果key没有被找到\n        /* Key not found: enlarge */\n        zm = zipmapResize(zm, zmlen+reqlen); // 为压缩字典扩容，使其能够容纳新增的键值对\n        p = zm+zmlen-1; // 让指针p指向新增键值对的起始地址(略过存储长度的地址,直接到键的起始地址)\n        zmlen = zmlen+reqlen; // 总长度加上新增长度\n\n        /* Increase zipmap length (this is an insert) */\n        if (zm[0] < ZIPMAP_BIGLEN) zm[0]++; // 如果压缩字典长度在ZIPMAP_BIGLEN之内，长度就加\n    } else {\n        /* Key found. Is there enough space for the new value? */\n        /* Compute the total length: */\n\t\t// 如果key在压缩字典中内找到，就将update置1,并且更新key的value值\n        if (update) *update = 1;\n        freelen = zipmapRawEntryLength(p); // 获取压缩字典中查找到的节点总长度\n        if (freelen < reqlen) { // 如果节点总长度小于需要新增的长度\n            /* Store the offset of this key within the current zipmap, so\n             * it can be resized. Then, move the tail backwards so this\n             * pair fits at the current position. */\n            offset = p-zm; // 获取压缩字典起始地址到查找到的键值对的起始地址之间的偏移量\n            zm = zipmapResize(zm, zmlen-freelen+reqlen); // 为压缩字典分配需要新增的多余的长度，zm回到压缩字典的起始地址\n            p = zm+offset; // 扩容之后，再将指针p指向键值对的起始地址\n\n            /* The +1 in the number of bytes to be moved is caused by the\n             * end-of-zipmap byte. Note: the *original* zmlen is used. */\n\t\t\t// +1是压缩字典的结尾字符,zmlen-(offset+freelen+1)就是用来获取原压缩字典的当前节点的后面所有节点的长度,将后面所有节点所占的内存区域重新移动到更新后的节点的内存区域后面\n            memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+1));\n            zmlen = zmlen-freelen+reqlen; // 总长度就是减去原来的节点长度，然后加上新增的节点长度\n            freelen = reqlen;\n        }\n    }\n\n    /* We now have a suitable block where the key/value entry can\n     * be written. If there is too much free space, move the tail\n     * of the zipmap a few bytes to the front and shrink the zipmap,\n     * as we want zipmaps to be very space efficient. */\n\t// 上面讨论了压缩字典中没有key的情况和压缩字典中有key的情况；但是在压缩字典中有key的情况下，没有讨论如果节点总长度大于需要请求的长度，这时更新的value小于当前的value长度\n    empty = freelen-reqlen; // 而free字段只预留了4个字节的空闲空间\n    if (empty >= ZIPMAP_VALUE_MAX_FREE) { // 如果更新value后产生的空闲空间大于4字节\n        /* First, move the tail <empty> bytes to the front, then resize\n         * the zipmap to be <empty> bytes smaller. */\n\t\t // 那么后面的节点就要向前移动，将多余的free字节消除\n        offset = p-zm; // 这里获取当前位置与起始位置之间的偏移量\n        memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+1)); // 将后面所有内存区域(除去结尾符)移动到reqlen后面(这里reqlen比freelen小，遮阳将reqlen长度后面的字节覆盖了)\n        zmlen -= empty; // 整个压缩字典减去空闲出来的长度\n        zm = zipmapResize(zm, zmlen); // 改变压缩字典的长度\n        p = zm+offset; // p指针重新指向当前位置\n        vempty = 0; // value值前面的free长度变为0\n    } else {\n        vempty = empty; // 否则的话，空闲长度在4字节之内，这就不需要将空闲长度缩小了，empty的长度就是free字段的长度\n    }\n\n    /* Just write the key + value and we are done. */\n    /* Key: */\n    p += zipmapEncodeLength(p,klen); // 将klen编码写入len字段中,p指针向后偏移，略过len\n    memcpy(p,key,klen); // 将输入的key放入len后面的key的位置\n    p += klen; // p指针向后偏移\n    /* Value: */\n\t// 值的操作与key的操作一样\n    p += zipmapEncodeLength(p,vlen);\n    *p++ = vempty;\n    memcpy(p,val,vlen);\n    return zm; // 然后返回插入节点后的压缩字典\n}\n\n/* Remove the specified key. If 'deleted' is not NULL the pointed integer is\n * set to 0 if the key was not found, to 1 if it was found and deleted. */\n// 通过key删除节点;如果key没有被找到，就被设置为0，找到就被设置为1\nunsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted) {\n    unsigned int zmlen, freelen;\n    unsigned char *p = zipmapLookupRaw(zm,key,klen,&zmlen); // 通过key从压缩字典中找到key，并返回\n    if (p) { // 如果key存在,就可以执行删除\n        freelen = zipmapRawEntryLength(p); // 获取key所在节点的总长度\n        memmove(p, p+freelen, zmlen-((p-zm)+freelen+1)); // 将节点后的所有内存(除了结尾符)向前移动删除节点的长度的位置，覆盖需要删除的节点\n        zm = zipmapResize(zm, zmlen-freelen); // 将需要删除的节点的长度释放\n\n        /* Decrease zipmap length */\n        if (zm[0] < ZIPMAP_BIGLEN) zm[0]--; // 判断压缩字典总长度是否在限制之内，如果在限制之内就可以把其看做是长度，可以进行加减\n\n        if (deleted) *deleted = 1; // 将标志位置1，表示找到需要删除的节点\n    } else { // 如果key不存在\n        if (deleted) *deleted = 0; // 将标志位置0，表示没有找到需要删除的节点\n    }\n    return zm; // 返回删除节点后的压缩字典\n}\n\n/* Call before iterating through elements via zipmapNext() */\n// 在迭代压缩字典之前，将指针游标重置到第一个节点的起始地址\nunsigned char *zipmapRewind(unsigned char *zm) {\n    return zm+1;\n}\n\n/* This function is used to iterate through all the zipmap elements.\n * In the first call the first argument is the pointer to the zipmap + 1.\n * In the next calls what zipmapNext returns is used as first argument.\n * Example:\n *\n * unsigned char *i = zipmapRewind(my_zipmap);\n * while((i = zipmapNext(i,&key,&klen,&value,&vlen)) != NULL) {\n *     printf(\"%d bytes key at $p\\n\", klen, key);\n *     printf(\"%d bytes value at $p\\n\", vlen, value);\n * }\n */\n/*\n\t用来迭代压缩字典中的节点(这个函数一次只能迭代一次)，所以起始地址需要忽略存储压缩字典总长度的第一个字节(所以需要先调用zipmapRewind将指针重置)\n\t*zm表示需要迭代的压缩字典\n\t**key用来存储迭代的key\n\t**value用来存储迭代的value\n */\nunsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen) {\n    if (zm[0] == ZIPMAP_END) return NULL; // 如果压缩字典为空\n    if (key) {\n        *key = zm; // 将指针移到到第一个节点的key的起始位置\n        *klen = zipmapDecodeLength(zm); // 解码key的长度\n        *key += ZIPMAP_LEN_BYTES(*klen); //获取key长度所占字符数,现在key指针就指向key数据的起始位置\n    }\n    zm += zipmapRawKeyLength(zm); // 将zm指针移动到key数据区结束位置\n    if (value) {\n        *value = zm+1; // 现在value指针指向value的起始位置\n        *vlen = zipmapDecodeLength(zm); // 解码出value的长度\n        *value += ZIPMAP_LEN_BYTES(*vlen); // 获取value长度所占字符数,现在value指针就指向value数据的起始位置\n    }\n    zm += zipmapRawValueLength(zm); // 将zm指针移动到value数据区结束位置\n\n\t// 现在key和value两个变量都存储了遍历的节点的键值对\n    return zm; // 返回压缩字典，其游标在下一个节点的起始位置\n}\n\n/* Search a key and retrieve the pointer and len of the associated value.\n * If the key is found the function returns 1, otherwise 0. */\n// 通过已知的key获取key对应的value数据区的起始地址，并存储到value变量中，value的值就存储到vlen中\nint zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen) {\n    unsigned char *p;\n\n\t// 通过key查找压缩字典中的节点，并返回给p\n    if ((p = zipmapLookupRaw(zm,key,klen,NULL)) == NULL) return 0;\n    p += zipmapRawKeyLength(p); // 如果存在则将节点的key的总长度，并将游标移向总长度之后\n    *vlen = zipmapDecodeLength(p); // 现在游标在value的len字段出，解码出len的长度，存储到vlen中\n    *value = p + ZIPMAP_LEN_BYTES(*vlen) + 1; // 将value的数据区的起始地址给value\n    return 1; // 找到就返回1\n}\n\n/* Return 1 if the key exists, otherwise 0 is returned. */\n// 判断key是否存在,调用的是zipmapLookupRaw函数\nint zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen) {\n    return zipmapLookupRaw(zm,key,klen,NULL) != NULL;\n}\n\n/* Return the number of entries inside a zipmap */\n// 遍历压缩字典，获得压缩字典中节点数\nunsigned int zipmapLen(unsigned char *zm) {\n    unsigned int len = 0;\n    if (zm[0] < ZIPMAP_BIGLEN) { // 表示压缩字典的节点数小于254，压缩字典的第一个字节能表示节点数\n        len = zm[0];\n    } else { // 否则需要遍历\n        unsigned char *p = zipmapRewind(zm); // 将指针重置到第一个节点的起始地址\n        while((p = zipmapNext(p,NULL,NULL,NULL,NULL)) != NULL) len++; // 循环调用zipmapNext,遍历压缩字典，获得节点数\n\n        /* Re-store length if small enough */\n\t\t// 如果遍历节点后，发现节点数还是小于254，也可以让压缩字典的第一个字典表示节点数，只是重新遍历了一次压缩字典\n        if (len < ZIPMAP_BIGLEN) zm[0] = len;\n    }\n    return len;\n}\n\n/* Return the raw size in bytes of a zipmap, so that we can serialize\n * the zipmap on disk (or everywhere is needed) just writing the returned\n * amount of bytes of the C array starting at the zipmap pointer. */\n// 获取压缩字典的总长度,用于序列化\nsize_t zipmapBlobLen(unsigned char *zm) {\n    unsigned int totlen;\n    zipmapLookupRaw(zm,NULL,0,&totlen);\n    return totlen;\n}\n\n#ifdef REDIS_TEST\nstatic void zipmapRepr(unsigned char *p) {\n    unsigned int l;\n\n    printf(\"{status %u}\",*p++);\n    while(1) {\n        if (p[0] == ZIPMAP_END) {\n            printf(\"{end}\");\n            break;\n        } else {\n            unsigned char e;\n\n            l = zipmapDecodeLength(p);\n            printf(\"{key %u}\",l);\n            p += zipmapEncodeLength(NULL,l);\n            if (l != 0 && fwrite(p,l,1,stdout) == 0) perror(\"fwrite\");\n            p += l;\n\n            l = zipmapDecodeLength(p);\n            printf(\"{value %u}\",l);\n            p += zipmapEncodeLength(NULL,l);\n            e = *p++;\n            if (l != 0 && fwrite(p,l,1,stdout) == 0) perror(\"fwrite\");\n            p += l+e;\n            if (e) {\n                printf(\"[\");\n                while(e--) printf(\".\");\n                printf(\"]\");\n            }\n        }\n    }\n    printf(\"\\n\");\n}\n\n#define UNUSED(x) (void)(x)\nint zipmapTest(int argc, char *argv[]) {\n    unsigned char *zm;\n\n    UNUSED(argc);\n    UNUSED(argv);\n\n    zm = zipmapNew();\n\n    zm = zipmapSet(zm,(unsigned char*) \"name\",4, (unsigned char*) \"foo\",3,NULL);\n    zm = zipmapSet(zm,(unsigned char*) \"surname\",7, (unsigned char*) \"foo\",3,NULL);\n    zm = zipmapSet(zm,(unsigned char*) \"age\",3, (unsigned char*) \"foo\",3,NULL);\n    zipmapRepr(zm);\n\n    zm = zipmapSet(zm,(unsigned char*) \"hello\",5, (unsigned char*) \"world!\",6,NULL);\n    zm = zipmapSet(zm,(unsigned char*) \"foo\",3, (unsigned char*) \"bar\",3,NULL);\n    zm = zipmapSet(zm,(unsigned char*) \"foo\",3, (unsigned char*) \"!\",1,NULL);\n    zipmapRepr(zm);\n    zm = zipmapSet(zm,(unsigned char*) \"foo\",3, (unsigned char*) \"12345\",5,NULL);\n    zipmapRepr(zm);\n    zm = zipmapSet(zm,(unsigned char*) \"new\",3, (unsigned char*) \"xx\",2,NULL);\n    zm = zipmapSet(zm,(unsigned char*) \"noval\",5, (unsigned char*) \"\",0,NULL);\n    zipmapRepr(zm);\n    zm = zipmapDel(zm,(unsigned char*) \"new\",3,NULL);\n    zipmapRepr(zm);\n\n    printf(\"\\nLook up large key:\\n\");\n    {\n        unsigned char buf[512];\n        unsigned char *value;\n        unsigned int vlen, i;\n        for (i = 0; i < 512; i++) buf[i] = 'a';\n\n        zm = zipmapSet(zm,buf,512,(unsigned char*) \"long\",4,NULL);\n        if (zipmapGet(zm,buf,512,&value,&vlen)) {\n            printf(\"  <long key> is associated to the %d bytes value: %.*s\\n\",\n                vlen, vlen, value);\n        }\n    }\n\n    printf(\"\\nPerform a direct lookup:\\n\");\n    {\n        unsigned char *value;\n        unsigned int vlen;\n\n        if (zipmapGet(zm,(unsigned char*) \"foo\",3,&value,&vlen)) {\n            printf(\"  foo is associated to the %d bytes value: %.*s\\n\",\n                vlen, vlen, value);\n        }\n    }\n    printf(\"\\nIterate through elements:\\n\");\n    {\n        unsigned char *i = zipmapRewind(zm);\n        unsigned char *key, *value;\n        unsigned int klen, vlen;\n\n        while((i = zipmapNext(i,&key,&klen,&value,&vlen)) != NULL) {\n            printf(\"  %d:%.*s => %d:%.*s\\n\", klen, klen, key, vlen, vlen, value);\n        }\n    }\n    return 0;\n}\n#endif\n```\n","tags":["源码阅读"],"categories":["数据结构"]},{"title":"redis源码阅读-endianconv(大小端字节序)","url":"%2F2019%2F12%2F22%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FC%2Fredis%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-endianconv-%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F%2F","content":"\n## redis源码阅读-endianconv(大小端字节序)\n### endianconv主要功能\nendianconv主要功能就是用来将转换字节序的。\n#### 什么是字节序?\n计算机硬件有两种存储数据的方式：**大端字节序**和**小端字节序**。大端字节序就是高位字节在前，低位字节在后;而小端字节序就是低位字节在前，高位字节在后。\n我们的计算机电路是先处理低位字节，然后再处理高位字节。如果采用**小端字节序**，其字节排序与计算机处理顺序一样，这样处理效率就很高。而采用**大端字节序**，其字节排序与计算机相反的，这样处理效率就低的多。\n大端字节序是人类读写数值的方法，主要是人来看，面向的是使用者;而小端字节序主要是计算机使用，面向的是计算机。\n这两种存储方法的使用场景不一样，在追求效率的情况下，就要迁就计算机，计算机内部处理都是使用小端字节序。而面向人的网络传输和文件存储就是使用大端字节序。\n\n### endianconv.h\n```C\n/* See endianconv.c top comments for more information\n *\n * ----------------------------------------------------------------------------\n *\n * Copyright (c) 2011-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef __ENDIANCONV_H\n#define __ENDIANCONV_H\n\n#include \"config.h\"\n#include <stdint.h>\n\nvoid memrev16(void *p);\nvoid memrev32(void *p);\nvoid memrev64(void *p);\nuint16_t intrev16(uint16_t v);\nuint32_t intrev32(uint32_t v);\nuint64_t intrev64(uint64_t v);\n\n/* variants of the function doing the actual conversion only if the target\n * host is big endian */\n// 如果字节序是小端字节序，就不需要重新排序\n#if (BYTE_ORDER == LITTLE_ENDIAN)\n#define memrev16ifbe(p) ((void)(0))\n#define memrev32ifbe(p) ((void)(0))\n#define memrev64ifbe(p) ((void)(0))\n#define intrev16ifbe(v) (v)\n#define intrev32ifbe(v) (v)\n#define intrev64ifbe(v) (v)\n#else // 否则就是大端字节序，就需要重新排序\n#define memrev16ifbe(p) memrev16(p)\n#define memrev32ifbe(p) memrev32(p)\n#define memrev64ifbe(p) memrev64(p)\n#define intrev16ifbe(v) intrev16(v)\n#define intrev32ifbe(v) intrev32(v)\n#define intrev64ifbe(v) intrev64(v)\n#endif\n\n/* The functions htonu64() and ntohu64() convert the specified value to\n * network byte ordering and back. In big endian systems they are no-ops. */\n// 如果字节序是大端字节序，就将值转换为网络字节序(网络字节序就是大端的)\n#if (BYTE_ORDER == BIG_ENDIAN) \n#define htonu64(v) (v)\n#define ntohu64(v) (v)\n#else\n#define htonu64(v) intrev64(v)\n#define ntohu64(v) intrev64(v)\n#endif\n\n#ifdef REDIS_TEST\nint endianconvTest(int argc, char *argv[]);\n#endif\n\n#endif\n```\n### endianconv.c\n```C\n/* endinconv.c -- Endian conversions utilities.\n *\n * This functions are never called directly, but always using the macros\n * defined into endianconv.h, this way we define everything is a non-operation\n * if the arch is already little endian.\n *\n * Redis tries to encode everything as little endian (but a few things that need\n * to be backward compatible are still in big endian) because most of the\n * production environments are little endian, and we have a lot of conversions\n * in a few places because ziplists, intsets, zipmaps, need to be endian-neutral\n * even in memory, since they are serialied on RDB files directly with a single\n * write(2) without other additional steps.\n *\n * ----------------------------------------------------------------------------\n *\n * Copyright (c) 2011-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n#include <stdint.h>\n\n/* Toggle the 16 bit unsigned integer pointed by *p from little endian to\n * big endian */\n// 将16位转换为小端字节序 0000 1111 --> 1111 0000\nvoid memrev16(void *p) {\n    unsigned char *x = p, t;\n\n    t = x[0];\n    x[0] = x[1];\n    x[1] = t;\n}\n\n/* Toggle the 32 bit unsigned integer pointed by *p from little endian to\n * big endian */\n// 将32位转换为小端字节序 0000 0101 1100 1111 -> 1111 1100 0101 0000\nvoid memrev32(void *p) {\n    unsigned char *x = p, t;\n\n    t = x[0];\n    x[0] = x[3];\n    x[3] = t;\n    t = x[1];\n    x[1] = x[2];\n    x[2] = t;\n}\n\n/* Toggle the 64 bit unsigned integer pointed by *p from little endian to\n * big endian */\n// 将64位转换小端字节序 0000 0100 0110 0111 1000 1001 1011 1111 -> 1111 1011 1001 1000 0111 0110 0100 0000\nvoid memrev64(void *p) {\n    unsigned char *x = p, t;\n\n    t = x[0];\n    x[0] = x[7];\n    x[7] = t;\n    t = x[1];\n    x[1] = x[6];\n    x[6] = t;\n    t = x[2];\n    x[2] = x[5];\n    x[5] = t;\n    t = x[3];\n    x[3] = x[4];\n    x[4] = t;\n}\n\n// 将16位地址转换为小端字节序，返回内容\nuint16_t intrev16(uint16_t v) {\n    memrev16(&v);\n    return v;\n}\n// 将32位地址转换为小端字节序，返回内容\nuint32_t intrev32(uint32_t v) {\n    memrev32(&v);\n    return v;\n}\n// 将64位地址转换为小端字节序，返回内容\nuint64_t intrev64(uint64_t v) {\n    memrev64(&v);\n    return v;\n}\n\n#ifdef REDIS_TEST\n#include <stdio.h>\n\n#define UNUSED(x) (void)(x)\nint endianconvTest(int argc, char *argv[]) {\n    char buf[32];\n\n    UNUSED(argc);\n    UNUSED(argv);\n\n    sprintf(buf,\"ciaoroma\");\n    memrev16(buf);\n    printf(\"%s\\n\", buf);\n\n    sprintf(buf,\"ciaoroma\");\n    memrev32(buf);\n    printf(\"%s\\n\", buf);\n\n    sprintf(buf,\"ciaoroma\");\n    memrev64(buf);\n    printf(\"%s\\n\", buf);\n\n    return 0;\n}\n#endif\n```\n\n### 文献整理\n 1. [理解大小端字节序](https://www.cnblogs.com/gremount/p/8830707.html) ","tags":["源码阅读"],"categories":["工具类"]},{"title":"redis源码阅读-intset(整数集合)","url":"%2F2019%2F12%2F22%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FC%2Fredis%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-intset-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%2F","content":"\n## redis源码阅读-intset(整数集合)\n\n### intset\nintset是redis实现的整数集合，是redis集合键底层实现之一。主要用在数据量比较小，并且是整数的地方。\nintset能保存int16_t,int32_t,int64_t类型的整数，并且可以保存其中不会出现重复数据，而且其数据的大小是从小到大有序排列(这个有序排列我还没想明白是怎么实现的)。\nintset的结构如下：\n```C\ntypedef struct intset {\n    uint32_t encoding; // intset集合真正的类型,有uint16_t,uint32_t,uint64_t三种类型。\n    uint32_t length; // 长度\n    int8_t contents[]; // 内容数组,存储整数集合，其声明类型没有意义\n} intset;\n```\n其中的encoding是用来判断intset是什么类型的，而contents是用来存储intset集合元素的，默认声明是int8_t，但是没有意义。\nintset有个特性就是**升级**,当加入intset的值的编码比当前Intset的编码大时，intset会自动升级为加入的值一样的编码。例如：当前intset是int8_t类型，有4个元素，总共占8\\*3=24位的内存空间，现在加入一个int32_t类型的65535,intset这个集合升级为占32\\*4=128位的内存空间，而**升级后不能降级**。\n### intset.h\n```C\n/*\n * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef __INTSET_H\n#define __INTSET_H\n#include <stdint.h>\n// 定义整数集合结构\ntypedef struct intset {\n    uint32_t encoding; // intset集合真正的类型,有uint16_t,uint32_t,uint64_t三种类型。\n    uint32_t length; // 长度\n    int8_t contents[]; // 内容数组,存储整数集合，其声明类型没有意义\n} intset;\n\n// 创建一个整数集合\nintset *intsetNew(void);\n// 将整数值存入整数集合\nintset *intsetAdd(intset *is, int64_t value, uint8_t *success);\n// 将整数值从整数集合移除\nintset *intsetRemove(intset *is, int64_t value, int *success);\n// 通过指定的整数从整数集合中查找\nuint8_t intsetFind(intset *is, int64_t value);\nint64_t intsetRandom(intset *is);\nuint8_t intsetGet(intset *is, uint32_t pos, int64_t *value);\n// 获取整数集合的长度\nuint32_t intsetLen(const intset *is);\n// 获取整数集合占用内存空间的长度\nsize_t intsetBlobLen(intset *is);\n\n// 用于测试\n#ifdef REDIS_TEST\nint intsetTest(int argc, char *argv[]);\n#endif\n\n#endif // __INTSET_H\n```\n### intset.c\n```C\n/*\n * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"intset.h\"\n#include \"zmalloc.h\"\n#include \"endianconv.h\"\n\n/* Note that these encodings are ordered, so:\n * INTSET_ENC_INT16 < INTSET_ENC_INT32 < INTSET_ENC_INT64. */\n \n/*\n * 大小端字节序：https://www.cnblogs.com/gremount/p/8830707.html\n * 在计算机中，一般是从低位字节开始读取，而人总是习惯从高位字节开始读取\n * 为了适应计算机需求，需要将字节转换为小端字节序，也就是把字节的低位转到高位\n */\n\n// 各种整数类型占位大小\n#define INTSET_ENC_INT16 (sizeof(int16_t))\n#define INTSET_ENC_INT32 (sizeof(int32_t))\n#define INTSET_ENC_INT64 (sizeof(int64_t))\n\n/* Return the required encoding for the provided value. */\n// 返回提供的整数类型的占位大小,虽然输入的是int64_t类型，但是如果输入的值范围在更小的类型中，那就返回适合的类型占位大小\nstatic uint8_t _intsetValueEncoding(int64_t v) {\n    if (v < INT32_MIN || v > INT32_MAX) // 如果输入的数值小于整型所占最小范围或者大于整型所占最大范围，那确定它是64位整型\n        re1turn INTSET_ENC_INT64;\n    else if (v < INT16_MIN || v > INT16_MAX)\n        return INTSET_ENC_INT32;\n    else\n        return INTSET_ENC_INT16;\n}\n\n/* Return the value at pos, given an encoding. */\n/* 从is中获取pos位置的整数,它是通过enc编码来获取地址的\n * 因为在intset集合中,contents一般声明为int8_t类型，取地址一般是8位8位的取。但是intset集合的类型是encoding来决定的\n * 如果intset是int16_t类型，却8位8位的取地址，取出的内容都是不对的。我们需要将contents的类型转换为enc指定的类型。\n * 取地址的时候通过enc指定的位数来取，这样就能取得正确的地址，获取正确地址中的正确内容\n * intset *is : 整数集合\n * int pos : 整数集合中一个整数所在位置\n * uint8_t enc : 类型值 uint8_t类型值是1 , uint16_t类型值是2 , uint32_t类型值是4 , uint64_t类型值是8\n * 一般enc都是is->encoding\n */\nstatic int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {\n    int64_t v64;\n    int32_t v32;\n    int16_t v16;\n\n\t// 如果enc=8 , 表示is是一个uint64_t类型的整数集合\n    if (enc == INTSET_ENC_INT64) {\n\t\t// 不管怎样，先将is的contents类型转换为int64_t,将int64_t类型区域复制给v64\n        memcpy(&v64,((int64_t*)is->contents)+pos,sizeof(v64));\n        memrev64ifbe(&v64); // 将v64地址转换为小端字节序,方便计算机读取\n        return v64; // 然后返回v64的内容\n    } else if (enc == INTSET_ENC_INT32) {\n        memcpy(&v32,((int32_t*)is->contents)+pos,sizeof(v32));\n        memrev32ifbe(&v32);\n        return v32;\n    } else {\n        memcpy(&v16,((int16_t*)is->contents)+pos,sizeof(v16));\n        memrev16ifbe(&v16);\n        return v16;\n    }\n}\n\n/* Return the value at pos, using the configured encoding. */\n// 获取pos位置的整型变量，整型集合的类型直接从encoding中获取\nstatic int64_t _intsetGet(intset *is, int pos) {\n    return _intsetGetEncoded(is,pos,intrev32ifbe(is->encoding));\n}\n\n/* Set the value at pos, using the configured encoding. */\n// 在pos位置设置一个整数值\nstatic void _intsetSet(intset *is, int pos, int64_t value) {\n    uint32_t encoding = intrev32ifbe(is->encoding); //先获取is是哪种类型的整数集合\n\n    if (encoding == INTSET_ENC_INT64) { // 如果is是uint64_t类型的整数集合,先将is中的contents强制转换为int64_t类型，将value放置在64位的区域内\n        ((int64_t*)is->contents)[pos] = value;\n        memrev64ifbe(((int64_t*)is->contents)+pos); // 将地址转换为小端地址序存储\n    } else if (encoding == INTSET_ENC_INT32) {\n        ((int32_t*)is->contents)[pos] = value;\n        memrev32ifbe(((int32_t*)is->contents)+pos);\n    } else {\n        ((int16_t*)is->contents)[pos] = value;\n        memrev16ifbe(((int16_t*)is->contents)+pos);\n    }\n}\n\n/* Create an empty intset. */\n// 创建一个空的整数集合\nintset *intsetNew(void) {\n    intset *is = zmalloc(sizeof(intset));\n    is->encoding = intrev32ifbe(INTSET_ENC_INT16);\n    is->length = 0;\n    return is;\n}\n\n/* Resize the intset */\n// 改变整数集合大小\nstatic intset *intsetResize(intset *is, uint32_t len) {\n    uint32_t size = len*intrev32ifbe(is->encoding);\n    is = zrealloc(is,sizeof(intset)+size);\n    return is;\n}\n\n/* Search for the position of \"value\". Return 1 when the value was found and\n * sets \"pos\" to the position of the value within the intset. Return 0 when\n * the value is not present in the intset and sets \"pos\" to the position\n * where \"value\" can be inserted. */\n/* 搜索pos位置的value,如果value被找到，则返回1,并且pos位置在集合中\n * 如果value没有被找到，则返回0,并且pos位置不在集合中,就为pos置0或者最大值\n */\nstatic uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {\n\t// 使用二分查找法\n    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1; // min:最小值，max:最大值，mid:初始中间值\n    int64_t cur = -1; // 当前游标\n\n    /* The value can never be found when the set is empty */\n    if (intrev32ifbe(is->length) == 0) { // 当集合长度为0,表示为空\n        if (pos) *pos = 0; // 如果输入的pos地址不畏NULL,就给它置0\n        return 0;\n    } else {\n        /* Check for the case where we know we cannot find the value,\n         * but do know the insert position. */\n         // 在intset集合中,最大值会被放在最后，最小值会被放在最前\n         // 因为，数据编码最大的会放在最后面，而最大值的数据编码是最大的\n        if (value > _intsetGet(is,max)) { \n            if (pos) *pos = intrev32ifbe(is->length);\n            return 0;\n        } else if (value < _intsetGet(is,0)) {\n            if (pos) *pos = 0;\n            return 0;\n        }\n    }\n\n\t// 当索引最大值大于索引最小值\n    while(max >= min) {\n        mid = ((unsigned int)min + (unsigned int)max) >> 1; // (相当于min+max)/2\n        cur = _intsetGet(is,mid); // 获取中间值\n        // 判断value值在哪边,如果在中间就表示已经被找到,索引值就不要改变，直接执行下一步\n        if (value > cur) {\n            min = mid+1;\n        } else if (value < cur) {\n            max = mid-1;\n        } else {\n            break;\n        }\n    }\n\t\n\t// 表示已经被找到\n    if (value == cur) {\n        if (pos) *pos = mid;\n        return 1;\n    } else {\n        if (pos) *pos = min;\n        return 0;\n    }\n}\n\n/* Upgrades the intset to a larger encoding and inserts the given integer. */\n// 新增value,并根据新增value的编码来升级intset的编码\nstatic intset *intsetUpgradeAndAdd(intset *is, int64_t value) {\n    uint8_t curenc = intrev32ifbe(is->encoding); // 将encoding转换为32为的小端字节序，并返回其内容\n    uint8_t newenc = _intsetValueEncoding(value); // 获取value值的编码类型\n    int length = intrev32ifbe(is->length); // 获取is的长度\n    int prepend = value < 0 ? 1 : 0; \n\n    /* First set new encoding and resize */\n    is->encoding = intrev32ifbe(newenc); // is小端字节序存储新编码\n    is = intsetResize(is,intrev32ifbe(is->length)+1); // 扩容\n\n    /* Upgrade back-to-front so we don't overwrite values.\n     * Note that the \"prepend\" variable is used to make sure we have an empty\n     * space at either the beginning or the end of the intset. */\n     /* 如果prepend=1,表示需要在最前面增加值，就将intset集合中的元素一个一个的向后摞一位，使得索引为0时是空的\n      * 如果prepend=0,表示需要在最后面增加值，就将intset集合重新增加一遍，不改变索引\n      */\n    while(length--)\n        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));\n\n    /* Set the value at the beginning or the end. */\n    // 如果输入的整数是小于0的，就将其安放在最开始\n    if (prepend)\n        _intsetSet(is,0,value);\n    else // 否则就放在结束\n        _intsetSet(is,intrev32ifbe(is->length),value);\n    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);\n    return is;\n}\n\n// 向后移动元素,主要是用来为新元素预留空间\nstatic void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {\n    void *src, *dst;\n    uint32_t bytes = intrev32ifbe(is->length)-from; // 获取索引from后的元素数\n    uint32_t encoding = intrev32ifbe(is->encoding);\n\n    if (encoding == INTSET_ENC_INT64) {\n        src = (int64_t*)is->contents+from;\n        dst = (int64_t*)is->contents+to;\n        bytes *= sizeof(int64_t);\n    } else if (encoding == INTSET_ENC_INT32) {\n        src = (int32_t*)is->contents+from;\n        dst = (int32_t*)is->contents+to;\n        bytes *= sizeof(int32_t);\n    } else {\n        src = (int16_t*)is->contents+from;\n        dst = (int16_t*)is->contents+to;\n        bytes *= sizeof(int16_t);\n    }\n    memmove(dst,src,bytes);\n}\n\n/* Insert an integer in the intset */\n// 添加一个整数到intset,添加成功，success=1,否则success=0\nintset *intsetAdd(intset *is, int64_t value, uint8_t *success) {\n    uint8_t valenc = _intsetValueEncoding(value); // 为value值设置一个合适的编码\n    uint32_t pos;\n    if (success) *success = 1;\n\n    /* Upgrade encoding if necessary. If we need to upgrade, we know that\n     * this value should be either appended (if > 0) or prepended (if < 0),\n     * because it lies outside the range of existing values. */\n    if (valenc > intrev32ifbe(is->encoding)) { // 如果需要增加值的编码比is的编码大，就需要升级is为value一样的编码,并将value增加到最后\n        /* This always succeeds, so we don't need to curry *success. */\n        return intsetUpgradeAndAdd(is,value);\n    } else { // 如果编码一样或者更小，就找到value的插入点\n        /* Abort if the value is already present in the set.\n         * This call will populate \"pos\" with the right position to insert\n         * the value when it cannot be found. */\n        if (intsetSearch(is,value,&pos)) { // 表示查找到intset有相同的值\n            if (success) *success = 0;\n            return is;\n        }\n\n        is = intsetResize(is,intrev32ifbe(is->length)+1);\n        // 如果pos=0,就直接将整体向后移一位，空出第一位\n        if (pos < intrev32ifbe(is->length)) intsetMoveTail(is,pos,pos+1);\n    }\n\n    _intsetSet(is,pos,value);\n    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);\n    return is;\n}\n\n/* Delete integer from intset */\n// 从intset中删除\nintset *intsetRemove(intset *is, int64_t value, int *success) {\n    uint8_t valenc = _intsetValueEncoding(value);\n    uint32_t pos;\n    if (success) *success = 0;\n\n    if (valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,&pos)) {\n        uint32_t len = intrev32ifbe(is->length);\n\n        /* We know we can delete */\n        if (success) *success = 1;\n\n        /* Overwrite value with tail and update length */\n        if (pos < (len-1)) intsetMoveTail(is,pos+1,pos);\n        is = intsetResize(is,len-1);\n        is->length = intrev32ifbe(len-1);\n    }\n    return is;\n}\n\n/* Determine whether a value belongs to this set */\n// 查询value,调用intsetSearch函数,查询成功返回1,失败返回0\nuint8_t intsetFind(intset *is, int64_t value) {\n    uint8_t valenc = _intsetValueEncoding(value);\n    return valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,NULL);\n}\n\n/* Return random member */\n// 返回一个随机索引中的值\nint64_t intsetRandom(intset *is) {\n    return _intsetGet(is,rand()%intrev32ifbe(is->length));\n}\n\n/* Get the value at the given position. When this position is\n * out of range the function returns 0, when in range it returns 1. */\n // 获取pos位置的整型变量，如果成功获取，返回1,并且value存储获取到的值;否则返回0,value=NULL\nuint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {\n    if (pos < intrev32ifbe(is->length)) {\n        *value = _intsetGet(is,pos);\n        return 1;\n    }\n    return 0;\n}\n\n/* Return intset length */\n// 获取is长度\nuint32_t intsetLen(const intset *is) {\n    return intrev32ifbe(is->length);\n}\n\n/* Return intset blob size in bytes. */\n// len*encoding+sizeof(intset);返回的是内存空间的长度\nsize_t intsetBlobLen(intset *is) {\n    return sizeof(intset)+intrev32ifbe(is->length)*intrev32ifbe(is->encoding);\n}\n\n#ifdef REDIS_TEST\n#include <sys/time.h>\n#include <time.h>\n\n#if 0\nstatic void intsetRepr(intset *is) {\n    for (uint32_t i = 0; i < intrev32ifbe(is->length); i++) {\n        printf(\"%lld\\n\", (uint64_t)_intsetGet(is,i));\n    }\n    printf(\"\\n\");\n}\n\nstatic void error(char *err) {\n    printf(\"%s\\n\", err);\n    exit(1);\n}\n#endif\n\nstatic void ok(void) {\n    printf(\"OK\\n\");\n}\n\nstatic long long usec(void) {\n    struct timeval tv;\n    gettimeofday(&tv,NULL);\n    return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;\n}\n\n#define assert(_e) ((_e)?(void)0:(_assert(#_e,__FILE__,__LINE__),exit(1)))\nstatic void _assert(char *estr, char *file, int line) {\n    printf(\"\\n\\n=== ASSERTION FAILED ===\\n\");\n    printf(\"==> %s:%d '%s' is not true\\n\",file,line,estr);\n}\n\nstatic intset *createSet(int bits, int size) {\n    uint64_t mask = (1<<bits)-1;\n    uint64_t value;\n    intset *is = intsetNew();\n\n    for (int i = 0; i < size; i++) {\n        if (bits > 32) {\n            value = (rand()*rand()) & mask;\n        } else {\n            value = rand() & mask;\n        }\n        is = intsetAdd(is,value,NULL);\n    }\n    return is;\n}\n\nstatic void checkConsistency(intset *is) {\n    for (uint32_t i = 0; i < (intrev32ifbe(is->length)-1); i++) {\n        uint32_t encoding = intrev32ifbe(is->encoding);\n\n        if (encoding == INTSET_ENC_INT16) {\n            int16_t *i16 = (int16_t*)is->contents;\n            assert(i16[i] < i16[i+1]);\n        } else if (encoding == INTSET_ENC_INT32) {\n            int32_t *i32 = (int32_t*)is->contents;\n            assert(i32[i] < i32[i+1]);\n        } else {\n            int64_t *i64 = (int64_t*)is->contents;\n            assert(i64[i] < i64[i+1]);\n        }\n    }\n}\n\n#define UNUSED(x) (void)(x)\nint intsetTest(int argc, char **argv) {\n    uint8_t success;\n    int i;\n    intset *is;\n    srand(time(NULL));\n\n    UNUSED(argc);\n    UNUSED(argv);\n\n    printf(\"Value encodings: \"); {\n        assert(_intsetValueEncoding(-32768) == INTSET_ENC_INT16);\n        assert(_intsetValueEncoding(+32767) == INTSET_ENC_INT16);\n        assert(_intsetValueEncoding(-32769) == INTSET_ENC_INT32);\n        assert(_intsetValueEncoding(+32768) == INTSET_ENC_INT32);\n        assert(_intsetValueEncoding(-2147483648) == INTSET_ENC_INT32);\n        assert(_intsetValueEncoding(+2147483647) == INTSET_ENC_INT32);\n        assert(_intsetValueEncoding(-2147483649) == INTSET_ENC_INT64);\n        assert(_intsetValueEncoding(+2147483648) == INTSET_ENC_INT64);\n        assert(_intsetValueEncoding(-9223372036854775808ull) ==\n                    INTSET_ENC_INT64);\n        assert(_intsetValueEncoding(+9223372036854775807ull) ==\n                    INTSET_ENC_INT64);\n        ok();\n    }\n\n    printf(\"Basic adding: \"); {\n        is = intsetNew();\n        is = intsetAdd(is,5,&success); assert(success);\n        is = intsetAdd(is,6,&success); assert(success);\n        is = intsetAdd(is,4,&success); assert(success);\n        is = intsetAdd(is,4,&success); assert(!success);\n        ok();\n    }\n\n    printf(\"Large number of random adds: \"); {\n        uint32_t inserts = 0;\n        is = intsetNew();\n        for (i = 0; i < 1024; i++) {\n            is = intsetAdd(is,rand()%0x800,&success);\n            if (success) inserts++;\n        }\n        assert(intrev32ifbe(is->length) == inserts);\n        checkConsistency(is);\n        ok();\n    }\n\n    printf(\"Upgrade from int16 to int32: \"); {\n        is = intsetNew();\n        is = intsetAdd(is,32,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);\n        is = intsetAdd(is,65535,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT32);\n        assert(intsetFind(is,32));\n        assert(intsetFind(is,65535));\n        checkConsistency(is);\n\n        is = intsetNew();\n        is = intsetAdd(is,32,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);\n        is = intsetAdd(is,-65535,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT32);\n        assert(intsetFind(is,32));\n        assert(intsetFind(is,-65535));\n        checkConsistency(is);\n        ok();\n    }\n\n    printf(\"Upgrade from int16 to int64: \"); {\n        is = intsetNew();\n        is = intsetAdd(is,32,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);\n        is = intsetAdd(is,4294967295,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT64);\n        assert(intsetFind(is,32));\n        assert(intsetFind(is,4294967295));\n        checkConsistency(is);\n\n        is = intsetNew();\n        is = intsetAdd(is,32,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT16);\n        is = intsetAdd(is,-4294967295,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT64);\n        assert(intsetFind(is,32));\n        assert(intsetFind(is,-4294967295));\n        checkConsistency(is);\n        ok();\n    }\n\n    printf(\"Upgrade from int32 to int64: \"); {\n        is = intsetNew();\n        is = intsetAdd(is,65535,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT32);\n        is = intsetAdd(is,4294967295,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT64);\n        assert(intsetFind(is,65535));\n        assert(intsetFind(is,4294967295));\n        checkConsistency(is);\n\n        is = intsetNew();\n        is = intsetAdd(is,65535,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT32);\n        is = intsetAdd(is,-4294967295,NULL);\n        assert(intrev32ifbe(is->encoding) == INTSET_ENC_INT64);\n        assert(intsetFind(is,65535));\n        assert(intsetFind(is,-4294967295));\n        checkConsistency(is);\n        ok();\n    }\n\n    printf(\"Stress lookups: \"); {\n        long num = 100000, size = 10000;\n        int i, bits = 20;\n        long long start;\n        is = createSet(bits,size);\n        checkConsistency(is);\n\n        start = usec();\n        for (i = 0; i < num; i++) intsetSearch(is,rand() % ((1<<bits)-1),NULL);\n        printf(\"%ld lookups, %ld element set, %lldusec\\n\",\n               num,size,usec()-start);\n    }\n\n    printf(\"Stress add+delete: \"); {\n        int i, v1, v2;\n        is = intsetNew();\n        for (i = 0; i < 0xffff; i++) {\n            v1 = rand() % 0xfff;\n            is = intsetAdd(is,v1,NULL);\n            assert(intsetFind(is,v1));\n\n            v2 = rand() % 0xfff;\n            is = intsetRemove(is,v2,NULL);\n            assert(!intsetFind(is,v2));\n        }\n        checkConsistency(is);\n        ok();\n    }\n\n    return 0;\n}\n#endif\n```\n\n### 文献整理\n 1. [Redis内部数据结构详解(7)——intset](https://blog.csdn.net/yellowriver007/article/details/79021147)\n 2. [Redis之整数集合intset](https://blog.csdn.net/zgaoq/article/details/89708500)\n 3. [redis中整数聚合的add操作](https://blog.csdn.net/bettyf/article/details/82319619) \n","tags":["源码阅读"],"categories":["数据结构"]},{"title":"redis源码阅读-dict(字典)","url":"%2F2019%2F12%2F22%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FC%2Fredis%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-dict-%E5%AD%97%E5%85%B8%2F","content":"\n## redis源码阅读-dict(字典)\n### 字典结构\n#### 字典主要结构\n字典主要分四个结构：dictEntry,dictht,dict,dictType。\n  + dictEntry，是存放键值对元素的实体结构，其可以组成链表结构。\n  + dictht，是存放由dictEntry组成的数组，形成hash表。\n  + dict,则是存放dictht，形成一个字典。\n  + dictType，是字典需要的动作。\n我们可以把dictht中的hash表看作为一个数组，数组中的每个元素被成为一个桶，这个桶存放的是一个以dictEntry形成的链表。dict中存放有两张hash表，组成新旧两张表，这是用来进行rehash的。\n#### rehash\n  + rehash,渐进式迁移，这是redis中用来改变表大小的一种手段。redis中有新旧两张表，旧表存储的是字典数据，一般新表是空的。\n  + 当字典需要改变时，比如扩展容量，缩小容量等。如果字典存储的数据量太大，一次改变大小会进行很久，而redis是一个单进程程序，这样会造成阻塞。\n  + 而采用渐进式迁移，先为新表分配需要改变的大小，然后将旧表中的数据一个个的迁移进新表，而且这个迁移过程被分为许多步，在迁移过程中可以被中断。\n  + 中断之后，还没迁移完成的数据存在旧表中，迁移完成的数据就存放在新表中，数据并不会消失。\n### 字典重要函数介绍\n#### dictScan函数\n主要是其使用的算法很经典，值得研究。dictScan函数为了减少重复遍历元素，其采用 reverse binary iteration迭代器算法，此算法由Pieter Noordhuis创造。\n主要原理：\n```\n最高位+1,向低位进位，在字典不稳定的情况下，既要遍历到所有没被删除的元素，又要尽可能较少的重复遍历。这么做是最好的\nhash表的扩容和缩小都是以2的幂次进行的,如果使用这种方法，每次hash表改变时，游标的状态都不会变。游标所遍历的节点大部分都会在改变后表的游标的前面，不用再被遍历。 \n例如：\n    每次加法都是最高位+1,向低位进位\n    hash为8位时：000 -> 100 -> 010 -> 110 -> 001 -> 101 -> 011 -> 111 -> 000 \n    hash表为16位时：0000 -> 1000 -> 0100 -> 1100 -> 0010 -> 1010 -> 0110 -> \n    1110 -> 0001 -> 1001 -> 0101 -> 1101 -> 0011 -> 1011 -> \n    0111 -> 1111 -> 0000 \n    \n    当我在hash表为8位时，游标是110,我已经遍历了000,100,010;如果hash表扩张到16位，游标在新表中的位置是0110\n    看一下游标之前的有哪些，0000,1000,0100,1100,0010,1010;恰好，扩张前已经遍历的都在其中。\n```\n### dict.h\n```C\n/* Hash Tables Implementation.\n *\n * This file implements in-memory hash tables with insert/del/replace/find/\n * get-random-element operations. Hash tables will auto-resize if needed\n * tables of power of two in size are used, collisions are handled by\n * chaining. See the source code for more information... :)\n *\n * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/**********************************\n\t这个文件实现了在内存中的hash表的insert/del/replace/find/get-random-element操作\n\t如果发现被用的新旧两个hash表已经满了，就自动扩展\n***********************************/\n#include <stdint.h>\n\n#ifndef __DICT_H\n#define __DICT_H\n\n#define DICT_OK 0\n#define DICT_ERR 1\n\n/* Unused arguments generate annoying warnings... */\n#define DICT_NOTUSED(V) ((void) V)\n\n// 一个键值对的数据结构，存储的是一对键值对。这可以组成一个链表\ntypedef struct dictEntry {\n    void *key;\n    union { // 联合体，占用字节数按其中最大的一个类型计算\n        void *val; // 空类型，可以表示任意\n        uint64_t u64; // 无符号长整型\n        int64_t s64; // 长整型\n        double d; // 双精度浮点数\n    } v;\n    struct dictEntry *next; // 键值对指针，可以查找下一个键值对\n} dictEntry;\n\n// 其中是操作字典类型的各种动作\ntypedef struct dictType {\n    uint64_t (*hashFunction)(const void *key);\n    void *(*keyDup)(void *privdata, const void *key); // 键复制\n    void *(*valDup)(void *privdata, const void *obj); // 值复制\n    int (*keyCompare)(void *privdata, const void *key1, const void *key2); // 键比较\n    void (*keyDestructor)(void *privdata, void *key); // 销毁键\n    void (*valDestructor)(void *privdata, void *obj); // 销毁值\n} dictType;\n\n/* This is our hash table structure. Every dictionary has two of this as we\n * implement incremental rehashing, for the old to the new table. */\n// 字典类型的hash表\ntypedef struct dictht {\n\t/* 哈希表数组\n\t\t一个数组,每个元素位存储的是一个dictEntry,而dictEntry可以组成一个链表。这就使得数组中的每个元素可以作为一个链表的头结点，这样一个数组元素可以存储多个数据。\n\t\tjava中的hashMap等hash结构也是使用hash表，可以对照看\n\t */\n    dictEntry **table; \n    unsigned long size; // 哈希表大小\n    unsigned long sizemask; // 哈希表大小掩码，用于计算索引值，总是等于size=-1\n    unsigned long used; // 哈希表已有的节点数\n} dictht;\n\n// 一个完整的字典类型，其中包含字典动作，字典数据，字典的hash表\n// 可以把这个结构体看做是一个完整的类，type就是类方法，private就是类的私有属性，其他也是类的属性\ntypedef struct dict {\n    dictType *type;\n    void *privdata;\n\t/* ht数组可以容纳两个元素，这每个元素就是dictht类型的元素。\n\t\t功能：\n\t\t\t维护两张hash表，作用等同于一对滚动数组。一张是旧表，一张是新表，当hash表大小需要被改变时，先创建一个新表，旧表中的元素就往新表迁移。\n\t\t\t当下一次hash表变动时，新表就变为旧表，重新开始以上动作。\n\t */\n    dictht ht[2]; \n    long rehashidx; /* rehashing not in progress if rehashidx == -1 */ // 用来标志是否需要渐进式hash\n    unsigned long iterators; /* number of iterators currently running */ // 字典迭代器号\n} dict;\n\n/* If safe is set to 1 this is a safe iterator, that means, you can call\n * dictAdd, dictFind, and other functions against the dictionary even while\n * iterating. Otherwise it is a non safe iterator, and only dictNext()\n * should be called while iterating. */\n // 字典迭代器 , 在字典中，迭代一个个的dictEntry元素\n // https://blog.csdn.net/dengzhilong_cpp/article/details/54953911\ntypedef struct dictIterator {\n    dict *d; // 指向迭代器处理的字典\n    long index; // hash数组中的索引，是dictht结构里的table的下标。\n\t/*\n\t\tsafe是用来确定迭代器是否安全，safe=1时，表示迭代器安全，可以使用dictAdd,dictFind等函数\n\t\t如果safe不等于1，表示迭代器不安全，只能使用dictNext函数进行迭代\n\t\ttable是dict里的dictht数组的下标，标识ht是ht[0]还是ht[1]\n\t */\n    int table, safe;\n    dictEntry *entry, *nextEntry;\n    /* unsafe iterator fingerprint for misuse detection. */\n    long long fingerprint; // 是字典的指纹,是对不安全的迭代器的误用检测\n} dictIterator;\n\n// 字典扫描函数指针\ntypedef void (dictScanFunction)(void *privdata, const dictEntry *de);\ntypedef void (dictScanBucketFunction)(void *privdata, dictEntry **bucketref);\n\n/* This is the initial size of every hash table */\n// 每个hash表初始化的大小\n#define DICT_HT_INITIAL_SIZE     4\n\n/* ------------------------------- Macros ------------------------------------*/\n// 字典为指定键值对释放值,(d)->type->valDestructor表示函数指针不为空(已经指向了一个执行函数),可以通过这个执行函数获取结果\n#define dictFreeVal(d, entry) \\\n    if ((d)->type->valDestructor) \\\n        (d)->type->valDestructor((d)->privdata, (entry)->v.val)\n// 字典为指定键值对设置值\n// 将_val_值复制给(d)->privdata\n// 然后将值再复制给键值对\n#define dictSetVal(d, entry, _val_) do { \\\n    if ((d)->type->valDup) \\\n        (entry)->v.val = (d)->type->valDup((d)->privdata, _val_); \\\n    else \\\n        (entry)->v.val = (_val_); \\\n} while(0)\n\n/************************为键值对设置值***********************/\n// 为指定键值对设置有符号整型值\n#define dictSetSignedIntegerVal(entry, _val_) \\\n    do { (entry)->v.s64 = _val_; } while(0)\n\n// 为指定键值对设置无符号整型值\n#define dictSetUnsignedIntegerVal(entry, _val_) \\\n    do { (entry)->v.u64 = _val_; } while(0)\n\n// 为指定键值对设置double值\n#define dictSetDoubleVal(entry, _val_) \\\n    do { (entry)->v.d = _val_; } while(0)\n\n// 从字典中释放键值对\n#define dictFreeKey(d, entry) \\\n    if ((d)->type->keyDestructor) \\\n        (d)->type->keyDestructor((d)->privdata, (entry)->key)\n\n// 为字典设置键\n#define dictSetKey(d, entry, _key_) do { \\\n    if ((d)->type->keyDup) \\\n        (entry)->key = (d)->type->keyDup((d)->privdata, _key_); \\\n    else \\\n        (entry)->key = (_key_); \\\n} while(0)\n\n// 字典中键的比较\n#define dictCompareKeys(d, key1, key2) \\\n    (((d)->type->keyCompare) ? \\\n        (d)->type->keyCompare((d)->privdata, key1, key2) : \\\n        (key1) == (key2))\n\t\t\n// 为字典中的键获取hash值\n#define dictHashKey(d, key) (d)->type->hashFunction(key)\n// 从键值对中获取key\n#define dictGetKey(he) ((he)->key)\n// 从键值对中获取val(空指针类型)\n#define dictGetVal(he) ((he)->v.val)\n// 从键值对中获取s64(int64_t类型)\n#define dictGetSignedIntegerVal(he) ((he)->v.s64)\n// 从键值对中获取u64(uint64_t类型)\n#define dictGetUnsignedIntegerVal(he) ((he)->v.u64)\n// 从键值对中获取d(double类型)\n#define dictGetDoubleVal(he) ((he)->v.d)\n// 获取字典中新旧hash表被分配的总大小\n#define dictSlots(d) ((d)->ht[0].size+(d)->ht[1].size)\n// 获取字典中新旧hash被用的总节点数\n#define dictSize(d) ((d)->ht[0].used+(d)->ht[1].used)\n// 判断字典是否渐进式\n#define dictIsRehashing(d) ((d)->rehashidx != -1)\n\n/* API */\n// 字典创建\ndict *dictCreate(dictType *type, void *privDataPtr);\n// 字典扩展\nint dictExpand(dict *d, unsigned long size);\n// 为字典增加键值对\nint dictAdd(dict *d, void *key, void *val);\ndictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing);\ndictEntry *dictAddOrFind(dict *d, void *key);\nint dictReplace(dict *d, void *key, void *val);\nint dictDelete(dict *d, const void *key);\ndictEntry *dictUnlink(dict *ht, const void *key);\nvoid dictFreeUnlinkedEntry(dict *d, dictEntry *he);\nvoid dictRelease(dict *d);\ndictEntry * dictFind(dict *d, const void *key);\nvoid *dictFetchValue(dict *d, const void *key);\nint dictResize(dict *d);\ndictIterator *dictGetIterator(dict *d);\ndictIterator *dictGetSafeIterator(dict *d);\ndictEntry *dictNext(dictIterator *iter);\nvoid dictReleaseIterator(dictIterator *iter);\ndictEntry *dictGetRandomKey(dict *d);\nunsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count);\nvoid dictGetStats(char *buf, size_t bufsize, dict *d);\nuint64_t dictGenHashFunction(const void *key, int len);\nuint64_t dictGenCaseHashFunction(const unsigned char *buf, int len);\nvoid dictEmpty(dict *d, void(callback)(void*));\nvoid dictEnableResize(void);\nvoid dictDisableResize(void);\nint dictRehash(dict *d, int n);\nint dictRehashMilliseconds(dict *d, int ms);\nvoid dictSetHashFunctionSeed(uint8_t *seed);\nuint8_t *dictGetHashFunctionSeed(void);\nunsigned long dictScan(dict *d, unsigned long v, dictScanFunction *fn, dictScanBucketFunction *bucketfn, void *privdata);\nuint64_t dictGetHash(dict *d, const void *key);\ndictEntry **dictFindEntryRefByPtrAndHash(dict *d, const void *oldptr, uint64_t hash);\n\n/* Hash table types */\nextern dictType dictTypeHeapStringCopyKey;\nextern dictType dictTypeHeapStrings;\nextern dictType dictTypeHeapStringCopyKeyValue;\n\n#endif /* __DICT_H */\n```\n### dict.c\n```C\n/* Hash Tables Implementation.\n *\n * This file implements in memory hash tables with insert/del/replace/find/\n * get-random-element operations. Hash tables will auto resize if needed\n * tables of power of two in size are used, collisions are handled by\n * chaining. See the source code for more information... :)\n *\n * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"fmacros.h\" // 提供mac兼容\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <sys/time.h>\n\n#include \"dict.h\" // 提供定义的字典数据结构和字典需要的函数原型\n#include \"zmalloc.h\" // 提供redis包装的内存分配函数\n#ifndef DICT_BENCHMARK_MAIN // 如果有判断字典的检测主函数，就需要使用断言的函数\n#include \"redisassert.h\"\n#else\n#include <assert.h> // 否则使用默认的断言\n#endif\n\n/* Using dictEnableResize() / dictDisableResize() we make possible to\n * enable/disable resizing of the hash table as needed. This is very important\n * for Redis, as we use copy-on-write and don't want to move too much memory\n * around when there is a child performing saving operations.\n *\n * Note that even when dict_can_resize is set to 0, not all resizes are\n * prevented: a hash table is still allowed to grow if the ratio between\n * the number of elements and the buckets > dict_force_resize_ratio. */\n // 标志位，字典是否能重设大小。等于1表示能，等于0表示不能\n //有种情况下可以：总的元素个数/dict桶的个数>dict_force_resize_ratio\n // 含义：hash表示由数组+链表组成，一个数组元素形成的链表就是一个桶(hash会遇到碰撞问题，如果一个新增的元素的hash值与数组中的一个元素相同，则这个新增的元素就挂在相同元素的前面，形成链表，就成一个桶了。)\n // 如果桶存储的元素太多，每次查询时都会到一个元素所在位置，然后查链表，链表的查询效率本来就比数组低。这样查询效率就很低\nstatic int dict_can_resize = 1;\nstatic unsigned int dict_force_resize_ratio = 5; // 平均桶的深度\n\n/* -------------------------- private prototypes ---------------------------- */\n// 私有函数\n\n// 如果需要字典可以进行扩展\nstatic int _dictExpandIfNeeded(dict *ht);\n// 获取字典的真实大小\nstatic unsigned long _dictNextPower(unsigned long size);\n// 通过key进行字典索引\nstatic long _dictKeyIndex(dict *ht, const void *key, uint64_t hash, dictEntry **existing);\n// 字典初始化\nstatic int _dictInit(dict *ht, dictType *type, void *privDataPtr);\n\n/* -------------------------- hash functions -------------------------------- */\n\nstatic uint8_t dict_hash_function_seed[16];\n\nvoid dictSetHashFunctionSeed(uint8_t *seed) {\n    memcpy(dict_hash_function_seed,seed,sizeof(dict_hash_function_seed));\n}\n\nuint8_t *dictGetHashFunctionSeed(void) {\n    return dict_hash_function_seed;\n}\n\n/* The default hashing function uses SipHash implementation\n * in siphash.c. */\n\nuint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k);\nuint64_t siphash_nocase(const uint8_t *in, const size_t inlen, const uint8_t *k);\n\nuint64_t dictGenHashFunction(const void *key, int len) {\n    return siphash(key,len,dict_hash_function_seed);\n}\n\nuint64_t dictGenCaseHashFunction(const unsigned char *buf, int len) {\n    return siphash_nocase(buf,len,dict_hash_function_seed);\n}\n\n/* ----------------------------- API implementation ------------------------- */\n\n/* Reset a hash table already initialized with ht_init().\n * NOTE: This function should only be called by ht_destroy(). */\n // 重置hash表\nstatic void _dictReset(dictht *ht)\n{\n    ht->table = NULL;\n    ht->size = 0;\n    ht->sizemask = 0;\n    ht->used = 0;\n}\n\n/* Create a new hash table */\n// 创建一个新的hash表\ndict *dictCreate(dictType *type,\n        void *privDataPtr)\n{\n    dict *d = zmalloc(sizeof(*d));\n\n    _dictInit(d,type,privDataPtr);\n    return d;\n}\n\n/* Initialize the hash table */\n// 初始化hash表\nint _dictInit(dict *d, dictType *type,\n        void *privDataPtr)\n{\n\t// 先重置新表和旧表\n    _dictReset(&d->ht[0]);\n    _dictReset(&d->ht[1]);\n    d->type = type; // 初始化操作字典的动作\n    d->privdata = privDataPtr; // 初始化字典值\n    d->rehashidx = -1; // 初始化为不需要渐进式hash\n    d->iterators = 0; // 初始化为安全的迭代器\n    return DICT_OK;\n}\n\n/* Resize the table to the minimal size that contains all the elements,\n * but with the invariant of a USED/BUCKETS ratio near to <= 1 */\n // 重置字典的hash表大小(这个大小需要包含所有的元素)\nint dictResize(dict *d)\n{\n    int minimal;\n\t\n\t// 这个字典必须能被重置，并且这个字典是渐进式hash，能进行新旧表迁移\n    if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;\n    minimal = d->ht[0].used; // 获取旧表使用的元素节点数\n    if (minimal < DICT_HT_INITIAL_SIZE) // 如果节点数小于字典初始大小\n        minimal = DICT_HT_INITIAL_SIZE; // 这个字典重置的最小值扩充为字典初始大小\n    return dictExpand(d, minimal); // 然后扩容\n}\n\n/* Expand or create the hash table */\n// 扩容或者创建hash表\nint dictExpand(dict *d, unsigned long size)\n{\n    /* the size is invalid if it is smaller than the number of\n     * elements already inside the hash table */\n    if (dictIsRehashing(d) || d->ht[0].used > size)\n        return DICT_ERR;\n\n    dictht n; /* the new hash table */\n    unsigned long realsize = _dictNextPower(size); // 扩容后的大小是2^n > size\n\n    /* Rehashing to the same table size is not useful. */\n\t// 如果扩容后的大小与旧表大小相同，表示根本没有扩容\n    if (realsize == d->ht[0].size) return DICT_ERR;\n\n    /* Allocate the new hash table and initialize all pointers to NULL */\n    n.size = realsize; // 将扩容的大小赋值给字典的size属性\n    n.sizemask = realsize-1; // saize的掩码是realsize-1\n    n.table = zcalloc(realsize*sizeof(dictEntry*)); // 为hash表分配realsize个dictEntry大小的内存，calloc的size已被zcaloc设为默认的realsize*sizeof(dictEntry*)+PREFIX_SIZE\n    n.used = 0; // 被用的节点数\n\n    /* Is this the first initialization? If so it's not really a rehashing\n     * we just set the first hash table so that it can accept keys. */\n    if (d->ht[0].table == NULL) { // 如果第一个hash表为空，表示数据在ht[1]中，需要将ht[1]的数据迁移到ht[0]\n        d->ht[0] = n; // ht[0]为新表设置扩容后的分配的内存\n        return DICT_OK;\n    }\n\n    /* Prepare a second hash table for incremental rehashing */\n\t// 如果第一个表不为空，则准备第二个表进行渐进式hash\n    d->ht[1] = n; // ht[1]表为新表，为其设置扩容后的分配的内存\n    d->rehashidx = 0; // 表示可以进行渐进式hash\n    return DICT_OK;\n}\n\n/* Performs N steps of incremental rehashing. Returns 1 if there are still\n * keys to move from the old to the new hash table, otherwise 0 is returned.\n *\n * Note that a rehashing step consists in moving a bucket (that may have more\n * than one key as we use chaining) from the old to the new hash table, however\n * since part of the hash table may be composed of empty spaces, it is not\n * guaranteed that this function will rehash even a single bucket, since it\n * will visit at max N*10 empty buckets in total, otherwise the amount of\n * work it does would be unbound and the function may block for a long time. */\n // n表示需要rehash的次数\n // 数据的迁移不是一次性完成的，而是可以通过dictRehash()这个函数分步规划的，并且调用方可以及时知道是否需要继续进行渐进式哈希操作。\n // 如果dict数据结构中存储了海量的数据，那么一次性迁移势必带来redis性能的下降，redis是单线程模型，在实时性要求高的场景下这可能是致命的。\n // 而渐进式哈希则将这种代价可控地分摊了，调用方可以在dict做插入，删除，更新的时候执行dictRehash()，最小化数据迁移的代价。\n // 在迁移的过程中，数据是在新表还是旧表中并不是一个非常急迫的需求，迁移的过程并不会丢失数据，在旧表中找不到再到新表中寻找就是了。\nint dictRehash(dict *d, int n) {\n    int empty_visits = n*10; /* Max number of empty buckets to visit. */\n    if (!dictIsRehashing(d)) return 0; // 如果字典不能被渐进式\n\n\t// 一桶一桶的迁移\n    while(n-- && d->ht[0].used != 0) { // hash表的被用节点数不能为0,这里是hash表的数组节点遍历\n        dictEntry *de, *nextde; // 定义两个字典指针\n\n        /* Note that rehashidx can't overflow as we are sure there are more\n         * elements because ht[0].used != 0 */\n        assert(d->ht[0].size > (unsigned long)d->rehashidx); // 断言，字典大小必须大于渐进式hash过程的索引(rehashidx是用来确定新表中与旧表对应的索引位置)\n\t\t// 为了跳过空桶\n        while(d->ht[0].table[d->rehashidx] == NULL) { // 如果新表与旧表对应的索引在旧表中位置的元素为NULL，表示旧表已经遍历完，整个旧表已经全部复制到新表\n            d->rehashidx++;\n            if (--empty_visits == 0) return 1; // 能被访问的空桶已经没有了\n        }\n        de = d->ht[0].table[d->rehashidx]; // 得到的是hash表中对应的元素\n        /* Move all the keys in this bucket from the old to the new hash HT */\n        while(de) { // 遍历hash表元素形成的链表\n            uint64_t h;\n\n            nextde = de->next;\n            /* Get the index in the new hash table */\n\t\t\t// 获取新表索引\n            h = dictHashKey(d, de->key) & d->ht[1].sizemask;\n            de->next = d->ht[1].table[h]; // 旧表当前hash元素的向后指针指向新表\n            d->ht[1].table[h] = de; // 让旧表的当前hash与新表建立关系，进入新表\n            d->ht[0].used--; // 旧表节点减少一个\n            d->ht[1].used++; // 新表节点增加一个\n            de = nextde; // 遍历下一个\n        }\n        d->ht[0].table[d->rehashidx] = NULL; // 将旧表当前索引置NULL\n        d->rehashidx++; // 渐进式hash索引+1\n    }\n\n    /* Check if we already rehashed the whole table... */\n\t// 如果已经遍历完整个表,将旧表分配的内存释放\n    if (d->ht[0].used == 0) {\n        zfree(d->ht[0].table);\n        d->ht[0] = d->ht[1]; // 将重新分配的内存从新表迁移回到旧表\n        _dictReset(&d->ht[1]); // 重置新表\n        d->rehashidx = -1; // 此时渐进式迁移索引-1\n        return 0;\n    }\n\n    /* More to rehash... */\n    return 1; // 否则表示数据还没有迁移完成\n}\n\n// 获取当前微秒级时间\nlong long timeInMilliseconds(void) {\n    struct timeval tv;\n\n    gettimeofday(&tv,NULL);\n    return (((long long)tv.tv_sec)*1000)+(tv.tv_usec/1000);\n}\n\n/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */\n// 在ms微秒和ms+1微秒之间渐进式迁移hsah表的进度(rehashes表示一张hash表rehash的次数)\nint dictRehashMilliseconds(dict *d, int ms) {\n    long long start = timeInMilliseconds();\n    int rehashes = 0;\n\t\n\t// 每次都进行100次rehash操作\n    while(dictRehash(d,100)) {\n        rehashes += 100;\n        if (timeInMilliseconds()-start > ms) break;\n    }\n    return rehashes;\n}\n\n/* This function performs just a step of rehashing, and only if there are\n * no safe iterators bound to our hash table. When we have iterators in the\n * middle of a rehashing we can't mess with the two hash tables otherwise\n * some element can be missed or duplicated.\n *\n * This function is called by common lookup or update operations in the\n * dictionary so that the hash table automatically migrates from H1 to H2\n * while it is actively used. */\n // 一步一步的rehash\nstatic void _dictRehashStep(dict *d) {\n    if (d->iterators == 0) dictRehash(d,1); // 每次都进行一次rehash操作\n}\n\n/* Add an element to the target hash table */\n// 增加一个元素到字典中的hash表中\nint dictAdd(dict *d, void *key, void *val)\n{\n    dictEntry *entry = dictAddRaw(d,key,NULL); // 先将键加入字典实体,创建一个新的键值对实体,先不设置值。\n\n    if (!entry) return DICT_ERR; \n    dictSetVal(d, entry, val); // 然后将值加入字典中的对应的键的实体中\n    return DICT_OK;\n}\n\n/* Low level add or find:\n * This function adds the entry but instead of setting a value returns the\n * dictEntry structure to the user, that will make sure to fill the value\n * field as he wishes.\n *\n * This function is also directly exposed to the user API to be called\n * mainly in order to store non-pointers inside the hash value, example:\n *\n * entry = dictAddRaw(dict,mykey,NULL);\n * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);\n *\n * Return values:\n *\n * If key already exists NULL is returned, and \"*existing\" is populated\n * with the existing entry if existing is not NULL.\n *\n * If key was added, the hash entry is returned to be manipulated by the caller.\n */\n // 只是增加一个包含键的实体结构，不为实体设置值。如果需要增加的实体存在，则让存在的实体将existing填充\ndictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)\n{\n    long index; // 字典中的索引\n    dictEntry *entry; // 字典中的键值对实体\n    dictht *ht; // 字典中的hash表\n\n    if (dictIsRehashing(d)) _dictRehashStep(d); // 如果该字典正在rehash过程中，那接着执行rehash\n\n    /* Get the index of the new element, or -1 if\n     * the element already exists. */\n\t // 获取新元素在字典中的索引，如果元素已经存在，则返回-1\n    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)\n        return NULL;\n\n    /* Allocate the memory and store the new entry.\n     * Insert the element in top, with the assumption that in a database\n     * system it is more likely that recently added entries are accessed\n     * more frequently. */\n\t // 如果该字典正在rehash，就让指针ht指向新表，在新表分配内存\n    ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];\n    entry = zmalloc(sizeof(*entry)); // 为实体分配内存\n    entry->next = ht->table[index]; // 将实体加入hash表\n    ht->table[index] = entry;\n    ht->used++;\n\n    /* Set the hash entry fields. */\n\t// 将键设置到entry中，然后将entry设置到字典中\n    dictSetKey(d, entry, key);\n    return entry;\n}\n\n/* Add or Overwrite:\n * Add an element, discarding the old value if the key already exists.\n * Return 1 if the key was added from scratch, 0 if there was already an\n * element with such key and dictReplace() just performed a value update\n * operation. */\n // 如果字典中有这个元素，就将旧元素替代，如果没有就增加进去\nint dictReplace(dict *d, void *key, void *val)\n{\n    dictEntry *entry, *existing, auxentry;\n\n    /* Try to add the element. If the key\n     * does not exists dictAdd will succeed. */\n\t // 将key增加到实体中，如果字典中存在有相同的，则返回NULL,并且existing被存在的实体填充\n\t // 如果字典中不存在相同的实体，则将实体加入字典，并返回加入后的实体\n    entry = dictAddRaw(d,key,&existing);\n    if (entry) { // 如果entry不为空，表示原来的实体不存在，就直接将新实体加入\n        dictSetVal(d, entry, val);\n        return 1;\n    }\n\n    /* Set the new value and free the old one. Note that it is important\n     * to do that in this order, as the value may just be exactly the same\n     * as the previous one. In this context, think to reference counting,\n     * you want to increment (set), and then decrement (free), and not the\n     * reverse. */\n\t // 如果有相同的实体，让auxentry指针指向指向实体的指针existing,找到该实体中值的地址\n    auxentry = *existing;\n    dictSetVal(d, existing, val); // 将更新后的实体加入字典\n    dictFreeVal(d, &auxentry); // 将原来存在的值所在地址分配的内存释放\n    return 0;\n}\n\n/* Add or Find:\n * dictAddOrFind() is simply a version of dictAddRaw() that always\n * returns the hash entry of the specified key, even if the key already\n * exists and can't be added (in that case the entry of the already\n * existing key is returned.)\n *\n * See dictAddRaw() for more information. */\n // 是dictAddRaw的一种应用(如果增加成功就返回增加成功的实体；如果增加失败就返回存在的实体)\ndictEntry *dictAddOrFind(dict *d, void *key) {\n    dictEntry *entry, *existing;\n    entry = dictAddRaw(d,key,&existing); \n    return entry ? entry : existing; // 如果entry返回NULL，表示有相同的实体，那existing就是那个相同实体，就返回existing;如果entry不为空，表示已经增加实体，那就返回entry\n}\n\n/* Search and remove an element. This is an helper function for\n * dictDelete() and dictUnlink(), please check the top comment\n * of those functions. */\n  /*************************************************\n dictUnlink和dictFreeUnlinkedEntryl两个函数加起来就是dictGenericDelete函数\n dictUnlink和dictFreeUnlinkedEntryl其实就是dictGenericDelete分成两步来做\n dictDelete则是对dictGenericDelete函数的应用\n  *************************************************/\n \n \n // 通过key搜寻字典中的键值对实体并移除\nstatic dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) {\n    uint64_t h, idx;\n    dictEntry *he, *prevHe;\n    int table;\n\n\t// 如果新旧表被用的节点都为0，表示这个字典中的元素为空\n    if (d->ht[0].used == 0 && d->ht[1].used == 0) return NULL;\n\n    if (dictIsRehashing(d)) _dictRehashStep(d); // 如果该字典正在进行rehash，那就执行下一步rehash\n    h = dictHashKey(d, key); // 通过key获取字典中对应实体的hash值\n\n    for (table = 0; table <= 1; table++) { // 对两个表进行查询\n        idx = h & d->ht[table].sizemask; // 获取key所在位置的索引值\n        he = d->ht[table].table[idx]; // 获取table表的idx索引下的节点\n        prevHe = NULL;\n        while(he) {// 移除节点he\n            if (key==he->key || dictCompareKeys(d, key, he->key)) { // 判断输入的key是否是在该节点下\n                /* Unlink the element from the list */\n                if (prevHe)\n                    prevHe->next = he->next;\n                else\n                    d->ht[table].table[idx] = he->next;\n                if (!nofree) {\n                    dictFreeKey(d, he);\n                    dictFreeVal(d, he);\n                    zfree(he);\n                }\n                d->ht[table].used--;\n                return he;\n            }\n            prevHe = he;\n            he = he->next; // 如果没有在该节点下，则继续向后遍历\n        }\n        if (!dictIsRehashing(d)) break;\n    }\n    return NULL; /* not found */\n}\n\n/* Remove an element, returning DICT_OK on success or DICT_ERR if the\n * element was not found. */\n //nofree默认为0.需要将内存释放\nint dictDelete(dict *ht, const void *key) {\n    return dictGenericDelete(ht,key,0) ? DICT_OK : DICT_ERR;\n}\n\n/* Remove an element from the table, but without actually releasing\n * the key, value and dictionary entry. The dictionary entry is returned\n * if the element was found (and unlinked from the table), and the user\n * should later call `dictFreeUnlinkedEntry()` with it in order to release it.\n * Otherwise if the key is not found, NULL is returned.\n *\n * This function is useful when we want to remove something from the hash\n * table but want to use its value before actually deleting the entry.\n * Without this function the pattern would require two lookups:\n *\n *  entry = dictFind(...);\n *  // Do something with entry\n *  dictDelete(dictionary,entry);\n *\n * Thanks to this function it is possible to avoid this, and use\n * instead:\n *\n * entry = dictUnlink(dictionary,entry);\n * // Do something with entry\n * dictFreeUnlinkedEntry(entry); // <- This does not need to lookup again.\n */\n\n \n // nofree默认为1，表示虽然删除该实体，但是不会释放内存\ndictEntry *dictUnlink(dict *ht, const void *key) {\n    return dictGenericDelete(ht,key,1);\n}\n\n/* You need to call this function to really free the entry after a call\n * to dictUnlink(). It's safe to call this function with 'he' = NULL. */\n // 用于释放dictUnlink函数留下的内存\nvoid dictFreeUnlinkedEntry(dict *d, dictEntry *he) {\n    if (he == NULL) return;\n    dictFreeKey(d, he);\n    dictFreeVal(d, he);\n    zfree(he);\n}\n\n/* Destroy an entire dictionary */\n// 销毁字典\n/*\n\tdict *d     : 需要被销毁的字典\n\tdictht *ht  : 字典中的hash表\n\tvoid(callback)(void *) : 一个函数指针，回调函数，需要传入一个函数\n */\nint _dictClear(dict *d, dictht *ht, void(callback)(void *)) {\n    unsigned long i;\n\n    /* Free all the elements */\n\t// 释放所有的元素\n    for (i = 0; i < ht->size && ht->used > 0; i++) {\n        dictEntry *he, *nextHe;\n\n        if (callback && (i & 65535) == 0) callback(d->privdata);\n\n        if ((he = ht->table[i]) == NULL) continue;\n        while(he) { // 遍历桶中的链表并释放\n            nextHe = he->next;\n            dictFreeKey(d, he);\n            dictFreeVal(d, he);\n            zfree(he);\n            ht->used--;\n            he = nextHe;\n        }\n    }\n    /* Free the table and the allocated cache structure */\n    zfree(ht->table); // 释放表\n    /* Re-initialize the table */\n    _dictReset(ht); // 重置ht结构\n    return DICT_OK; /* never fails */\n}\n\n/* Clear & Release the hash table */\n// 清除和释放hash表\nvoid dictRelease(dict *d)\n{\n    _dictClear(d,&d->ht[0],NULL);\n    _dictClear(d,&d->ht[1],NULL);\n    zfree(d);\n}\n\n// 通过key查找对应的实体\ndictEntry *dictFind(dict *d, const void *key)\n{\n    dictEntry *he;\n    uint64_t h, idx, table;\n\n    if (d->ht[0].used + d->ht[1].used == 0) return NULL; /* dict is empty */\n    if (dictIsRehashing(d)) _dictRehashStep(d);\n    h = dictHashKey(d, key);\n    for (table = 0; table <= 1; table++) {\n        idx = h & d->ht[table].sizemask; // 从0开始\n        he = d->ht[table].table[idx];\n        while(he) { // 一个一个的比对，对上了就返回\n            if (key==he->key || dictCompareKeys(d, key, he->key))\n                return he;\n            he = he->next;\n        }\n        if (!dictIsRehashing(d)) return NULL;\n    }\n    return NULL;\n}\n// 通过key获取value\n// void不是不返回，而是返回一个无类型指针，可以被转换为任何类型\nvoid *dictFetchValue(dict *d, const void *key) {\n    dictEntry *he;\n\n    he = dictFind(d,key);\n    return he ? dictGetVal(he) : NULL;\n}\n\n/* A fingerprint is a 64 bit number that represents the state of the dictionary\n * at a given time, it's just a few dict properties xored together.\n * When an unsafe iterator is initialized, we get the dict fingerprint, and check\n * the fingerprint again when the iterator is released.\n * If the two fingerprints are different it means that the user of the iterator\n * performed forbidden operations against the dictionary while iterating. */\n // 字典指纹，是一个64位的整数(一个64位的hash值)\nlong long dictFingerprint(dict *d) {\n    long long integers[6], hash = 0;\n    int j;\n\n    integers[0] = (long) d->ht[0].table; // 第一位保存旧表(转换为long型)\n    integers[1] = d->ht[0].size; // 第二位保存旧表总数\n    integers[2] = d->ht[0].used; // 第三位保存旧表被用数\n    integers[3] = (long) d->ht[1].table; // 第四位保存新表(转换为long型)\n    integers[4] = d->ht[1].size; // 第五位保存新表总数\n    integers[5] = d->ht[1].used; // 第六位保存新表被用数\n\n    /* We hash N integers by summing every successive integer with the integer\n     * hashing of the previous sum. Basically:\n     *\n     * Result = hash(hash(hash(int1)+int2)+int3) ...\n     *\n     * This way the same set of integers in a different order will (likely) hash\n     * to a different number. */\n    for (j = 0; j < 6; j++) {\n        hash += integers[j];\n        /* For the hashing step we use Tomas Wang's 64 bit integer hash. */\n        hash = (~hash) + (hash << 21); // hash = (hash << 21) - hash - 1; hash << 21 ： hash的21次幂\n        hash = hash ^ (hash >> 24); // hash的(hash >> 24)次幂\n        hash = (hash + (hash << 3)) + (hash << 8); // hash * 265\n        hash = hash ^ (hash >> 14);\n        hash = (hash + (hash << 2)) + (hash << 4); // hash * 21\n        hash = hash ^ (hash >> 28);\n        hash = hash + (hash << 31);\n    }\n    return hash;\n}\n\n// 获取字典的迭代器\ndictIterator *dictGetIterator(dict *d)\n{\n    dictIterator *iter = zmalloc(sizeof(*iter)); // 为迭代器分配内存\n\n\t// 初始化字典迭代器\n    iter->d = d;\n    iter->table = 0;\n    iter->index = -1;\n    iter->safe = 0;\n    iter->entry = NULL;\n    iter->nextEntry = NULL;\n    return iter;\n}\n\n// 安全的字典迭代器\ndictIterator *dictGetSafeIterator(dict *d) {\n    dictIterator *i = dictGetIterator(d); // 获取到字典的迭代器\n\n    i->safe = 1; // 如果迭代器的safe变量为1表示迭代器是安全的\n    return i;\n}\n\n// 通过迭代器来迭代字典元素\ndictEntry *dictNext(dictIterator *iter)\n{\n    while (1) {\n        if (iter->entry == NULL) { // 如果迭代器中的元素为空，表示迭代器是初始化状态，刚开始迭代\n            dictht *ht = &iter->d->ht[iter->table]; // 获取字典的hash表\n            if (iter->index == -1 && iter->table == 0) { // \n                if (iter->safe)\n                    iter->d->iterators++;\n                else // 迭代器是初始化状态，且不安全，那就重新把需要迭代字典的指纹给迭代器\n                    iter->fingerprint = dictFingerprint(iter->d);\n            }\n            iter->index++;\n\t\t\t// 如果迭代器的索引值比字典的索引值还大。如果迭代器迭代的字典正在rehash并迭代器的hash表为空，直接初始化迭代器;否则就停止迭代\n            if (iter->index >= (long) ht->size) {\n                if (dictIsRehashing(iter->d) && iter->table == 0) {\n                    iter->table++;\n                    iter->index = 0;\n                    ht = &iter->d->ht[1];\n                } else {\n                    break;\n                }\n            }\n            iter->entry = ht->table[iter->index];\n        } else { // 表示迭代器已经开始迭代，直接开始遍历字典元素\n            iter->entry = iter->nextEntry;\n        }\n\t\t// 迭代器获取到一个元素，就像这个元素返回，并迭代器的后向指针指向下一个元素\n        if (iter->entry) {\n            /* We need to save the 'next' here, the iterator user\n             * may delete the entry we are returning. */\n            iter->nextEntry = iter->entry->next;\n            return iter->entry;\n        }\n    }\n    return NULL;\n}\n// 释放字典迭代器内存\nvoid dictReleaseIterator(dictIterator *iter)\n{\n    if (!(iter->index == -1 && iter->table == 0)) {\n        if (iter->safe)\n            iter->d->iterators--;\n        else\n            assert(iter->fingerprint == dictFingerprint(iter->d));\n    }\n    zfree(iter);\n}\n\n/* Return a random entry from the hash table. Useful to\n * implement randomized algorithms */\n // 从字典中通过随机的key获取键值对实体\ndictEntry *dictGetRandomKey(dict *d)\n{\n    dictEntry *he, *orighe;\n    unsigned long h;\n    int listlen, listele;\n\n    if (dictSize(d) == 0) return NULL;\n    if (dictIsRehashing(d)) _dictRehashStep(d);\n    if (dictIsRehashing(d)) { // 如果字典正在rehash\n        do {\n            /* We are sure there are no elements in indexes from 0\n             * to rehashidx-1 */\n             // 我们必须确保0到rehashidx-1之内没有元素\n             // 获取随机的索引(必须在rehashidx之后)\n            h = d->rehashidx + (random() % (d->ht[0].size +\n                                            d->ht[1].size -\n                                            d->rehashidx));\n            // 必须要在新表中获取指定随机key在hash表中所在位置的桶\n            he = (h >= d->ht[0].size) ? d->ht[1].table[h - d->ht[0].size] :\n                                      d->ht[0].table[h];\n        } while(he == NULL);\n    } else { // 如果没有rehash,就只需要在字典d中获取key的所在的桶，不需要涉及两个表\n        do {\n            h = random() & d->ht[0].sizemask;\n            he = d->ht[0].table[h];\n        } while(he == NULL);\n    }\n\n    /* Now we found a non empty bucket, but it is a linked\n     * list and we need to get a random element from the list.\n     * The only sane way to do so is counting the elements and\n     * select a random index. */\n    listlen = 0;\n    orighe = he; // 获取到的桶\n    while(he) { // 遍历桶中的链表结构\n        he = he->next;\n        listlen++;\n    }\n    // 从桶中随机得到一个元素\n    listele = random() % listlen;\n    he = orighe;\n    while(listele--) he = he->next;\n    return he;\n}\n\n/* This function samples the dictionary to return a few keys from random\n * locations.\n *\n * It does not guarantee to return all the keys specified in 'count', nor\n * it does guarantee to return non-duplicated elements, however it will make\n * some effort to do both things.\n *\n * Returned pointers to hash table entries are stored into 'des' that\n * points to an array of dictEntry pointers. The array must have room for\n * at least 'count' elements, that is the argument we pass to the function\n * to tell how many random elements we need.\n *\n * The function returns the number of items stored into 'des', that may\n * be less than 'count' if the hash table has less than 'count' elements\n * inside, or if not enough elements were found in a reasonable amount of\n * steps.\n *\n * Note that this function is not suitable when you need a good distribution\n * of the returned items, but only when you need to \"sample\" a given number\n * of continuous elements to run some kind of algorithm or to produce\n * statistics. However the function is much faster than dictGetRandomKey()\n * at producing N elements. */\n /* 从字典d中通过随机的多个key获取键值对实体，存放到des中\n  * d : 目标字典\n  * des : 存放获得的字典实体数组\n  * count: 表示需要随机多少个key\n  * \n  * 获取的键值对限制只有count对，如果通过key获取到的桶有一个count节点数量的链表，那只能获取这count个键值对，那么不能再去获取其他的桶\n  * 如果通过key获取到的每个桶只有一个节点，那可以获取count个桶\n  * 如果字典正在rehash，那只能从新表中取桶\n  */\nunsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count) {\n    unsigned long j; /* internal hash table id, 0 or 1. */ // 哪个表\n    unsigned long tables; /* 1 or 2 tables? */ // 有多少个表\n    unsigned long stored = 0, maxsizemask;\n    unsigned long maxsteps; // 最大需要步数\n\n\t// 如果字典长度小于需要获取的key数量\n    if (dictSize(d) < count) count = dictSize(d);\n    maxsteps = count*10;\n\n    /* Try to do a rehashing work proportional to 'count'. */\n    // 确保需要的key指定的键值对实体在新表中\n    for (j = 0; j < count; j++) {\n        if (dictIsRehashing(d))\n            _dictRehashStep(d);\n        else\n            break;\n    }\n\n\t// 判断是否在rehash\n    tables = dictIsRehashing(d) ? 2 : 1;\n    maxsizemask = d->ht[0].sizemask;\n    // 如果字典正在rehash,就获取新表掩码\n    if (tables > 1 && maxsizemask < d->ht[1].sizemask)\n        maxsizemask = d->ht[1].sizemask;\n\n    /* Pick a random point inside the larger table. */\n    unsigned long i = random() & maxsizemask; // 获取一个随机索引\n    unsigned long emptylen = 0; /* Continuous empty entries so far. */\n    while(stored < count && maxsteps--) {\n        for (j = 0; j < tables; j++) {\n            /* Invariant of the dict.c rehashing: up to the indexes already\n             * visited in ht[0] during the rehashing, there are no populated\n             * buckets, so we can skip ht[0] for indexes between 0 and idx-1. */\n             // 如果获取的随机索引是正在rehash的旧表中，我们需要跳过旧表\n            if (tables == 2 && j == 0 && i < (unsigned long) d->rehashidx) {\n                /* Moreover, if we are currently out of range in the second\n                 * table, there will be no elements in both tables up to\n                 * the current rehashing index, so we jump if possible.\n                 * (this happens when going from big to small table). */\n                 // 如果我们当前范围在第二张表，并且索引值超过了第二张hash表已经rehash了的大小,就会没有元素\n                 // 索引值比新表大小还大，那就让索引值置为rehashidx\n                if (i >= d->ht[1].size)\n                    i = d->rehashidx;\n                else\n                    continue;\n            }\n            if (i >= d->ht[j].size) continue; /* Out of range for this table. */\n            dictEntry *he = d->ht[j].table[i];\n\n            /* Count contiguous empty buckets, and jump to other\n             * locations if they reach 'count' (with a minimum of 5). */\n            if (he == NULL) {\n                emptylen++; // 连续遍历到的空桶数\n                // 空桶数>=5或者大于需要的key数量\n                if (emptylen >= 5 && emptylen > count) {\n                    i = random() & maxsizemask;\n                    emptylen = 0;\n                }\n            } else {\n                emptylen = 0;\n                while (he) { // 获取这个桶中所有的元素\n                    /* Collect all the elements of the buckets found non\n                     * empty while iterating. */\n                    *des = he;\n                    des++;\n                    he = he->next;\n                    stored++;\n                    if (stored == count) return stored;\n                }\n            }\n        }\n        i = (i+1) & maxsizemask;\n    }\n    return stored;\n}\n\n/* Function to reverse bits. Algorithm from:\n * http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel */\n// 颠倒输入的值的bit位\nstatic unsigned long rev(unsigned long v) { // 8 1000\n    unsigned long s = 8 * sizeof(v); // bit size; must be power of 2\n    unsigned long mask = ~0; // 111111111\n    while ((s >>= 1) > 0) {// 每次向右移一位 \n        mask ^= (mask << s);  // 这里是获取\n        v = ((v >> s) & mask) | ((v << s) & ~mask);\n    }\n    return v;\n}\n\n/* dictScan() is used to iterate over the elements of a dictionary.\n *\n * Iterating works the following way:\n *\n * 1) Initially you call the function using a cursor (v) value of 0.\n * 2) The function performs one step of the iteration, and returns the\n *    new cursor value you must use in the next call.\n * 3) When the returned cursor is 0, the iteration is complete.\n *\n * The function guarantees all elements present in the\n * dictionary get returned between the start and end of the iteration.\n * However it is possible some elements get returned multiple times.\n *\n * For every element returned, the callback argument 'fn' is\n * called with 'privdata' as first argument and the dictionary entry\n * 'de' as second argument.\n *\n * HOW IT WORKS.\n *\n * The iteration algorithm was designed by Pieter Noordhuis.\n * The main idea is to increment a cursor starting from the higher order\n * bits. That is, instead of incrementing the cursor normally, the bits\n * of the cursor are reversed, then the cursor is incremented, and finally\n * the bits are reversed again.\n *\n * This strategy is needed because the hash table may be resized between\n * iteration calls.\n *\n * dict.c hash tables are always power of two in size, and they\n * use chaining, so the position of an element in a given table is given\n * by computing the bitwise AND between Hash(key) and SIZE-1\n * (where SIZE-1 is always the mask that is equivalent to taking the rest\n *  of the division between the Hash of the key and SIZE).\n *\n * For example if the current hash table size is 16, the mask is\n * (in binary) 1111. The position of a key in the hash table will always be\n * the last four bits of the hash output, and so forth.\n *\n * WHAT HAPPENS IF THE TABLE CHANGES IN SIZE?\n *\n * If the hash table grows, elements can go anywhere in one multiple of\n * the old bucket: for example let's say we already iterated with\n * a 4 bit cursor 1100 (the mask is 1111 because hash table size = 16).\n *\n * If the hash table will be resized to 64 elements, then the new mask will\n * be 111111. The new buckets you obtain by substituting in ??1100\n * with either 0 or 1 can be targeted only by keys we already visited\n * when scanning the bucket 1100 in the smaller hash table.\n *\n * By iterating the higher bits first, because of the inverted counter, the\n * cursor does not need to restart if the table size gets bigger. It will\n * continue iterating using cursors without '1100' at the end, and also\n * without any other combination of the final 4 bits already explored.\n *\n * Similarly when the table size shrinks over time, for example going from\n * 16 to 8, if a combination of the lower three bits (the mask for size 8\n * is 111) were already completely explored, it would not be visited again\n * because we are sure we tried, for example, both 0111 and 1111 (all the\n * variations of the higher bit) so we don't need to test it again.\n *\n * WAIT... YOU HAVE *TWO* TABLES DURING REHASHING!\n *\n * Yes, this is true, but we always iterate the smaller table first, then\n * we test all the expansions of the current cursor into the larger\n * table. For example if the current cursor is 101 and we also have a\n * larger table of size 16, we also test (0)101 and (1)101 inside the larger\n * table. This reduces the problem back to having only one table, where\n * the larger one, if it exists, is just an expansion of the smaller one.\n *\n * LIMITATIONS\n *\n * This iterator is completely stateless, and this is a huge advantage,\n * including no additional memory used.\n *\n * The disadvantages resulting from this design are:\n *\n * 1) It is possible we return elements more than once. However this is usually\n *    easy to deal with in the application level.\n * 2) The iterator must return multiple elements per call, as it needs to always\n *    return all the keys chained in a given bucket, and all the expansions, so\n *    we are sure we don't miss keys moving during rehashing.\n * 3) The reverse cursor is somewhat hard to understand at first, but this\n *    comment is supposed to help.\n */\n/*\n    * 通过迭代器迭代整个字典\n    * 这篇文章解释的比较清楚：https://blog.csdn.net/gqtcgq/article/details/50533336\n    * 官方给出的解释：https://github.com/antirez/redis/pull/579#issuecomment-16871583\n    * 最高位+1,向低位进位，在字典不稳定的情况下，既要遍历到所有没被删除的元素，又要尽可能较少的重复遍历。这么做是最好的\n    *  hash表的扩容和缩小都是以2的幂次进行的,如果使用这种方法，每次hash表改变时，游标的状态都不会变。游标所遍历的节点大部分都会在改变后表的游标的前面，不用再被遍历。\n    * \n    * 例如：\n    * 每次加法都是最高位+1,向低位进位\n    * hash为8位时：000 -> 100 -> 010 -> 110 -> 001 -> 101 -> 011 -> 111 -> 000\n    * \n    * hash表为16位时：0000 -> 1000 -> 0100 -> 1100 -> 0010 -> 1010 -> 0110 -> \n    * 1110 -> 0001 -> 1001 -> 0101 -> 1101 -> 0011 -> 1011 -> \n    * 0111 -> 1111 -> 0000\n    * \n    * 当我在hash表为8位时，游标是110,我已经遍历了000,100,010;如果hash表扩张到16位，游标在新表中的位置是0110\n    * 看一下游标之前的有哪些，0000,1000,0100,1100,0010,1010;恰好，扩张前已经遍历的都在其中。\n    * \n */\nunsigned long dictScan(dict *d,\n                       unsigned long v,\n                       dictScanFunction *fn,\n                       dictScanBucketFunction* bucketfn,\n                       void *privdata)\n{\n    dictht *t0, *t1;\n    const dictEntry *de, *next;\n    unsigned long m0, m1;\n\n\t// 如果字典大小为0\n    if (dictSize(d) == 0) return 0;\n\n\t// 如果字典没有在rehash,那么只有一个表存在数据\n    if (!dictIsRehashing(d)) {\n        t0 = &(d->ht[0]); // 让指针t0指向字典的hash表\n        m0 = t0->sizemask; // m0表示字典掩码\n\n        /* Emit entries at cursor */\n        // 传入的桶函数指针,如果函数指针指向的函数返回不为NULL\n        if (bucketfn) bucketfn(privdata, &t0->table[v & m0]);\n        de = t0->table[v & m0]; // 指针de指向hash表中的一个桶\n        while (de) { // 迭代桶中的元素\n            next = de->next;\n            fn(privdata, de);\n            de = next;\n        }\n\n        /* Set unmasked bits so incrementing the reversed cursor\n         * operates on the masked bits */\n        v |= ~m0; // v是游标，用来标记字典中迭代的位置\n\n        /* Increment the reverse cursor */\n        v = rev(v); // 将游标化为二进制，并颠倒，让其高位变为低位\n        v++; // 然后+1,这里加的低位是变为低位的高位\n        v = rev(v); // 这里就将加1后的高位重新颠倒回来，这时就变为对高位+1\n\n    } else {\n        t0 = &d->ht[0];\n        t1 = &d->ht[1];\n\n        /* Make sure t0 is the smaller and t1 is the bigger table */\n        if (t0->size > t1->size) {\n            t0 = &d->ht[1];\n            t1 = &d->ht[0];\n        }\n\n        m0 = t0->sizemask;\n        m1 = t1->sizemask;\n\n        /* Emit entries at cursor */\n        if (bucketfn) bucketfn(privdata, &t0->table[v & m0]);\n        de = t0->table[v & m0];\n        while (de) {\n            next = de->next;\n            fn(privdata, de);\n            de = next;\n        }\n\n        /* Iterate over indices in larger table that are the expansion\n         * of the index pointed to by the cursor in the smaller table */\n        do {\n            /* Emit entries at cursor */\n            if (bucketfn) bucketfn(privdata, &t1->table[v & m1]);\n            de = t1->table[v & m1];\n            while (de) {\n                next = de->next;\n                fn(privdata, de);\n                de = next;\n            }\n\n            /* Increment the reverse cursor not covered by the smaller mask.*/\n            v |= ~m1;\n            v = rev(v);\n            v++;\n            v = rev(v);\n\n            /* Continue while bits covered by mask difference is non-zero */\n        } while (v & (m0 ^ m1));\n    }\n\n    return v;\n}\n\n/* ------------------------- private functions ------------------------------ */\n\n/* Expand the hash table if needed */\n// 如果需要的话，扩展hash表\nstatic int _dictExpandIfNeeded(dict *d)\n{\n    /* Incremental rehashing already in progress. Return. */\n    // 如果字典正在rehash,就不需要扩展\n    if (dictIsRehashing(d)) return DICT_OK;\n\t\n    /* If the hash table is empty expand it to the initial size. */\n    // 如果字典大小为0,则为字典扩展默认大小\n    if (d->ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);\n\n    /* If we reached the 1:1 ratio, and we are allowed to resize the hash\n     * table (global setting) or we should avoid it but the ratio between\n     * elements/buckets is over the \"safe\" threshold, we resize doubling\n     * the number of buckets. */\n     // 如果字典被用的元素数大于hash表桶数，并且字典能被改变，或者元素与桶的比率大于平均桶深度\n    if (d->ht[0].used >= d->ht[0].size &&\n        (dict_can_resize ||\n         d->ht[0].used/d->ht[0].size > dict_force_resize_ratio))\n    {\n\t\t// 那么就为字典扩容两倍\n        return dictExpand(d, d->ht[0].used*2);\n    }\n    // 否则就不用扩容\n    return DICT_OK;\n}\n\n/* Our hash table capability is a power of two */\n// hash表的容量是2的次幂，如果输入的size不是2的次幂，就需要将其改造为2的次幂\nstatic unsigned long _dictNextPower(unsigned long size)\n{\n    unsigned long i = DICT_HT_INITIAL_SIZE; // hash表的初始大小\n\n    if (size >= LONG_MAX) return LONG_MAX + 1LU; // 如果给出的大小比最大值还打，则返回最大值\n    while(1) { // \n        if (i >= size)\n            return i;\n        i *= 2;\n    }\n}\n\n/* Returns the index of a free slot that can be populated with\n * a hash entry for the given 'key'.\n * If the key already exists, -1 is returned\n * and the optional output parameter may be filled.\n *\n * Note that if we are in the process of rehashing the hash table, the\n * index is always returned in the context of the second (new) hash table. */\n // 通过需要添加的key获取需要添加的key在字典中的索引\nstatic long _dictKeyIndex(dict *d, const void *key, uint64_t hash, dictEntry **existing)\n{\n    unsigned long idx, table;\n    dictEntry *he;\n    if (existing) *existing = NULL; // 如果existing不为空\n\n    /* Expand the hash table if needed */\n    if (_dictExpandIfNeeded(d) == DICT_ERR)\n        return -1;\n    for (table = 0; table <= 1; table++) {\n        idx = hash & d->ht[table].sizemask; // key的hash值与掩码，获得索引值\n        /* Search if this slot does not already contain the given key */\n        he = d->ht[table].table[idx]; // 通过索引搜索到桶\n        while(he) { // 如果通过索引能获取到桶，就遍历桶中节点，如果存在相同的key，就返回-1,并将相同的实体存储到existing,中表示不能添加这个新key\n            if (key==he->key || dictCompareKeys(d, key, he->key)) {\n                if (existing) *existing = he;\n                return -1;\n            }\n            he = he->next;\n        }\n        if (!dictIsRehashing(d)) break;\n    }\n    // 最终如果没有找到存在的key,就表示新key能被添加，这时就返回索引值\n    return idx;\n}\n\n// 将字典置空\nvoid dictEmpty(dict *d, void(callback)(void*)) {\n\t// 初始化新旧表，rehash索引以及迭代器\n    _dictClear(d,&d->ht[0],callback);\n    _dictClear(d,&d->ht[1],callback);\n    d->rehashidx = -1;\n    d->iterators = 0;\n}\n\n// 设置字典能被改变\nvoid dictEnableResize(void) {\n    dict_can_resize = 1;\n}\n\n// 设置字典禁止被改变\nvoid dictDisableResize(void) {\n    dict_can_resize = 0;\n}\n\n// 字典通过key获取hash值\nuint64_t dictGetHash(dict *d, const void *key) {\n    return dictHashKey(d, key);\n}\n\n/* Finds the dictEntry reference by using pointer and pre-calculated hash.\n * oldkey is a dead pointer and should not be accessed.\n * the hash value should be provided using dictGetHash.\n * no string / key comparison is performed.\n * return value is the reference to the dictEntry if found, or NULL if not found. */\n // 通过指针(指针是死指针，不能被访问)和hash值找到字典中的元素\ndictEntry **dictFindEntryRefByPtrAndHash(dict *d, const void *oldptr, uint64_t hash) {\n    dictEntry *he, **heref;\n    unsigned long idx, table;\n\n    if (d->ht[0].used + d->ht[1].used == 0) return NULL; /* dict is empty */\n    for (table = 0; table <= 1; table++) {\n        idx = hash & d->ht[table].sizemask; // 通过hash找到索引值\n        heref = &d->ht[table].table[idx]; // 通过索引找到hash表中桶\n        he = *heref;\n        while(he) {\n            if (oldptr==he->key) // 如果有与指针对应的key\n                return heref; // 就返回桶\n            heref = &he->next; // 否则重新遍历\n            he = *heref;\n        }\n        if (!dictIsRehashing(d)) return NULL;\n    }\n    return NULL;\n}\n\n/* ------------------------------- Debugging ---------------------------------*/\n\n#define DICT_STATS_VECTLEN 50\nsize_t _dictGetStatsHt(char *buf, size_t bufsize, dictht *ht, int tableid) {\n    unsigned long i, slots = 0, chainlen, maxchainlen = 0;\n    unsigned long totchainlen = 0;\n    unsigned long clvector[DICT_STATS_VECTLEN];\n    size_t l = 0;\n\n    if (ht->used == 0) {\n        return snprintf(buf,bufsize,\n            \"No stats available for empty dictionaries\\n\");\n    }\n\n    /* Compute stats. */\n    for (i = 0; i < DICT_STATS_VECTLEN; i++) clvector[i] = 0;\n    for (i = 0; i < ht->size; i++) {\n        dictEntry *he;\n\n        if (ht->table[i] == NULL) {\n            clvector[0]++;\n            continue;\n        }\n        slots++;\n        /* For each hash entry on this slot... */\n        chainlen = 0;\n        he = ht->table[i];\n        while(he) {\n            chainlen++;\n            he = he->next;\n        }\n        clvector[(chainlen < DICT_STATS_VECTLEN) ? chainlen : (DICT_STATS_VECTLEN-1)]++;\n        if (chainlen > maxchainlen) maxchainlen = chainlen;\n        totchainlen += chainlen;\n    }\n\n    /* Generate human readable stats. */\n    l += snprintf(buf+l,bufsize-l,\n        \"Hash table %d stats (%s):\\n\"\n        \" table size: %ld\\n\"\n        \" number of elements: %ld\\n\"\n        \" different slots: %ld\\n\"\n        \" max chain length: %ld\\n\"\n        \" avg chain length (counted): %.02f\\n\"\n        \" avg chain length (computed): %.02f\\n\"\n        \" Chain length distribution:\\n\",\n        tableid, (tableid == 0) ? \"main hash table\" : \"rehashing target\",\n        ht->size, ht->used, slots, maxchainlen,\n        (float)totchainlen/slots, (float)ht->used/slots);\n\n    for (i = 0; i < DICT_STATS_VECTLEN-1; i++) {\n        if (clvector[i] == 0) continue;\n        if (l >= bufsize) break;\n        l += snprintf(buf+l,bufsize-l,\n            \"   %s%ld: %ld (%.02f%%)\\n\",\n            (i == DICT_STATS_VECTLEN-1)?\">= \":\"\",\n            i, clvector[i], ((float)clvector[i]/ht->size)*100);\n    }\n\n    /* Unlike snprintf(), teturn the number of characters actually written. */\n    if (bufsize) buf[bufsize-1] = '\\0';\n    return strlen(buf);\n}\n\nvoid dictGetStats(char *buf, size_t bufsize, dict *d) {\n    size_t l;\n    char *orig_buf = buf;\n    size_t orig_bufsize = bufsize;\n\n    l = _dictGetStatsHt(buf,bufsize,&d->ht[0],0);\n    buf += l;\n    bufsize -= l;\n    if (dictIsRehashing(d) && bufsize > 0) {\n        _dictGetStatsHt(buf,bufsize,&d->ht[1],1);\n    }\n    /* Make sure there is a NULL term at the end. */\n    if (orig_bufsize) orig_buf[orig_bufsize-1] = '\\0';\n}\n\n/* ------------------------------- Benchmark ---------------------------------*/\n\n#ifdef DICT_BENCHMARK_MAIN\n\n#include \"sds.h\"\n\nuint64_t hashCallback(const void *key) {\n    return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));\n}\n\nint compareCallback(void *privdata, const void *key1, const void *key2) {\n    int l1,l2;\n    DICT_NOTUSED(privdata);\n\n    l1 = sdslen((sds)key1);\n    l2 = sdslen((sds)key2);\n    if (l1 != l2) return 0;\n    return memcmp(key1, key2, l1) == 0;\n}\n\nvoid freeCallback(void *privdata, void *val) {\n    DICT_NOTUSED(privdata);\n\n    sdsfree(val);\n}\n\ndictType BenchmarkDictType = {\n    hashCallback,\n    NULL,\n    NULL,\n    compareCallback,\n    freeCallback,\n    NULL\n};\n\n#define start_benchmark() start = timeInMilliseconds()\n#define end_benchmark(msg) do { \\\n    elapsed = timeInMilliseconds()-start; \\\n    printf(msg \": %ld items in %lld ms\\n\", count, elapsed); \\\n} while(0);\n\n/* dict-benchmark [count] */\nint main(int argc, char **argv) {\n    long j;\n    long long start, elapsed;\n    dict *dict = dictCreate(&BenchmarkDictType,NULL);\n    long count = 0;\n\n    if (argc == 2) {\n        count = strtol(argv[1],NULL,10);\n    } else {\n        count = 5000000;\n    }\n\n    start_benchmark();\n    for (j = 0; j < count; j++) {\n        int retval = dictAdd(dict,sdsfromlonglong(j),(void*)j);\n        assert(retval == DICT_OK);\n    }\n    end_benchmark(\"Inserting\");\n    assert((long)dictSize(dict) == count);\n\n    /* Wait for rehashing. */\n    while (dictIsRehashing(dict)) {\n        dictRehashMilliseconds(dict,100);\n    }\n\n    start_benchmark();\n    for (j = 0; j < count; j++) {\n        sds key = sdsfromlonglong(j);\n        dictEntry *de = dictFind(dict,key);\n        assert(de != NULL);\n        sdsfree(key);\n    }\n    end_benchmark(\"Linear access of existing elements\");\n\n    start_benchmark();\n    for (j = 0; j < count; j++) {\n        sds key = sdsfromlonglong(j);\n        dictEntry *de = dictFind(dict,key);\n        assert(de != NULL);\n        sdsfree(key);\n    }\n    end_benchmark(\"Linear access of existing elements (2nd round)\");\n\n    start_benchmark();\n    for (j = 0; j < count; j++) {\n        sds key = sdsfromlonglong(rand() % count);\n        dictEntry *de = dictFind(dict,key);\n        assert(de != NULL);\n        sdsfree(key);\n    }\n    end_benchmark(\"Random access of existing elements\");\n\n    start_benchmark();\n    for (j = 0; j < count; j++) {\n        sds key = sdsfromlonglong(rand() % count);\n        key[0] = 'X';\n        dictEntry *de = dictFind(dict,key);\n        assert(de == NULL);\n        sdsfree(key);\n    }\n    end_benchmark(\"Accessing missing\");\n\n    start_benchmark();\n    for (j = 0; j < count; j++) {\n        sds key = sdsfromlonglong(j);\n        int retval = dictDelete(dict,key);\n        assert(retval == DICT_OK);\n        key[0] += 17; /* Change first number to letter. */\n        retval = dictAdd(dict,key,(void*)j);\n        assert(retval == DICT_OK);\n    }\n    end_benchmark(\"Removing and adding\");\n}\n#endif\n```","tags":["源码阅读"],"categories":["数据结构"]},{"title":"redis源码阅读-sds(简单动态字符串)","url":"%2F2019%2F12%2F21%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FC%2Fredis%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-sds-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%2F","content":"\n## redis源码阅读-sds(简单动态字符串)\n\n### 介绍\n>> sds是redis定义的代替c语言标准字符串的简单动态字符串\n>> 在redis中，c语言标准字符串通常被作为字面量，而字符串的修改则使用sds来进行\n>> sds字符串有简单的数据结构，可以看作是一个封装类\n\n### sds.h\n```C\n/* SDSLib 2.0 -- A C dynamic strings library\n *\n * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2015, Oran Agra\n * Copyright (c) 2015, Redis Labs, Inc\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/**************************************************\n * redis自己构建的简单动态字符串抽象类型，用来代替c语言传统字符串\n * 在redis中，c字符串只作为字面量，sds用来被表示可被修改的字符串\n **************************************************/\n#ifndef __SDS_H\n#define __SDS_H\n\n// 为sds预留的最大分配内存\n#define SDS_MAX_PREALLOC (1024*1024)\nconst char *SDS_NOINIT;\n\n#include <sys/types.h>\n#include <stdarg.h>\n#include <stdint.h>\n\n// 将char* 指针自定义为sds类型\ntypedef char *sds;\n\n// __attribute__ ((__packed__))关键字 https://blog.csdn.net/weixin_39533180/article/details/76207099\n// 功能： 结构体建立的时候，会进行字节对齐。为了减少内存占用，使用这个关键字取消字节对齐，按照紧凑排列的方式，占用内存\n\n/* Note: sdshdr5 is never used, we just access the flags byte directly.\n * However is here to document the layout of type 5 SDS strings. */\n/**\n * lsb(Linux Standards Base/ least significant bit)和msb(Most Significant Bit)\n * 参考：https://zhidao.baidu.com/question/155072477.html\n * lsb: 最低有效位,msb: 最高有效位,MSB位于二进制数的最左侧，LSB位于二进制数的最右侧。\n *\n * sdshdr使用场景分析 : https://www.codercto.com/a/46648.html\n */\n\n/* sds的五种类型\n * len : sds的长度，不包括结尾结束符\n * alloc : 分配的sds长度,不包括结束符\n * flag: sds类型\n * buf: sds实际存放位置\n */\n// flag低三位保存sds类型，flag高三位保存string长度(buf)\nstruct __attribute__ ((__packed__)) sdshdr5 {\n    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */\n    char buf[];\n};\n// uint8_t: 无符号char (-128~127) char默认是 signed char\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len; /* used */\n    uint8_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n// uint16_t : short int (占2字节)\nstruct __attribute__ ((__packed__)) sdshdr16 {\n    uint16_t len; /* used */\n    uint16_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n// uint32_t : int (占4字节)\nstruct __attribute__ ((__packed__)) sdshdr32 {\n    uint32_t len; /* used */\n    uint32_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n// uint64_t : long int (占8字节)\nstruct __attribute__ ((__packed__)) sdshdr64 {\n    uint64_t len; /* used */\n    uint64_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n\n// 为sds类型定义标志码\n#define SDS_TYPE_5  0\n#define SDS_TYPE_8  1\n#define SDS_TYPE_16 2\n#define SDS_TYPE_32 3\n#define SDS_TYPE_64 4\n#define SDS_TYPE_MASK 7\n#define SDS_TYPE_BITS 3\n\n/**\n * 这三个函数共通的地方就是功能都是为了去除sds类型和结构，获得有效的数据\n *\n * SDS_HDR_VAR(T,s)/SDS_HDR(T,s)\n * T传入的是(5,8,16,32,64),sdshdr##T拼接为sdshdr5,sdshdr8,sdshdr16,sdshdr32,sdshdr64\n * s传入的是字符串\n * (void*)((s)-(sizeof(struct sdshdr##T))) 是为了将字符串的sds结构体所占大小减去，获得字符串实际长度\n *\n * SDS_HDR(T,s)和SDS_HDR_VAR(T,s)区别就是SDS_HDR_VAR(T,s)是需要变量中转，SDS_HDR(T,s)不需要变量中转\n */\n#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));\n#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))\n// f 是传入的flag,(f)>>3表示将3位最低有效位(存储sds类型)消除,获得没有类型的长度\n#define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)\n\n// 获取sds长度\nstatic inline size_t sdslen(const sds s) {\n    unsigned char flags = s[-1];\n    // flag存储的是sds五种类型的二进制 5(0000),8(0001),16(0010),32(0011),64(0100)\n    // flag&SDS_TYPE_MASK = 0000 & 0111 = 0000 ; 最终得到的值就是flag。SDS_TYPE_MASK是屏蔽位，不需要检查的位置0，检查到对应的位对应置1\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return SDS_TYPE_5_LEN(flags);\n        case SDS_TYPE_8:\n            return SDS_HDR(8,s)->len;\n        case SDS_TYPE_16:\n            return SDS_HDR(16,s)->len;\n        case SDS_TYPE_32:\n            return SDS_HDR(32,s)->len;\n        case SDS_TYPE_64:\n            return SDS_HDR(64,s)->len;\n    }\n    return 0;\n}\n\n// 获取sds可用字节数(分配长度-已经分配的长度)\nstatic inline size_t sdsavail(const sds s) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5: {\n            return 0;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            return sh->alloc - sh->len;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            return sh->alloc - sh->len;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            return sh->alloc - sh->len;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            return sh->alloc - sh->len;\n        }\n    }\n    return 0;\n}\n\n// 为sds设置长度\nstatic inline void sdssetlen(sds s, size_t newlen) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5: // sdshdr5没有len属性，不能直接给其赋值,需要按相反的操作来\n            {\n                unsigned char *fp = ((unsigned char*)s)-1;\n                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS); // 加上最低有效位(sds类型)\n            }\n            break;\n        case SDS_TYPE_8:\n            SDS_HDR(8,s)->len = newlen;\n            break;\n        case SDS_TYPE_16:\n            SDS_HDR(16,s)->len = newlen;\n            break;\n        case SDS_TYPE_32:\n            SDS_HDR(32,s)->len = newlen;\n            break;\n        case SDS_TYPE_64:\n            SDS_HDR(64,s)->len = newlen;\n            break;\n    }\n}\n\n// sds在原有基础上增加inc的长度\nstatic inline void sdsinclen(sds s, size_t inc) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            {\n                unsigned char *fp = ((unsigned char*)s)-1;\n                unsigned char newlen = SDS_TYPE_5_LEN(flags)+inc;\n                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);\n            }\n            break;\n        case SDS_TYPE_8:\n            SDS_HDR(8,s)->len += inc;\n            break;\n        case SDS_TYPE_16:\n            SDS_HDR(16,s)->len += inc;\n            break;\n        case SDS_TYPE_32:\n            SDS_HDR(32,s)->len += inc;\n            break;\n        case SDS_TYPE_64:\n            SDS_HDR(64,s)->len += inc;\n            break;\n    }\n}\n\n/* sdsalloc() = sdsavail() + sdslen() */\n// 获取sds分配的内存空间(已用大小+可用大小)\nstatic inline size_t sdsalloc(const sds s) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return SDS_TYPE_5_LEN(flags);\n        case SDS_TYPE_8:\n            return SDS_HDR(8,s)->alloc;\n        case SDS_TYPE_16:\n            return SDS_HDR(16,s)->alloc;\n        case SDS_TYPE_32:\n            return SDS_HDR(32,s)->alloc;\n        case SDS_TYPE_64:\n            return SDS_HDR(64,s)->alloc;\n    }\n    return 0;\n}\n\n// 为sds设置分配大小\nstatic inline void sdssetalloc(sds s, size_t newlen) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            /* Nothing to do, this type has no total allocation info. */\n            break;\n        case SDS_TYPE_8:\n            SDS_HDR(8,s)->alloc = newlen;\n            break;\n        case SDS_TYPE_16:\n            SDS_HDR(16,s)->alloc = newlen;\n            break;\n        case SDS_TYPE_32:\n            SDS_HDR(32,s)->alloc = newlen;\n            break;\n        case SDS_TYPE_64:\n            SDS_HDR(64,s)->alloc = newlen;\n            break;\n    }\n}\n\n// 创建一个sds对象(提供初始值为initlen)\nsds sdsnewlen(const void *init, size_t initlen);\n// 创建sds对象(没有初始值)\nsds sdsnew(const char *init);\n// 置空\nsds sdsempty(void);\n// 复制sds\nsds sdsdup(const sds s);\n// 释放sds分配的内存\nvoid sdsfree(sds s);\n// 如果现在的字符串长度已经是len字节了的话，sdsgrowzero()函数不做任何事情；如果不是，它需要用0字节补齐，把字符串增长到len。\nsds sdsgrowzero(sds s, size_t len);\n// 字符串连接函数\nsds sdscatlen(sds s, const void *t, size_t len); // 定长字符串连接\nsds sdscat(sds s, const char *t); // 以空字符结尾\nsds sdscatsds(sds s, const sds t); // 连接两个sds字符串\n// 字符串复制函数\nsds sdscpylen(sds s, const char *t, size_t len); // 定长复制字符串\nsds sdscpy(sds s, const char *t);\n\nsds sdscatvprintf(sds s, const char *fmt, va_list ap);\n#ifdef __GNUC__\nsds sdscatprintf(sds s, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\n#else\nsds sdscatprintf(sds s, const char *fmt, ...);\n#endif\n\nsds sdscatfmt(sds s, char const *fmt, ...);\nsds sdstrim(sds s, const char *cset);\nvoid sdsrange(sds s, ssize_t start, ssize_t end);\nvoid sdsupdatelen(sds s);\nvoid sdsclear(sds s);\nint sdscmp(const sds s1, const sds s2);\nsds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count);\nvoid sdsfreesplitres(sds *tokens, int count);\nvoid sdstolower(sds s);\nvoid sdstoupper(sds s);\nsds sdsfromlonglong(long long value);\nsds sdscatrepr(sds s, const char *p, size_t len);\nsds *sdssplitargs(const char *line, int *argc);\nsds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);\nsds sdsjoin(char **argv, int argc, char *sep);\nsds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);\n\n/* Low level functions exposed to the user API */\nsds sdsMakeRoomFor(sds s, size_t addlen);\nvoid sdsIncrLen(sds s, ssize_t incr);\nsds sdsRemoveFreeSpace(sds s);\nsize_t sdsAllocSize(sds s);\nvoid *sdsAllocPtr(sds s);\n\n/* Export the allocator used by SDS to the program using SDS.\n * Sometimes the program SDS is linked to, may use a different set of\n * allocators, but may want to allocate or free things that SDS will\n * respectively free or allocate. */\nvoid *sds_malloc(size_t size);\nvoid *sds_realloc(void *ptr, size_t size);\nvoid sds_free(void *ptr);\n\n#ifdef REDIS_TEST\nint sdsTest(int argc, char *argv[]);\n#endif\n\n#endif\n```\n### sdsalloc.h\n```C\n/* SDSLib 2.0 -- A C dynamic strings library\n *\n * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2015, Redis Labs, Inc\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* SDS allocator selection.\n *\n * This file is used in order to change the SDS allocator at compile time.\n * Just define the following defines to what you want to use. Also add\n * the include of your alternate allocator if needed (not needed in order\n * to use the default libc allocator). */\n\n/**\n * 再将zmalloc包装为smalloc\n */\n#include \"zmalloc.h\"\n#define s_malloc zmalloc\n#define s_realloc zrealloc\n#define s_free zfree\n/* SDSLib 2.0 -- A C dynamic strings library\n *\n * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2015, Oran Agra\n * Copyright (c) 2015, Redis Labs, Inc\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/**************************************************\n * redis自己构建的简单动态字符串抽象类型，用来代替c语言传统字符串\n * 在redis中，c字符串只作为字面量，sds用来被表示可被修改的字符串\n **************************************************/\n#ifndef __SDS_H\n#define __SDS_H\n\n// 为sds预留的最大分配内存\n#define SDS_MAX_PREALLOC (1024*1024)\nconst char *SDS_NOINIT;\n\n#include <sys/types.h>\n#include <stdarg.h>\n#include <stdint.h>\n\n// 将char* 指针自定义为sds类型\ntypedef char *sds;\n\n// __attribute__ ((__packed__))关键字 https://blog.csdn.net/weixin_39533180/article/details/76207099\n// 功能： 结构体建立的时候，会进行字节对齐。为了减少内存占用，使用这个关键字取消字节对齐，按照紧凑排列的方式，占用内存\n\n/* Note: sdshdr5 is never used, we just access the flags byte directly.\n * However is here to document the layout of type 5 SDS strings. */\n/**\n * lsb(Linux Standards Base/ least significant bit)和msb(Most Significant Bit)\n * 参考：https://zhidao.baidu.com/question/155072477.html\n * lsb: 最低有效位,msb: 最高有效位,MSB位于二进制数的最左侧，LSB位于二进制数的最右侧。\n *\n * sdshdr使用场景分析 : https://www.codercto.com/a/46648.html\n */\n\n/* sds的五种类型\n * len : sds的长度，不包括结尾结束符\n * alloc : 分配的sds长度,不包括结束符\n * flag: sds类型\n * buf: sds实际存放位置\n */\n// flag低三位保存sds类型，flag高三位保存string长度(buf)\nstruct __attribute__ ((__packed__)) sdshdr5 {\n    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */\n    char buf[];\n};\n// uint8_t: 无符号char (-128~127) char默认是 signed char\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len; /* used */\n    uint8_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n// uint16_t : short int (占2字节)\nstruct __attribute__ ((__packed__)) sdshdr16 {\n    uint16_t len; /* used */\n    uint16_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n// uint32_t : int (占4字节)\nstruct __attribute__ ((__packed__)) sdshdr32 {\n    uint32_t len; /* used */\n    uint32_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n// uint64_t : long int (占8字节)\nstruct __attribute__ ((__packed__)) sdshdr64 {\n    uint64_t len; /* used */\n    uint64_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n\n// 为sds类型定义标志码\n#define SDS_TYPE_5  0\n#define SDS_TYPE_8  1\n#define SDS_TYPE_16 2\n#define SDS_TYPE_32 3\n#define SDS_TYPE_64 4\n#define SDS_TYPE_MASK 7\n#define SDS_TYPE_BITS 3\n\n/**\n * 这三个函数共通的地方就是功能都是为了去除sds类型和结构，获得有效的数据\n *\n * SDS_HDR_VAR(T,s)/SDS_HDR(T,s)\n * T传入的是(5,8,16,32,64),sdshdr##T拼接为sdshdr5,sdshdr8,sdshdr16,sdshdr32,sdshdr64\n * s传入的是字符串\n * (void*)((s)-(sizeof(struct sdshdr##T))) 是为了将字符串的sds结构体所占大小减去，获得字符串实际长度\n *\n * SDS_HDR(T,s)和SDS_HDR_VAR(T,s)区别就是SDS_HDR_VAR(T,s)是需要变量中转，SDS_HDR(T,s)不需要变量中转\n */\n#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));\n#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))\n// f 是传入的flag,(f)>>3表示将3位最低有效位(存储sds类型)消除,获得没有类型的长度\n#define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)\n\n// 获取sds长度\nstatic inline size_t sdslen(const sds s) {\n    unsigned char flags = s[-1];\n    // flag存储的是sds五种类型的二进制 5(0000),8(0001),16(0010),32(0011),64(0100)\n    // flag&SDS_TYPE_MASK = 0000 & 0111 = 0000 ; 最终得到的值就是flag。SDS_TYPE_MASK是屏蔽位，不需要检查的位置0，检查到对应的位对应置1\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return SDS_TYPE_5_LEN(flags);\n        case SDS_TYPE_8:\n            return SDS_HDR(8,s)->len;\n        case SDS_TYPE_16:\n            return SDS_HDR(16,s)->len;\n        case SDS_TYPE_32:\n            return SDS_HDR(32,s)->len;\n        case SDS_TYPE_64:\n            return SDS_HDR(64,s)->len;\n    }\n    return 0;\n}\n\n// 获取sds可用字节数(分配长度-已经分配的长度)\nstatic inline size_t sdsavail(const sds s) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5: {\n            return 0;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            return sh->alloc - sh->len;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            return sh->alloc - sh->len;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            return sh->alloc - sh->len;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            return sh->alloc - sh->len;\n        }\n    }\n    return 0;\n}\n\n// 为sds设置长度\nstatic inline void sdssetlen(sds s, size_t newlen) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5: // sdshdr5没有len属性，不能直接给其赋值,需要按相反的操作来\n            {\n                unsigned char *fp = ((unsigned char*)s)-1;\n                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS); // 加上最低有效位(sds类型)\n            }\n            break;\n        case SDS_TYPE_8:\n            SDS_HDR(8,s)->len = newlen;\n            break;\n        case SDS_TYPE_16:\n            SDS_HDR(16,s)->len = newlen;\n            break;\n        case SDS_TYPE_32:\n            SDS_HDR(32,s)->len = newlen;\n            break;\n        case SDS_TYPE_64:\n            SDS_HDR(64,s)->len = newlen;\n            break;\n    }\n}\n\n// sds在原有基础上增加inc的长度\nstatic inline void sdsinclen(sds s, size_t inc) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            {\n                unsigned char *fp = ((unsigned char*)s)-1;\n                unsigned char newlen = SDS_TYPE_5_LEN(flags)+inc;\n                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);\n            }\n            break;\n        case SDS_TYPE_8:\n            SDS_HDR(8,s)->len += inc;\n            break;\n        case SDS_TYPE_16:\n            SDS_HDR(16,s)->len += inc;\n            break;\n        case SDS_TYPE_32:\n            SDS_HDR(32,s)->len += inc;\n            break;\n        case SDS_TYPE_64:\n            SDS_HDR(64,s)->len += inc;\n            break;\n    }\n}\n\n/* sdsalloc() = sdsavail() + sdslen() */\n// 获取sds分配的内存空间(已用大小+可用大小)\nstatic inline size_t sdsalloc(const sds s) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return SDS_TYPE_5_LEN(flags);\n        case SDS_TYPE_8:\n            return SDS_HDR(8,s)->alloc;\n        case SDS_TYPE_16:\n            return SDS_HDR(16,s)->alloc;\n        case SDS_TYPE_32:\n            return SDS_HDR(32,s)->alloc;\n        case SDS_TYPE_64:\n            return SDS_HDR(64,s)->alloc;\n    }\n    return 0;\n}\n\n// 为sds设置分配大小\nstatic inline void sdssetalloc(sds s, size_t newlen) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            /* Nothing to do, this type has no total allocation info. */\n            break;\n        case SDS_TYPE_8:\n            SDS_HDR(8,s)->alloc = newlen;\n            break;\n        case SDS_TYPE_16:\n            SDS_HDR(16,s)->alloc = newlen;\n            break;\n        case SDS_TYPE_32:\n            SDS_HDR(32,s)->alloc = newlen;\n            break;\n        case SDS_TYPE_64:\n            SDS_HDR(64,s)->alloc = newlen;\n            break;\n    }\n}\n\n// 创建一个sds对象(提供初始值为initlen)\nsds sdsnewlen(const void *init, size_t initlen);\n// 创建sds对象(没有初始值)\nsds sdsnew(const char *init);\n// 置空\nsds sdsempty(void);\n// 复制sds\nsds sdsdup(const sds s);\n// 释放sds分配的内存\nvoid sdsfree(sds s);\n// 如果现在的字符串长度已经是len字节了的话，sdsgrowzero()函数不做任何事情；如果不是，它需要用0字节补齐，把字符串增长到len。\nsds sdsgrowzero(sds s, size_t len);\n// 字符串连接函数\nsds sdscatlen(sds s, const void *t, size_t len); // 定长字符串连接\nsds sdscat(sds s, const char *t); // 以空字符结尾\nsds sdscatsds(sds s, const sds t); // 连接两个sds字符串\n// 字符串复制函数\nsds sdscpylen(sds s, const char *t, size_t len); // 定长复制字符串\nsds sdscpy(sds s, const char *t);\n\nsds sdscatvprintf(sds s, const char *fmt, va_list ap);\n#ifdef __GNUC__\nsds sdscatprintf(sds s, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\n#else\nsds sdscatprintf(sds s, const char *fmt, ...);\n#endif\n\nsds sdscatfmt(sds s, char const *fmt, ...);\nsds sdstrim(sds s, const char *cset);\nvoid sdsrange(sds s, ssize_t start, ssize_t end);\nvoid sdsupdatelen(sds s);\nvoid sdsclear(sds s);\nint sdscmp(const sds s1, const sds s2);\nsds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count);\nvoid sdsfreesplitres(sds *tokens, int count);\nvoid sdstolower(sds s);\nvoid sdstoupper(sds s);\nsds sdsfromlonglong(long long value);\nsds sdscatrepr(sds s, const char *p, size_t len);\nsds *sdssplitargs(const char *line, int *argc);\nsds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);\nsds sdsjoin(char **argv, int argc, char *sep);\nsds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);\n\n/* Low level functions exposed to the user API */\nsds sdsMakeRoomFor(sds s, size_t addlen);\nvoid sdsIncrLen(sds s, ssize_t incr);\nsds sdsRemoveFreeSpace(sds s);\nsize_t sdsAllocSize(sds s);\nvoid *sdsAllocPtr(sds s);\n\n/* Export the allocator used by SDS to the program using SDS.\n * Sometimes the program SDS is linked to, may use a different set of\n * allocators, but may want to allocate or free things that SDS will\n * respectively free or allocate. */\nvoid *sds_malloc(size_t size);\nvoid *sds_realloc(void *ptr, size_t size);\nvoid sds_free(void *ptr);\n\n#ifdef REDIS_TEST\nint sdsTest(int argc, char *argv[]);\n#endif\n\n#endif\n```\n### sds.c\n```C\n/* SDSLib 2.0 -- A C dynamic strings library\n *\n * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2015, Oran Agra\n * Copyright (c) 2015, Redis Labs, Inc\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n#include <limits.h>\n#include \"sds.h\"\n#include \"sdsalloc.h\"\n\nconst char *SDS_NOINIT = \"SDS_NOINIT\";\n\n// 引用sds.h中的SDS_TYPE_系列定义\n// 返回各个sds类型的结构体大小\nstatic inline int sdsHdrSize(char type) {\n    switch(type&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return sizeof(struct sdshdr5);\n        case SDS_TYPE_8:\n            return sizeof(struct sdshdr8);\n        case SDS_TYPE_16:\n            return sizeof(struct sdshdr16);\n        case SDS_TYPE_32:\n            return sizeof(struct sdshdr32);\n        case SDS_TYPE_64:\n            return sizeof(struct sdshdr64);\n    }\n    return 0;\n}\n\n// 通过字符串大小判断该字符串属于哪种sds类型。如果字符串大小小于sds其中一个类型的最大范围，那这个字符串就是这个sds类型的字符串\nstatic inline char sdsReqType(size_t string_size) {\n    if (string_size < 1<<5) // 1<<5表示sdshdr5类型字符串最大范围\n        return SDS_TYPE_5;\n    if (string_size < 1<<8)\n        return SDS_TYPE_8;\n    if (string_size < 1<<16)\n        return SDS_TYPE_16;\n#if (LONG_MAX == LLONG_MAX)\n    if (string_size < 1ll<<32)\n        return SDS_TYPE_32;\n    return SDS_TYPE_64;\n#else\n    return SDS_TYPE_32;\n#endif\n}\n\n/* Create a new sds string with the content specified by the 'init' pointer\n * and 'initlen'.\n * If NULL is used for 'init' the string is initialized with zero bytes.\n * If SDS_NOINIT is used, the buffer is left uninitialized;\n *\n * The string is always null-termined (all the sds strings are, always) so\n * even if you create an sds string with:\n *\n * mystring = sdsnewlen(\"abc\",3);\n *\n * You can print the string with printf() as there is an implicit \\0 at the\n * end of the string. However the string is binary safe and can contain\n * \\0 characters in the middle, as the length is stored in the sds header. */\n// 创建一个initlen长度的sds对象\n/* 创建一个sds字符串的流程\n * 确定sds类型\n * 分配内存\n *\n */\nsds sdsnewlen(const void *init, size_t initlen) {\n    void *sh;\n    sds s;\n    char type = sdsReqType(initlen); // 通过字符串长度判断符合的sds类型\n    /* Empty strings are usually created in order to append. Use type 8\n     * since type 5 is not good at this. */\n    // redis现在已经不再使用sdshdr5类型了\n    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n    int hdrlen = sdsHdrSize(type); // 通过sds类型给initlen加上结构体长度,形成一个完整的sds对象需要的长度\n    unsigned char *fp; /* flags pointer. */ //类型指针\n\n    sh = s_malloc(hdrlen+initlen+1); // 为sds对象分配内存,+1是将空字符也算进去\n    if (init==SDS_NOINIT) // 如果sds没有被初始化，则分配大小为0\n        init = NULL;\n    else if (!init)\n        memset(sh, 0, hdrlen+initlen+1);\n    if (sh == NULL) return NULL;\n    // 指针sh已经分配了hdrlen+initlen+1的空间，现在指针s指向指针sh指向的这个空间中的hdrlen空间部分，就相当于给指针s分配了hdrlen的空间\n    s = (char*)sh+hdrlen;\n    fp = ((unsigned char*)s)-1; // ((unsigned char*)s)-1表示从指针s中划一个字节，分配给指针fp,用来表示sds类型\n    switch(type) { // 判断类型 , 然后为s的各个属性初始化\n        case SDS_TYPE_5: {\n            *fp = type | (initlen << SDS_TYPE_BITS);\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n    }\n    if (initlen && init) // initlen和init都不为空\n        memcpy(s, init, initlen); // 将initlen长度的字符串init复制到s的内存区域,这个直接在内存上操作，不用考虑分配内存\n        // void *memcpy(void *dest, const void *src, size_t n);\n        // 将指针src指向的前initlen字节到dest指定的内存地址上\n    s[initlen] = '\\0'; // 最终以空字符结尾，这表示一个完整的字符串\n    return s;\n}\n\n/* Create an empty (zero length) sds string. Even in this case the string\n * always has an implicit null term. */\n// 使用sdsnewlen创建一个空的sds字符串\nsds sdsempty(void) {\n    return sdsnewlen(\"\",0);\n}\n\n/* Create a new sds string starting from a null terminated C string. */\nsds sdsnew(const char *init) {\n    size_t initlen = (init == NULL) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}\n\n/* Duplicate an sds string. */\n// 复制字符串\nsds sdsdup(const sds s) {\n    return sdsnewlen(s, sdslen(s));\n}\n\n/* Free an sds string. No operation is performed if 's' is NULL. */\n// 释放分配给字符串的内存\nvoid sdsfree(sds s) {\n    if (s == NULL) return;\n    s_free((char*)s-sdsHdrSize(s[-1]));\n}\n\n/* Set the sds string length to the length as obtained with strlen(), so\n * considering as content only up to the first null term character.\n *\n * This function is useful when the sds string is hacked manually in some\n * way, like in the following example:\n *\n * s = sdsnew(\"foobar\");\n * s[2] = '\\0';\n * sdsupdatelen(s);\n * printf(\"%d\\n\", sdslen(s));\n * 最终结果是 2 ； 如果去掉sdsupdatelen(s);字符串的逻辑长度是6.\n * 虽然字符串已经在'\\0'结束，但是没有使用sdsupdatelen重新设置长度，s的'\\0'的后面的字符还存在，但是没有被显示。sdsupdatelen可以将后面不显示的字符串去掉\n * The output will be \"2\", but if we comment out the call to sdsupdatelen()\n * the output will be \"6\" as the string was modified but the logical length\n * remains 6 bytes. */\n// 重新为字符串设置长度\nvoid sdsupdatelen(sds s) {\n    size_t reallen = strlen(s);\n    sdssetlen(s, reallen);\n}\n\n/* Modify an sds string in-place to make it empty (zero length).\n * However all the existing buffer is not discarded but set as free space\n * so that next append operations will not require allocations up to the\n * number of bytes previously available. */\n//将sds长度置0\nvoid sdsclear(sds s) {\n    sdssetlen(s, 0);\n    s[0] = '\\0';\n}\n\n/* Enlarge the free space at the end of the sds string so that the caller\n * is sure that after calling this function can overwrite up to addlen\n * bytes after the end of the string, plus one more byte for nul term.\n *\n * Note: this does not change the *length* of the sds string as returned\n * by sdslen(), but only the free buffer space we have. */\n// 增加sds的长度(增加长度的前提是addlen比sds可用空间大，不然不用增加长度)\nsds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);// 获取可用字节数\n    size_t len, newlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s; // 如果原本字符串的可用字节数比增加的长度大，直接就返回这个字符串，不需要增加长度\n\n    len = sdslen(s); // 获sds字符串s的真实长度(去掉结构所占长度)\n    sh = (char*)s-sdsHdrSize(oldtype); // 这里让指针sh指向纯粹字符串(减去字符串类型的长度的字符串)\n    newlen = (len+addlen); // 这里得到新的字符串的长度\n    if (newlen < SDS_MAX_PREALLOC) // 如果新分配的字符串长度小于sds预分配的长度\n        newlen *= 2; // 就增加一倍\n    else\n        newlen += SDS_MAX_PREALLOC; // 如果大于，就再在新长度基础上加上sds预分配大小\n\n    type = sdsReqType(newlen); // 通过新长度获取sds字符串匹配的类型\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    // 这里抛弃sdshdr5\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type); // 获取新类型的类型长度\n    if (oldtype==type) { // 如果新类型还是和旧类型一样\n        newsh = s_realloc(sh, hdrlen+newlen+1); // 指针指向的内存区块不变，在这个区块之后再分配新长度，直到总长度与hdrlen+newlen+1相等\n        if (newsh == NULL) return NULL; // 如果新分配为空\n        s = (char*)newsh+hdrlen; // 这里先把指针s指向hdrlen位置(将hdrlen分配给了s)\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        // 这里只能重新分配内存\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1); //newsh先分配hdrlen长度的内存存储类型，然后将len+1长度的内存用来存放s,之外还有新增的空闲长度\n        s_free(sh); // 然后释放sh内存\n        s = (char*)newsh+hdrlen; // s指针指向指针newsh指向的内存区域，并将hdrlen长度的内存分配给类型\n        s[-1] = type;\n        sdssetlen(s, len);// 然后给s设置被用的长度\n    }\n    sdssetalloc(s, newlen); // 重新给指针s设置分配的长度\n    return s; // 现在返回的字符串s指向的内存区域已经重新被分配\n}\n\n/* Reallocate the sds string so that it has no free space at the end. The\n * contained string remains not altered, but next concatenation operations\n * will require a reallocation.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\n// 移除空闲空间\nsds sdsRemoveFreeSpace(sds s) {\n    void *sh, *newsh;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen, oldhdrlen = sdsHdrSize(oldtype);\n    size_t len = sdslen(s);// 获得该字符串已用长度\n    size_t avail = sdsavail(s); // 获取可用长度\n    sh = (char*)s-oldhdrlen;//指向剔除类型长度的字符串\n\n    /* Return ASAP if there is no space left. */\n    if (avail == 0) return s; // 如果可用长度为0，表示该字符串没有需要释放的空闲空间\n\n    /* Check what would be the minimum SDS header that is just good enough to\n     * fit this string. */\n    type = sdsReqType(len); // 通过字符串已用长度获取字符串类型\n    hdrlen = sdsHdrSize(type); // 获取类型长度\n\n    /* If the type is the same, or at least a large enough type is still\n     * required, we just realloc(), letting the allocator to do the copy\n     * only if really needed. Otherwise if the change is huge, we manually\n     * reallocate the string to use the different header type. */\n    if (oldtype==type || type > SDS_TYPE_8) { // 如果新类型(剔除空闲长度后的字符串类型)与旧类型相等(包括空闲长度的字符串类型) 或者新类型不是sdshdr5\n        newsh = s_realloc(sh, oldhdrlen+len+1); // 直接在原来的内存基础上缩小为len+1大小的内存\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+oldhdrlen; // 指针sh指向newsh指针指向的地址，并将指针移动到字符串类型长度那里，使得字符串从字符串类型结束开始存入\n    } else {\n        newsh = s_malloc(hdrlen+len+1); // 如果新类型不等于旧类型，就需要重新分配内存\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1); // 将字符串s的内存区域复制给从hdrlen地址开始，长度为len+1的内存区域\n        s_free(sh); // 释放中间指针变量sh内存\n        s = (char*)newsh+hdrlen; // 让指针s指向指针newsh，并将指针游标偏移hdrlen长度，从这里开始存储字符串\n        s[-1] = type; // 在s[-1]存储字符串类型\n        sdssetlen(s, len); // 给s设置被用长度\n    }\n    sdssetalloc(s, len); // 给s设置分配的长度为len(与被用长度一样)，表示空闲空间已被释放\n    return s;\n}\n\n/* Return the total size of the allocation of the specified sds string,\n * including:\n * 1) The sds header before the pointer.\n * 2) The string.\n * 3) The free buffer at the end if any.\n * 4) The implicit null term.\n */\n // 获取分配的长度\nsize_t sdsAllocSize(sds s) {\n    size_t alloc = sdsalloc(s); // 获取分配的长度(未包含字符串类型长度和结尾空字符)\n    return sdsHdrSize(s[-1])+alloc+1;\n}\n\n/* Return the pointer of the actual SDS allocation (normally SDS strings\n * are referenced by the start of the string buffer). */\n// 获取指向分配给字符串的内存的指针\nvoid *sdsAllocPtr(sds s) {\n    return (void*) (s-sdsHdrSize(s[-1]));\n}\n\n/* Increment the sds length and decrements the left free space at the\n * end of the string according to 'incr'. Also set the null term\n * in the new end of the string.\n *\n * This function is used in order to fix the string length after the\n * user calls sdsMakeRoomFor(), writes something after the end of\n * the current string, and finally needs to set the new length.\n *\n * Note: it is possible to use a negative increment in order to\n * right-trim the string.\n *\n * Usage example:\n *\n * Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the\n * following schema, to cat bytes coming from the kernel to the end of an\n * sds string without copying into an intermediate buffer:\n *\n * oldlen = sdslen(s);\n * s = sdsMakeRoomFor(s, BUFFER_SIZE);\n * nread = read(fd, s+oldlen, BUFFER_SIZE);\n * ... check for nread <= 0 and handle it ...\n * sdsIncrLen(s, nread);\n */\n// 增加sds长度\nvoid sdsIncrLen(sds s, ssize_t incr) {\n    unsigned char flags = s[-1];\n    size_t len;\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5: {\n            unsigned char *fp = ((unsigned char*)s)-1;\n            unsigned char oldlen = SDS_TYPE_5_LEN(flags);\n            assert((incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >= (unsigned int)(-incr)));\n            *fp = SDS_TYPE_5 | ((oldlen+incr) << SDS_TYPE_BITS);\n            len = oldlen+incr;\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= (unsigned int)incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= (uint64_t)incr) || (incr < 0 && sh->len >= (uint64_t)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        default: len = 0; /* Just to avoid compilation warnings. */\n    }\n    s[len] = '\\0';\n}\n\n/* Grow the sds to have the specified length. Bytes that were not part of\n * the original length of the sds will be set to zero.\n *\n * if the specified length is smaller than the current length, no operation\n * is performed. */\n// 为sds的空闲空间置0\nsds sdsgrowzero(sds s, size_t len) {\n    size_t curlen = sdslen(s); // 获取sds当前被用的字符长度\n\n    if (len <= curlen) return s; // 如果输入的长度小于当前长度，直接就返回s\n    s = sdsMakeRoomFor(s,len-curlen); // 如果len-curlen长度小于s的空闲长度，则直接返回s;如果大于，就为s增加长度(s的长度就是被用空间+(len-curlen))\n    if (s == NULL) return NULL;\n\n    /* Make sure added region doesn't contain garbage */\n    // 确保增加的内存不包含垃圾\n    memset(s+curlen,0,(len-curlen+1)); /* also set trailing \\0 byte */\n    sdssetlen(s, len); // 将输入的长度设置为新长度\n    return s;\n}\n\n/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the\n * end of the specified sds string 's'.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\n// 将一个字符串与一个空指针类型连接(自定义长度)\nsds sdscatlen(sds s, const void *t, size_t len) {\n    size_t curlen = sdslen(s); // s字符串的被用长度\n\n    s = sdsMakeRoomFor(s,len); // 为字符串s扩充len长度\n    if (s == NULL) return NULL;\n    memcpy(s+curlen, t, len); // 将长度为len的t的内容复制到指针s在curlen地址之后的地址\n    sdssetlen(s, curlen+len); // 为新字符串设置新长度\n    s[curlen+len] = '\\0'; // 空字符结尾\n    return s;\n}\n\n/* Append the specified null termianted C string to the sds string 's'.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\n// 封装了sdscatlen函数，为其len设置默认值\nsds sdscat(sds s, const char *t) {\n    return sdscatlen(s, t, strlen(t));\n}\n\n/* Append the specified sds 't' to the existing sds 's'.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\n// 将两个sds类型连接(空类型被强转为sds类型)\nsds sdscatsds(sds s, const sds t) {\n    return sdscatlen(s, t, sdslen(t));\n}\n\n/* Destructively modify the sds string 's' to hold the specified binary\n * safe string pointed by 't' of length 'len' bytes. */\n// 复制sds\nsds sdscpylen(sds s, const char *t, size_t len) {\n    if (sdsalloc(s) < len) { // 如果sds分配的空间小于len,表示len长度的内存能接受复制内容\n        s = sdsMakeRoomFor(s,len-sdslen(s)); // 将s扩充为len长度,使得两个字符串长度一样\n        if (s == NULL) return NULL;\n    }\n    memcpy(s, t, len); // 内存复制\n    s[len] = '\\0';\n    sdssetlen(s, len); // 为s重新设置长度\n    return s;\n}\n\n/* Like sdscpylen() but 't' must be a null-termined string so that the length\n * of the string is obtained with strlen(). */\n// 封装sdscpylen\nsds sdscpy(sds s, const char *t) {\n    return sdscpylen(s, t, strlen(t));\n}\n\n/* Helper for sdscatlonglong() doing the actual number -> string\n * conversion. 's' must point to a string with room for at least\n * SDS_LLSTR_SIZE bytes.\n *\n * The function returns the length of the null-terminated string\n * representation stored at 's'. */\n#define SDS_LLSTR_SIZE 21\n/*\n\t数值转换，将long long类型的整型转换为字符串,并以'\\0'结尾。最终将字符串存放在s中,返回转换后的长度\n\t函数实现流程：\n\t\t1. 将数值从右到左一位一位转换为字符，存放到指针中\n\t\t2. 如果是负数，加上'-' \n\t\t3. 算出长度，结尾加上'\\0'\n\t\t4. 把字符串反转，使得数值转换成的字符串是从左到右的\n*/\nint sdsll2str(char *s, long long value) {\n    char *p, aux;\n    unsigned long long v;\n    size_t l;\n\n    /* Generate the string representation, this method produces\n     * an reversed string. */\n    v = (value < 0) ? -value : value; // 让value一直是正数\n    p = s; // 指针p指向字符串\n    do {\n        *p++ = '0'+(v%10); // 将整数v的每一位转换为字符串放入指针p中\n        v /= 10;\n    } while(v);\n    if (value < 0) *p++ = '-'; // 如果value小于0,则在p的新的地址的内容中存放-,表示为负数\n\n    /* Compute length and add null term. */\n    // 计算长度和增加结尾空字符\n    l = p-s;\n    *p = '\\0';\n\n    /* Reverse the string. */\n    // 反转字符串\n    p--;\n    while(s < p) {\n        aux = *s;\n        *s = *p;\n        *p = aux;\n        s++;\n        p--;\n    }\n    return l;\n}\n\n/* Identical sdsll2str(), but for unsigned long long type. */\n// 功能与上面函数差不多，只是转换的数值v变成无符号类型，不用考虑是否是正数了\nint sdsull2str(char *s, unsigned long long v) {\n    char *p, aux;\n    size_t l;\n\n    /* Generate the string representation, this method produces\n     * an reversed string. */\n    p = s;\n    do {\n        *p++ = '0'+(v%10);\n        v /= 10;\n    } while(v);\n\n    /* Compute length and add null term. */\n    l = p-s;\n    *p = '\\0';\n\n    /* Reverse the string. */\n    p--;\n    while(s < p) {\n        aux = *s;\n        *s = *p;\n        *p = aux;\n        s++;\n        p--;\n    }\n    return l;\n}\n\n/* Create an sds string from a long long value. It is much faster than:\n *\n * sdscatprintf(sdsempty(),\"%lld\\n\", value);\n */\n // 从long long value数值创建为一个sds字符串\nsds sdsfromlonglong(long long value) {\n    char buf[SDS_LLSTR_SIZE];\n    int len = sdsll2str(buf,value); // 先将数值转换为字符串，存储到buf中,并获取它的长度\n\n    return sdsnewlen(buf,len); // 通过长度和字符串，创建为一个sds字符串\n}\n\n/* Like sdscatprintf() but gets va_list instead of being variadic. */\n/*\n\t将字符串s与格式化字符串连接，最终返回连接后的新sds字符串\n\ta=\"f\"\n\tt = sdscatvprintf(\"abc\" , \"de%s\",a)\n\tt = \"abcdef\"\n*/\n\nsds sdscatvprintf(sds s, const char *fmt, va_list ap) {\n    va_list cpy;\n    char staticbuf[1024], *buf = staticbuf, *t;\n    size_t buflen = strlen(fmt)*2;\n\n    /* We try to start using a static buffer for speed.\n     * If not possible we revert to heap allocation. */\n     // 哪个大就使用哪个\n    if (buflen > sizeof(staticbuf)) { // 如果fmt长度的2倍大于字符数组的大小\n        buf = s_malloc(buflen); // 为buf分配buflen长度的内存\n        if (buf == NULL) return NULL;\n    } else { // 将buflen重置为staticbuf的大小,并且buf指向staticbuf\n        buflen = sizeof(staticbuf);\n    }\n\n    /* Try with buffers two times bigger every time we fail to\n     * fit the string in the current buffer size. */\n    while(1) {\n        buf[buflen-2] = '\\0'; // 将'\\n'清除\n        va_copy(cpy,ap); // 将ap的参数列表复制给cpy\n        vsnprintf(buf, buflen, fmt, cpy); // 将buflen长度的字符串(cpy的参数列表的值被放入fmt格式中，形成一个字符串)输出到buf字符串中\n        va_end(cpy); // cpy参数列表被消除\n        if (buf[buflen-2] != '\\0') { // 如果不是'\\0'表示复制给buf的字符太多了，已经占用了buflen-2位置。这时就需要先释放buf内存，为buf扩容，重新分配内存，重新循环一次。直到buf的容量可以满足fmt字符串\n            if (buf != staticbuf) s_free(buf);\n            buflen *= 2;\n            buf = s_malloc(buflen);\n            if (buf == NULL) return NULL;\n            continue;\n        }\n        break;\n    }\n\n    /* Finally concat the obtained string to the SDS string and return it. */\n    t = sdscat(s, buf); // 将字符s与字符串buf连接为字符串t\n    if (buf != staticbuf) s_free(buf);\n    return t;\n}\n\n/* Append to the sds string 's' a string obtained using printf-alike format\n * specifier.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call.\n *\n * Example:\n *\n * s = sdsnew(\"Sum is: \");\n * s = sdscatprintf(s,\"%d+%d = %d\",a,b,a+b).\n *\n * Often you need to create a string from scratch with the printf-alike\n * format. When this is the need, just use sdsempty() as the target string:\n *\n * s = sdscatprintf(sdsempty(), \"... your format ...\", args);\n */\n // 封装了sdscatvprintf函数\nsds sdscatprintf(sds s, const char *fmt, ...) {\n    va_list ap;\n    char *t;\n    va_start(ap, fmt); // 参数列表ap以fmt的类型为模板\n    t = sdscatvprintf(s,fmt,ap);\n    va_end(ap);\n    return t;\n}\n\n/* This function is similar to sdscatprintf, but much faster as it does\n * not rely on sprintf() family functions implemented by the libc that\n * are often very slow. Moreover directly handling the sds string as\n * new data is concatenated provides a performance improvement.\n *\n * However this function only handles an incompatible subset of printf-alike\n * format specifiers:\n *\n * %s - C String\n * %S - SDS string\n * %i - signed int\n * %I - 64 bit signed integer (long long, int64_t)\n * %u - unsigned int\n * %U - 64 bit unsigned integer (unsigned long long, uint64_t)\n * %% - Verbatim \"%\" character.\n */\n /* 这个函数与sdscatprintf函数相似，但是它不会将字符串打印出来\n  * \n  * sdscatprintf函数依托了vsnprintf函数将fmt格式化，但是这个函数没有引用prinf，因此需要自己实现格式化功能\n  */\nsds sdscatfmt(sds s, char const *fmt, ...) {\n    size_t initlen = sdslen(s); // 获取s字符串长度\n    const char *f = fmt; \n    long i;\n    va_list ap;\n\n    va_start(ap,fmt);\n    f = fmt;    /* Next format specifier byte to process. */\n    i = initlen; /* Position of the next byte to write to dest str. */\n    while(*f) { // 字符串的第一个字符，确定字符串f是否为空\n        char next, *str;\n        size_t l;\n        long long num;\n        unsigned long long unum;\n\n        /* Make sure there is always space for at least 1 char. */\n        if (sdsavail(s)==0) { // 确保s字符串空闲空间最少为l个字符\n            s = sdsMakeRoomFor(s,1);\n        }\n\n        switch(*f) { // 现在f指针指向的字符\n        case '%': // 如果是%,表示有格式化数据需要格式化,那其后面就是需要格式化的类型\n            next = *(f+1);\n            f++;\n            switch(next) { // 看这个格式化类型是什么(s,d,ld,f等等)\n            case 's': // 忽略字符大小写\n            case 'S':\n                str = va_arg(ap,char*); // 将参数列表的参数的值转换为字符串(参数列表是通过指针读取，如果读取一个参数，指针向后偏移，下一次就是读取下一个参数)\n                l = (next == 's') ? strlen(str) : sdslen(str); // 如果是's'(c内置字符串),直接用strlen获取长度;如果是'S'(sds字符串),使用sdslen获取长度\n                if (sdsavail(s) < l) {\n                    s = sdsMakeRoomFor(s,l); // 为s增加可以容纳输入参数字符串长度的空间\n                }\n                memcpy(s+i,str,l); // 将长度为l的参数的值复制到字符串的后面\n                sdsinclen(s,l); // 为字符串s增加长度\n                i += l; // 相应的游标也需要增加l长度\n                break;\n            case 'i': // 如果是有符号整型\n            case 'I':\n                if (next == 'i') // 如果是c内置整型\n                    num = va_arg(ap,int); // 获取当前指针指向的参数列表中的参数，将其值转换为整型\n                else\n                    num = va_arg(ap,long long); // 否则是redis包装的整型，将其转换为long long类型\n                // 代码块中的代码作用域只是这个代码块\n                {\n                    char buf[SDS_LLSTR_SIZE];\n                    l = sdsll2str(buf,num); // 将num转换为字符串，并返回其长度\n                    if (sdsavail(s) < l) {\n                        s = sdsMakeRoomFor(s,l); // 为s增加l的长度\n                    }\n                    memcpy(s+i,buf,l); // 将长度为l的字符串buf复制到s的后面\n                    sdsinclen(s,l); // s长度增加l\n                    i += l; // 游标向后移动l长度\n                }\n                break;\n            case 'u': // 如果是无符号整型,原理和上面的整型一样\n            case 'U':\n                if (next == 'u')\n                    unum = va_arg(ap,unsigned int);\n                else\n                    unum = va_arg(ap,unsigned long long);\n                {\n                    char buf[SDS_LLSTR_SIZE];\n                    l = sdsull2str(buf,unum);\n                    if (sdsavail(s) < l) {\n                        s = sdsMakeRoomFor(s,l);\n                    }\n                    memcpy(s+i,buf,l);\n                    sdsinclen(s,l);\n                    i += l;\n                }\n                break;\n            default: /* Handle %% and generally %<unknown>. */\n                s[i++] = next; // 如果格式化类型是\"%\",表示是不知道的类型，直接将其加入s后面就行了 \n                sdsinclen(s,1); // s的长度相应的增加\n                break;\n            }\n            break;\n        default:\n            s[i++] = *f; // 如果没有遇到格式化i标志\"%\"，那就直接将字符加入到s的后面\n            sdsinclen(s,1);// 并将s的长度增加l\n            break;\n        }\n        f++;\n    }\n    va_end(ap);\n\n    /* Add null-term */\n    s[i] = '\\0'; // 操作完之后为字符串结尾增加空字符表示一个完整的字符串\n    return s;\n}\n\n/* Remove the part of the string from left and from right composed just of\n * contiguous characters found in 'cset', that is a null terminted C string.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call.\n *\n * Example:\n *\n * s = sdsnew(\"AA...AA.a.aa.aHelloWorld     :::\");\n * s = sdstrim(s,\"Aa. :\");\n * printf(\"%s\\n\", s);\n *\n * Output will be just \"HelloWorld\".\n */\n// 移除字符串s的左右指定字符(cset用来进行模式匹配)\nsds sdstrim(sds s, const char *cset) {\n    char *start, *end, *sp, *ep;\n    size_t len;\n\n    sp = start = s;\n    ep = end = s+sdslen(s)-1;\n    // 当指向开始的指针sp指向的内存地址没有超过指向结尾的end指针指向的内存地址，并且指针sp指向地址的内容在cset字符串中有匹配的字符，那么执行开始的指针sp的指针向后偏移一位\n    while(sp <= end && strchr(cset, *sp)) sp++;\n    while(ep > sp && strchr(cset, *ep)) ep--; // 与上面相反，向前偏移\n    len = (sp > ep) ? 0 : ((ep-sp)+1); // 当指向开始的指针sp指向的地址大于指向结尾的指针end指向的地址，表示没有被cset字符串中字符不匹配的字符，那么需要清除就是整个字符串，字符串长度就归0;如果相反，则还有剩余的字符没有被cset匹配，那就输出这些没有匹配的字符串以及其长度\n    if (s != sp) memmove(s, sp, len); // 如果当前字符串指针指向的地址不是sp指针指向的地址，则将以sp指针指向的地址为开始的长度为len的内存区域移动到以指针s指向的地址为开始的内存区\n    s[len] = '\\0';// 字符串以空字符结尾\n    sdssetlen(s,len); // 为字符串设置长度\n    return s;\n}\n\n/* Turn the string into a smaller (or equal) string containing only the\n * substring specified by the 'start' and 'end' indexes.\n *\n * start and end can be negative, where -1 means the last character of the\n * string, -2 the penultimate character, and so forth.\n *\n * The interval is inclusive, so the start and end characters will be part\n * of the resulting string.\n *\n * The string is modified in-place.\n *\n * Example:\n *\n * s = sdsnew(\"Hello World\");\n * sdsrange(s,1,-1); => \"ello World\"\n */\n // 将字符串s中以start为开始位置，以end为结束位置的范围的字符切出来作为子串，重新赋值给s\nvoid sdsrange(sds s, ssize_t start, ssize_t end) {\n    size_t newlen, len = sdslen(s); // 先获取sds字符串的被用长度\n\n    if (len == 0) return; // 如果字符串长度为0\n    \n    //将越界的索引放入索引范围之内\n    if (start < 0) {\n        start = len+start; \n        if (start < 0) start = 0;\n    }\n    if (end < 0) {\n        end = len+end;\n        if (end < 0) end = 0;\n    }\n    \n    // 开始索引大于结束索引，就将新字符串长度置0;否则获取新字符串长度\n    newlen = (start > end) ? 0 : (end-start)+1;\n    if (newlen != 0) {\n\t\t// 这里防止索引不在字符串长度范围内;如果不在，就强制让超出范围的索引包围整个字符串(start=0,end=len-1)\n        if (start >= (ssize_t)len) {\n            newlen = 0;\n        } else if (end >= (ssize_t)len) {\n            end = len-1;\n            newlen = (start > end) ? 0 : (end-start)+1;\n        }\n    } else { // 如果新长度为0,则开始索引置0\n        start = 0;\n    }\n    // 如果开始索引不为0,并且新长度不为0\n    if (start && newlen) memmove(s, s+start, newlen);\n    s[newlen] = 0;\n    sdssetlen(s,newlen);\n}\n\n/* Apply tolower() to every character of the sds string 's'. */\n// 字符串转小写,使用tolower函数\nvoid sdstolower(sds s) {\n    size_t len = sdslen(s), j;\n\n    for (j = 0; j < len; j++) s[j] = tolower(s[j]);\n}\n\n/* Apply toupper() to every character of the sds string 's'. */\n// 字符串转大写，应用toupper函数\nvoid sdstoupper(sds s) {\n    size_t len = sdslen(s), j;\n\n    for (j = 0; j < len; j++) s[j] = toupper(s[j]);\n}\n\n/* Compare two sds strings s1 and s2 with memcmp().\n *\n * Return value:\n *\n *     positive if s1 > s2.\n *     negative if s1 < s2.\n *     0 if s1 and s2 are exactly the same binary string.\n *\n * If two strings share exactly the same prefix, but one of the two has\n * additional characters, the longer string is considered to be greater than\n * the smaller one. */\n // 两个字符串之间比较是否相同\nint sdscmp(const sds s1, const sds s2) {\n    size_t l1, l2, minlen;\n    int cmp;\n\n    l1 = sdslen(s1);\n    l2 = sdslen(s2);\n    minlen = (l1 < l2) ? l1 : l2;\n    cmp = memcmp(s1,s2,minlen); // 比较的是内存区域\n    if (cmp == 0) return l1>l2? 1: (l1<l2? -1: 0);\n    return cmp;\n}\n\n/* Split 's' with separator in 'sep'. An array\n * of sds strings is returned. *count will be set\n * by reference to the number of tokens returned.\n *\n * On out of memory, zero length string, zero length\n * separator, NULL is returned.\n *\n * Note that 'sep' is able to split a string using\n * a multi-character separator. For example\n * sdssplit(\"foo_-_bar\",\"_-_\"); will return two\n * elements \"foo\" and \"bar\".\n *\n * This version of the function is binary-safe but\n * requires length arguments. sdssplit() is just the\n * same function but for zero-terminated strings.\n */\n /* 使用sep字符切分字符串s,返回的是一个字符串数组\n  * const char *s : 表示需要切分的字符串\n  * ssize_t len : 字符串长度\n  * const char *sep : 以该字符串或字符串来切分s\n  * int seplen : sep字符或字符串的长度\n  * int *count : 计数\n  */\nsds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count) {\n    int elements = 0, slots = 5; // elements：切的元素个数\n    long start = 0, j; // start:从哪里开始\n    sds *tokens; // 切分的字符串数组\n\n    if (seplen < 1 || len < 0) return NULL; // 如果切分标志字符串或字符串长度小于0\n\n    tokens = s_malloc(sizeof(sds)*slots); // 为数组分配内存\n    if (tokens == NULL) return NULL;\n\n    if (len == 0) { // 需要切分的长度为0\n        *count = 0;\n        return tokens;\n    }\n    for (j = 0; j < (len-(seplen-1)); j++) {\n        /* make sure there is room for the next element and the final one */\n        // 确保有空间能容纳下一个元素和最后一个元素\n        if (slots < elements+2) { // 如果不能容纳就扩容(两倍)\n            sds *newtokens;\n\n            slots *= 2;\n            newtokens = s_realloc(tokens,sizeof(sds)*slots);\n            if (newtokens == NULL) goto cleanup;\n            tokens = newtokens;\n        }\n        /* search the separator */\n        // 搜索分割符\n        // 如果分割符只是一个字符，直接字符比较就行了\n        // 如果分割符是一个字符串，则需要使用内存比较\n        if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {\n            tokens[elements] = sdsnewlen(s+start,j-start); // 将分割符前的，s当前指针后的字符串赋值给字符数组\n            if (tokens[elements] == NULL) goto cleanup;\n            // 相应的分割的元素个数+1,指针s的游标位置略过分割符，循环标志j也跳过分割符\n            elements++; \n            start = j+seplen;\n            j = j+seplen-1; /* skip the separator */\n        }\n    }\n    /* Add the final element. We are sure there is room in the tokens array. */\n    tokens[elements] = sdsnewlen(s+start,len-start); // 切分完后，需要将最后的元素放入字符数组\n    if (tokens[elements] == NULL) goto cleanup;\n    // *count记录元素总数\n    elements++;\n    *count = elements;\n    return tokens;\n\n// goto语句跳转的代码块，用来初始化\ncleanup:\n    {\n        int i;\n        for (i = 0; i < elements; i++) sdsfree(tokens[i]);\n        s_free(tokens);\n        *count = 0;\n        return NULL;\n    }\n}\n\n/* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */\n// 用来释放sdssplitlen函数产生的字符串数组中指定的字符串元素内存\nvoid sdsfreesplitres(sds *tokens, int count) {\n    if (!tokens) return;\n    while(count--)\n        sdsfree(tokens[count]);\n    s_free(tokens);\n}\n\n/* Append to the sds string \"s\" an escaped string representation where\n * all the non-printable characters (tested with isprint()) are turned into\n * escapes in the form \"\\n\\r\\a....\" or \"\\x<hex-number>\".\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\n // 将转义字符一起连接打印(*p输入的是转义字符),用来解决sdscatprintf函数的局限\nsds sdscatrepr(sds s, const char *p, size_t len) {\n    s = sdscatlen(s,\"\\\"\",1); // 使用双引号将转义字符包围\n    while(len--) {\n        switch(*p) {\n        case '\\\\': // 如果输入的是\\和\", 可以通过变量输入，不用转义\n        case '\"':\n            s = sdscatprintf(s,\"\\\\%c\",*p);\n            break;\n        // 其他的转义字符就不能通过变量输入，就需要使用sdscatlen函数手动转义\n        case '\\n': s = sdscatlen(s,\"\\\\n\",2); break;\n        case '\\r': s = sdscatlen(s,\"\\\\r\",2); break;\n        case '\\t': s = sdscatlen(s,\"\\\\t\",2); break;\n        case '\\a': s = sdscatlen(s,\"\\\\a\",2); break;\n        case '\\b': s = sdscatlen(s,\"\\\\b\",2); break;\n        default:// 如果输入的不是转义字符，就直接使用sdscatprintf函数打印\n            if (isprint(*p)) \n                s = sdscatprintf(s,\"%c\",*p);\n            else\n                s = sdscatprintf(s,\"\\\\x%02x\",(unsigned char)*p);\n            break;\n        }\n        p++;\n    }\n    return sdscatlen(s,\"\\\"\",1); // 用后引号包围\n}\n\n/* Helper function for sdssplitargs() that returns non zero if 'c'\n * is a valid hex digit. */\n // 判断是否是16进制\nint is_hex_digit(char c) {\n    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||\n           (c >= 'A' && c <= 'F');\n}\n\n/* Helper function for sdssplitargs() that converts a hex digit into an\n * integer from 0 to 15 */\n // 将16进制转换为10进制\nint hex_digit_to_int(char c) {\n    switch(c) {\n    case '0': return 0;\n    case '1': return 1;\n    case '2': return 2;\n    case '3': return 3;\n    case '4': return 4;\n    case '5': return 5;\n    case '6': return 6;\n    case '7': return 7;\n    case '8': return 8;\n    case '9': return 9;\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    default: return 0;\n    }\n}\n\n/* Split a line into arguments, where every argument can be in the\n * following programming-language REPL-alike form:\n *\n * foo bar \"newline are supported\\n\" and \"\\xff\\x00otherstuff\"\n *\n * The number of arguments is stored into *argc, and an array\n * of sds is returned.\n *\n * The caller should free the resulting array of sds strings with\n * sdsfreesplitres().\n *\n * Note that sdscatrepr() is able to convert back a string into\n * a quoted string in the same format sdssplitargs() is able to parse.\n *\n * The function returns the allocated tokens on success, even when the\n * input string is empty, or NULL if the input contains unbalanced\n * quotes or closed quotes followed by non space characters\n * as in: \"foo\"bar or \"foo'\n */\n // *line表示一个参数行，通过空格隔开;argc存储这个参数行每个参数的索引号\nsds *sdssplitargs(const char *line, int *argc) {\n    const char *p = line;\n    char *current = NULL;\n    char **vector = NULL; // 一个存放字符串的一个向量\n\n    *argc = 0;// 第一个索引\n    while(1) {\n        /* skip blanks */\n        while(*p && isspace(*p)) p++; // 如果当前指针游标指向的字符是空格，就跳过\n        if (*p) {\n            /* get a token */\n            int inq=0;  /* set to 1 if we are in \"quotes\" */ // 如果在双引号中设为1\n            int insq=0; /* set to 1 if we are in 'single quotes' */ // 如果p在单引号中设为1\n            int done=0;\n\n            if (current == NULL) current = sdsempty();\n            while(!done) {\n                if (inq) { // 如果p在双引号中,有16进制就转换为字符串\n\t\t\t\t\t// 如果p是转义字符，并且p的下一个是x,再下一个是16进制(\\x19就是一个16进制)\n                    if (*p == '\\\\' && *(p+1) == 'x' &&\n                                             is_hex_digit(*(p+2)) &&\n                                             is_hex_digit(*(p+3)))\n                    {\n                        unsigned char byte;\n\t\t\t\t\t\t// 将16进制转换为10进制再相加，得到一个字符\n                        byte = (hex_digit_to_int(*(p+2))*16)+\n                                hex_digit_to_int(*(p+3));\n                        current = sdscatlen(current,(char*)&byte,1);//将这个字符连接到字符串后面\n                        p += 3; // 指针游标向后偏移三位\n                    } else if (*p == '\\\\' && *(p+1)) { // 如果是转义字符\n                        char c;\n\n                        p++;\n                        // 将转义字符转义为普通字符\n                        switch(*p) {\n                        case 'n': c = '\\n'; break;\n                        case 'r': c = '\\r'; break;\n                        case 't': c = '\\t'; break;\n                        case 'b': c = '\\b'; break;\n                        case 'a': c = '\\a'; break;\n                        default: c = *p; break;\n                        }\n                        current = sdscatlen(current,&c,1); // 将转义字符连接到字符串后面\n                    } else if (*p == '\"') { // 如果再遇到双引号，就完成\n                        /* closing quote must be followed by a space or\n                         * nothing at all. */\n                         // 如果指针的下一个内容不为NULL，并且其不是一个空格,那就报错\n                        if (*(p+1) && !isspace(*(p+1))) goto err;\n                        done=1;\n                    } else if (!*p) { // 没有定义闭合双引号\n                        /* unterminated quotes */\n                        goto err;\n                    } else { // 否则是正常字符\n                        current = sdscatlen(current,p,1);\n                    }\n                } else if (insq) { // 如果是单引号，处理方法与处理双引号一样\n                    if (*p == '\\\\' && *(p+1) == '\\'') {\n                        p++;\n                        current = sdscatlen(current,\"'\",1);\n                    } else if (*p == '\\'') {\n                        /* closing quote must be followed by a space or\n                         * nothing at all. */\n                        if (*(p+1) && !isspace(*(p+1))) goto err;\n                        done=1;\n                    } else if (!*p) {\n                        /* unterminated quotes */\n                        goto err;\n                    } else {\n                        current = sdscatlen(current,p,1);\n                    }\n                } else { // 如果没有双引号和单引号\n                    switch(*p) {\n                    case ' ': // 遇到转义符号就需要结束\n                    case '\\n':\n                    case '\\r':\n                    case '\\t':\n                    case '\\0':\n                        done=1;\n                        break;\n                    case '\"': // 如果遇到双引号\n                        inq=1;\n                        break;\n                    case '\\'': // 如果遇到单引号\n                        insq=1;\n                        break;\n                    default: // 否则就是普通字符\n                        current = sdscatlen(current,p,1);\n                        break;\n                    }\n                }\n                if (*p) p++; // 只要p不为空，就接着遍历\n            }\n            /* add the token to the vector */\n            // 为向量分配内存\n            vector = s_realloc(vector,((*argc)+1)*sizeof(char*));\n            vector[*argc] = current; // 将元素放入向量中\n            (*argc)++;\n            current = NULL;\n        } else {// 到达一行结尾，如果向量还没有存入元素，不能让向量返回NULL，也需要为向量分配内存空间\n            /* Even on empty input string return something not NULL. */\n            if (vector == NULL) vector = s_malloc(sizeof(void*));\n            return vector;\n        }\n    }\n// 如果遇到错误就释放内存，向量返回NULL\nerr:\n    while((*argc)--)\n        sdsfree(vector[*argc]);\n    s_free(vector);\n    if (current) sdsfree(current);\n    *argc = 0;\n    return NULL;\n}\n\n/* Modify the string substituting all the occurrences of the set of\n * characters specified in the 'from' string to the corresponding character\n * in the 'to' array.\n *\n * For instance: sdsmapchars(mystring, \"ho\", \"01\", 2)\n * will have the effect of turning the string \"hello\" into \"0ell1\".\n *\n * The function returns the sds string pointer, that is always the same\n * as the input pointer since no resize is needed. */\n // 将字符串s中的from字符串根据to字符串按顺序替换\nsds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {\n    size_t j, i, l = sdslen(s);\n\n    for (j = 0; j < l; j++) {\n        for (i = 0; i < setlen; i++) {\n            if (s[j] == from[i]) {\n                s[j] = to[i];\n                break;\n            }\n        }\n    }\n    return s;\n}\n\n/* Join an array of C strings using the specified separator (also a C string).\n * Returns the result as an sds string. */\n /* 将标准C字符串连接为sds字符串\n  * **argv: [\"aaa\" , \"bbb\" , \"ccc\"]\n  * *sep : \"-\"\n  * argc: 3 \n  * result : \"aaa-bbb-ccc\"\n  */\nsds sdsjoin(char **argv, int argc, char *sep) {\n    sds join = sdsempty(); // 得到一个空的sds字符串\n    int j;\n\n    for (j = 0; j < argc; j++) { \n        join = sdscat(join, argv[j]); // 将字符串数组中的字符串连接到join字符串后面\n        if (j != argc-1) join = sdscat(join,sep); // 每个数组中的字符串以分割符sep连接\n    }\n    return join;\n}\n\n/* Like sdsjoin, but joins an array of SDS strings. */\n//将sds字符串数组中的sds字符串连接为一个字符串;与sdsjoin功能相似\nsds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {\n    sds join = sdsempty();\n    int j;\n\n    for (j = 0; j < argc; j++) {\n        join = sdscatsds(join, argv[j]);\n        if (j != argc-1) join = sdscatlen(join,sep,seplen);\n    }\n    return join;\n}\n\n/* Wrappers to the allocators used by SDS. Note that SDS will actually\n * just use the macros defined into sdsalloc.h in order to avoid to pay\n * the overhead of function calls. Here we define these wrappers only for\n * the programs SDS is linked to, if they want to touch the SDS internals\n * even if they use a different allocator. */\n // 封装的sds分配内存函数(相当与继承自s_系列分配函数,而s_系列又是继承自z_系列，z_系列又是继承自系统分配函数)\nvoid *sds_malloc(size_t size) { return s_malloc(size); }\nvoid *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }\nvoid sds_free(void *ptr) { s_free(ptr); }\n\n// 下面是用来测试的,也是上面函数的使用方法，如果不清楚上面函数怎么使用，可以参考一下\n#if defined(SDS_TEST_MAIN)\n#include <stdio.h>\n#include \"testhelp.h\"\n#include \"limits.h\"\n\n#define UNUSED(x) (void)(x)\nint sdsTest(void) {\n    {\n        sds x = sdsnew(\"foo\"), y;\n\n        test_cond(\"Create a string and obtain the length\",\n            sdslen(x) == 3 && memcmp(x,\"foo\\0\",4) == 0)\n\n        sdsfree(x);\n        x = sdsnewlen(\"foo\",2);\n        test_cond(\"Create a string with specified length\",\n            sdslen(x) == 2 && memcmp(x,\"fo\\0\",3) == 0)\n\n        x = sdscat(x,\"bar\");\n        test_cond(\"Strings concatenation\",\n            sdslen(x) == 5 && memcmp(x,\"fobar\\0\",6) == 0);\n\n        x = sdscpy(x,\"a\");\n        test_cond(\"sdscpy() against an originally longer string\",\n            sdslen(x) == 1 && memcmp(x,\"a\\0\",2) == 0)\n\n        x = sdscpy(x,\"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\");\n        test_cond(\"sdscpy() against an originally shorter string\",\n            sdslen(x) == 33 &&\n            memcmp(x,\"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\\0\",33) == 0)\n\n        sdsfree(x);\n        x = sdscatprintf(sdsempty(),\"%d\",123);\n        test_cond(\"sdscatprintf() seems working in the base case\",\n            sdslen(x) == 3 && memcmp(x,\"123\\0\",4) == 0)\n\n        sdsfree(x);\n        x = sdsnew(\"--\");\n        x = sdscatfmt(x, \"Hello %s World %I,%I--\", \"Hi!\", LLONG_MIN,LLONG_MAX);\n        test_cond(\"sdscatfmt() seems working in the base case\",\n            sdslen(x) == 60 &&\n            memcmp(x,\"--Hello Hi! World -9223372036854775808,\"\n                     \"9223372036854775807--\",60) == 0)\n        printf(\"[%s]\\n\",x);\n\n        sdsfree(x);\n        x = sdsnew(\"--\");\n        x = sdscatfmt(x, \"%u,%U--\", UINT_MAX, ULLONG_MAX);\n        test_cond(\"sdscatfmt() seems working with unsigned numbers\",\n            sdslen(x) == 35 &&\n            memcmp(x,\"--4294967295,18446744073709551615--\",35) == 0)\n\n        sdsfree(x);\n        x = sdsnew(\" x \");\n        sdstrim(x,\" x\");\n        test_cond(\"sdstrim() works when all chars match\",\n            sdslen(x) == 0)\n\n        sdsfree(x);\n        x = sdsnew(\" x \");\n        sdstrim(x,\" \");\n        test_cond(\"sdstrim() works when a single char remains\",\n            sdslen(x) == 1 && x[0] == 'x')\n\n        sdsfree(x);\n        x = sdsnew(\"xxciaoyyy\");\n        sdstrim(x,\"xy\");\n        test_cond(\"sdstrim() correctly trims characters\",\n            sdslen(x) == 4 && memcmp(x,\"ciao\\0\",5) == 0)\n\n        y = sdsdup(x);\n        sdsrange(y,1,1);\n        test_cond(\"sdsrange(...,1,1)\",\n            sdslen(y) == 1 && memcmp(y,\"i\\0\",2) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,1,-1);\n        test_cond(\"sdsrange(...,1,-1)\",\n            sdslen(y) == 3 && memcmp(y,\"iao\\0\",4) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,-2,-1);\n        test_cond(\"sdsrange(...,-2,-1)\",\n            sdslen(y) == 2 && memcmp(y,\"ao\\0\",3) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,2,1);\n        test_cond(\"sdsrange(...,2,1)\",\n            sdslen(y) == 0 && memcmp(y,\"\\0\",1) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,1,100);\n        test_cond(\"sdsrange(...,1,100)\",\n            sdslen(y) == 3 && memcmp(y,\"iao\\0\",4) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,100,100);\n        test_cond(\"sdsrange(...,100,100)\",\n            sdslen(y) == 0 && memcmp(y,\"\\0\",1) == 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"foo\");\n        y = sdsnew(\"foa\");\n        test_cond(\"sdscmp(foo,foa)\", sdscmp(x,y) > 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"bar\");\n        y = sdsnew(\"bar\");\n        test_cond(\"sdscmp(bar,bar)\", sdscmp(x,y) == 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"aar\");\n        y = sdsnew(\"bar\");\n        test_cond(\"sdscmp(bar,bar)\", sdscmp(x,y) < 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnewlen(\"\\a\\n\\0foo\\r\",7);\n        y = sdscatrepr(sdsempty(),x,sdslen(x));\n        test_cond(\"sdscatrepr(...data...)\",\n            memcmp(y,\"\\\"\\\\a\\\\n\\\\x00foo\\\\r\\\"\",15) == 0)\n\n        {\n            unsigned int oldfree;\n            char *p;\n            int step = 10, j, i;\n\n            sdsfree(x);\n            sdsfree(y);\n            x = sdsnew(\"0\");\n            test_cond(\"sdsnew() free/len buffers\", sdslen(x) == 1 && sdsavail(x) == 0);\n\n            /* Run the test a few times in order to hit the first two\n             * SDS header types. */\n            for (i = 0; i < 10; i++) {\n                int oldlen = sdslen(x);\n                x = sdsMakeRoomFor(x,step);\n                int type = x[-1]&SDS_TYPE_MASK;\n\n                test_cond(\"sdsMakeRoomFor() len\", sdslen(x) == oldlen);\n                if (type != SDS_TYPE_5) {\n                    test_cond(\"sdsMakeRoomFor() free\", sdsavail(x) >= step);\n                    oldfree = sdsavail(x);\n                }\n                p = x+oldlen;\n                for (j = 0; j < step; j++) {\n                    p[j] = 'A'+j;\n                }\n                sdsIncrLen(x,step);\n            }\n            test_cond(\"sdsMakeRoomFor() content\",\n                memcmp(\"0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ\",x,101) == 0);\n            test_cond(\"sdsMakeRoomFor() final length\",sdslen(x)==101);\n\n            sdsfree(x);\n        }\n    }\n    test_report()\n    return 0;\n}\n#endif\n\n#ifdef SDS_TEST_MAIN\nint main(void) {\n    return sdsTest();\n}\n#endif\n```","tags":["源码阅读"],"categories":["数据结构"]},{"title":"redis源码阅读-atomicvar(原子操作)","url":"%2F2019%2F12%2F16%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FC%2Fredis%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-atomicvar-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%2F","content":"\n## redis源码阅读-atomicvar(原子操作)\n\n### atomicvar介绍\n  + atomicvar是redis封装的原子操作函数。其中包括了三种原子操作方法，gcc提供的內建\\_\\_atomic和\\_\\_sync,mutex函数族以及pthread线程库提供的mutex系列函数。\n  + 原子操作主要是争对多线程下的线程安全。\n### atomicvar.h\n```C\n/* This file implements atomic counters using __atomic or __sync macros if\n    * available, otherwise synchronizing different threads using a mutex.\n    *\n    * The exported interface is composed of three macros:\n    *\n    * atomicIncr(var,count) -- Increment the atomic counter\n    * atomicGetIncr(var,oldvalue_var,count) -- Get and increment the atomic counter\n    * atomicDecr(var,count) -- Decrement the atomic counter\n    * atomicGet(var,dstvar) -- Fetch the atomic counter value\n    * atomicSet(var,value)  -- Set the atomic counter value\n    *\n    * The variable 'var' should also have a declared mutex with the same\n    * name and the \"_mutex\" postfix, for instance:\n    *\n    *  long myvar;\n    *  pthread_mutex_t myvar_mutex;\n    *  atomicSet(myvar,12345);\n    *\n    * If atomic primitives are available (tested in config.h) the mutex\n    * is not used.\n    *\n    * Never use return value from the macros, instead use the AtomicGetIncr()\n    * if you need to get the current value and increment it atomically, like\n    * in the followign example:\n    *\n    *  long oldvalue;\n    *  atomicGetIncr(myvar,oldvalue,1);\n    *  doSomethingWith(oldvalue);\n    *\n    * ----------------------------------------------------------------------------\n    *\n    * Copyright (c) 2015, Salvatore Sanfilippo <antirez at gmail dot com>\n    * All rights reserved.\n    *\n    * Redistribution and use in source and binary forms, with or without\n    * modification, are permitted provided that the following conditions are met:\n    *\n    *   * Redistributions of source code must retain the above copyright notice,\n    *     this list of conditions and the following disclaimer.\n    *   * Redistributions in binary form must reproduce the above copyright\n    *     notice, this list of conditions and the following disclaimer in the\n    *     documentation and/or other materials provided with the distribution.\n    *   * Neither the name of Redis nor the names of its contributors may be used\n    *     to endorse or promote products derived from this software without\n    *     specific prior written permission.\n    *\n    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n    * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n    * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n    * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n    * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n    * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n    * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n    * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n    * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    * POSSIBILITY OF SUCH DAMAGE.\n    */\n/***********************************************************************************\n    * 实现gcc内置函数(__atomic和__sync),实现线程的原子操作\n    * redis定义了__atomic,__sync,mutex三种原子操作方法，最多使用的是__atomic或者__sync(__atomic是用于替代__sync函数的，现在大多数使用__atomic进行原子操作),不能使用时就可以选择mutex(线程互斥量)\n    * 参考文档：\n    *  官方手册：https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html#g_t_005f_005fatomic-Builtins\n    *  gcc的原子操作：https://blog.csdn.net/qq_22660775/article/details/88806716\n    *\n    * 提供函数：\n    *  atomicIncr(var,count) -- 增加原子计数器\n    *  atomicGetIncr(var,oldvalue_var,count) -- 获取并增加原子计数器\n    *  atomicDecr(var,count) -- 减少原子计数器\n    *  atomicGet(var,dstvar) -- 获取原子计数器的值\n    *  atomicSet(var,value)  -- 设置原子计数器的值\n    ***********************************************************************************/\n#include <pthread.h> // 提供操作线程的函数原型\n#ifndef __ATOMIC_VAR_H\n#define __ATOMIC_VAR_H\n/* To test Redis with Helgrind (a Valgrind tool) it is useful to define\n    * the following macro, so that __sync macros are used: those can be detected\n    * by Helgrind (even if they are less efficient) so that no false positive\n    * is reported. */\n// #define __ATOMIC_VAR_FORCE_SYNC_MACROS\n// Helgrind用于检查线程中出现的竞争问题，在这里被用于检测定义的宏是否有用\n// 如果没有定义__ATOMIC_VAR_FORCE_SYNC_MACROS(强制使用__sync)并且定义了__atomic\n// 如果没有使用sun,mac(版本在4210057之上的mac例外)系列操作系统，clang编译器\n// 满足以上条件就使用__atomic宏进行原子操作\n#if !defined(__ATOMIC_VAR_FORCE_SYNC_MACROS) && defined(__ATOMIC_RELAXED) && !defined(__sun) && (!defined(__clang__) || !defined(__APPLE__) || __apple_build_version__ > 4210057)\n/* Implementation using __atomic macros. */\n// type __atomic_add_fetch (type *ptr, type val, int memorder) 原子加操作(先增加后提交)\n// type *ptr 要修改的原子对象指针\n// type val 要添加到存储在原子对象中的值的值\n// int memorder 此操作的内存同步排序：所有值都是允许的\n// 参考：https://m.php.cn/manual/view/34159.html\n#define atomicIncr(var,count) __atomic_add_fetch(&var,(count),__ATOMIC_RELAXED)\n// 先提交修改，然后增加原子计数器并返回原子计数器\n#define atomicGetIncr(var,oldvalue_var,count) do { \\\n    oldvalue_var = __atomic_fetch_add(&var,(count),__ATOMIC_RELAXED); \\\n} while(0)\n    // 先减再提交\n#define atomicDecr(var,count) __atomic_sub_fetch(&var,(count),__ATOMIC_RELAXED)\n// 以原子方式加载，并返回原子原子变量的当前值\n#define atomicGet(var,dstvar) do { \\\n    dstvar = __atomic_load_n(&var,__ATOMIC_RELAXED); \\\n} while(0)\n// 将value值存储到原子对象(&var)的值中\n#define atomicSet(var,value) __atomic_store_n(&var,value,__ATOMIC_RELAXED)\n#define REDIS_ATOMIC_API \"atomic-builtin\"\n#elif defined(HAVE_ATOMIC)\n/* Implementation using __sync macros. */\n// 与上诉方法差不多，只是底层实现使用__sync来实现\n#define atomicIncr(var,count) __sync_add_and_fetch(&var,(count))\n#define atomicGetIncr(var,oldvalue_var,count) do { \\\n    oldvalue_var = __sync_fetch_and_add(&var,(count)); \\\n} while(0)\n#define atomicDecr(var,count) __sync_sub_and_fetch(&var,(count))\n#define atomicGet(var,dstvar) do { \\\n    dstvar = __sync_sub_and_fetch(&var,0); \\\n} while(0)\n#define atomicSet(var,value) do { \\\n    while(!__sync_bool_compare_and_swap(&var,var,value)); \\\n} while(0)\n#define REDIS_ATOMIC_API \"sync-builtin\"\n#else\n/* Implementation using pthread mutex. */\n// 使用mutex来实现\n// &var ## _mutex : 将传入的原子对象变量值与_mutex连接，使_mutex作为后缀\n// int pthread_mutex_lock(pthread_mutex_t *mutex); // 通过线程互斥量来加锁,之后就对数值var进行加减等操作，完了就解锁\n#define atomicIncr(var,count) do { \\\n    pthread_mutex_lock(&var ## _mutex); \\\n    var += (count); \\\n    pthread_mutex_unlock(&var ## _mutex); \\\n} while(0)\n#define atomicGetIncr(var,oldvalue_var,count) do { \\\n    pthread_mutex_lock(&var ## _mutex); \\\n    oldvalue_var = var; \\\n    var += (count); \\\n    pthread_mutex_unlock(&var ## _mutex); \\\n} while(0)\n#define atomicDecr(var,count) do { \\\n    pthread_mutex_lock(&var ## _mutex); \\\n    var -= (count); \\\n    pthread_mutex_unlock(&var ## _mutex); \\\n} while(0)\n#define atomicGet(var,dstvar) do { \\\n    pthread_mutex_lock(&var ## _mutex); \\\n    dstvar = var; \\\n    pthread_mutex_unlock(&var ## _mutex); \\\n} while(0)\n#define atomicSet(var,value) do { \\\n    pthread_mutex_lock(&var ## _mutex); \\\n    var = value; \\\n    pthread_mutex_unlock(&var ## _mutex); \\\n} while(0)\n#define REDIS_ATOMIC_API \"pthread-mutex\"\n#endif\n#endif /* __ATOMIC_VAR_H */\n```\n","tags":["源码阅读"],"categories":["redis封装类"]},{"title":"spring源码阅读准备","url":"%2F2019%2F12%2F16%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FJava%2FSpring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2Fspring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%87%86%E5%A4%87%2F","content":"\n## spring源码阅读准备\n\n### spring模块\nspring的模块\n![spring模块](spring模块.png)\n\nspring模块之间的关系\n![spring模块构成](spring模块构成.png)\n\n#### spring模块组成\n  1. 数据访问模块：\n\tspring-jdbc: 对jdbc的支持\n\tspring-orm: 对象关系映射，集成orm框架\n\tspring-oxm: 对象xml映射，解析xml文件\n\tspring-jms: java消息服务\n\tspring-tx: 事务控制\n  2. web方面的模块：\n\tspring-web: 基础web功能，如上传文件\n\tspring-webflux: 用于替代旧的servlet线程模型,一种响应式编程方式\n\tspring-webmvc： mvc实现\n\tspring-webscoket: 为web应用提供高效的通信工具\n\tspring-messaging: 用于构建基础消息的应用程序\n  3. 核心模块：\n\tspring-core: 依赖注入或控制反转的最基本实现\n\tspring-beans: bean工厂与bean的装配，ApplicationContent就是继承BeanFactory\n\tspring-context: spring的ioc容器\n\tspring-expression: spring表达式语言\n  4. aop模块：\n\tspring-aop: 面向切面编程\n\tspring-aspects: 集成aspectJ\n\tspring-instrument: 提供一些类级别的工具支持和ClassLoader级别的实现，用于服务器\n  5. test模块：\n\tspring-test: 提供junit和mock测试功能\n  6. 日志模块:\n\tspring-jcl: spring的日志模块\n  7. 其他:\n\tspring-context-support: spring的额外支持包，比如邮件服务、视图解析等\n\tspring-context-indexer: spring的类管理组件以及classpath扫描\n\n#### spring模块间的依赖关系\n\n  1. spring-core: 这个模块是整个spring项目的基础，很多spring模块都需要依赖这个模块\t\t\n\tspring-jcl\n  2. spring-aop: \t\t\t\n\tspring-beans\n\tspring-core\n  3. spring-aspects: \t\t\n\tspring-aop\n\tspring-beans\n\tspring-context\n\tspring-context-support\n\tspring-core\n\tspring-orm\n\tspring-tx\n\tspring-test\n  4. spring-beans: \t\t\t\n\tspring-core\n  5. spring-context: \t\t\n\tspring-aop\n\tspring-beans\n\tspring-core\n\tspring-expression\n\tspring-instrument\n  6. spring-context-indexer: \n\tspring-context\n  7. spring-context-support: \n\tspring-beans\n\tspring-context\n\tspring-core\n\tspring-jdbc\n\tspring-tx\n  8. spring-expression: \t\t\n\tspring-core\n  9. spring-instrument\n  10. spring-jcl\n  11. spring-jdbc: \t\t\t\n\tspring-beans\n\tspring-context\n\tspring-core\n\tspring-tx\n  12. spring-jms: \n\tspring-beans\n\tspring-core\n\tspring-messaging\n\tspring-aop\n\tspring-context\n\tspring-oxm\n  13. spring-messaging: \n\tspring-beans\n\tspring-core\n\tspring-context\n\tspring-oxm\n  14. spring-orm: \n\tspring-beans\n\tspring-core\n\tspring-jdbc\n\tspring-tx\n\tspring-aop\n\tspring-context\n\tspring-web\n  15. spring-oxm: \n\tspring-beans\n\tspring-core\n\tspring-context\n  16. spring-test: \n\tspring-core\n\tspring-aop\n\tspring-beans\n\tspring-context\n\tspring-jdbc\n\tspring-orm\n\tspring-tx\n\tspring-web\n\tspring-webflux\n\tspring-webmvc\n\tspring-webscoket\n\tspring-context-support\n\tspring-oxm\n  17. spring-tx: \n\tspring-beans\n\tspring-core\n\tspring-aop\n\tspring-context\n  18. spring-web: \n\tspring-beans\n\tspring-core\n\tspring-aop\n\tspring-context\n\tspring-oxm\n  19. spring-webflux: \n\tspring-beans\n\tspring-core\n\tspring-web\n\tspring-context\n\tspring-context-support\n  20. spring-webmvc: \n\tspring-aop\n\tspring-beans\n\tspring-context\n\tspring-core\n\tspring-expression\n\tspring-web\n\tspring-context-support\n\tspring-oxm\n  21. spring-webscoket:\n\tspring-context\n\tspring-core\n\tspring-web\n\tspring-messaging\n\tspring-webmvc\n","tags":["源码阅读"],"categories":["源码阅读"]},{"title":"redis源码阅读-list数据结构(双向链表)","url":"%2F2019%2F12%2F16%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FC%2Fredis%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-list%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F","content":"\n## redis源码阅读-list数据结构(双向链表)\n\n### list数据结构\n> list底层数据结构是双向链表\n### adlist.h\n```C\n/* adlist.h - A generic doubly linked list implementation\n    *\n    * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n    * All rights reserved.\n    *\n    * Redistribution and use in source and binary forms, with or without\n    * modification, are permitted provided that the following conditions are met:\n    *\n    *   * Redistributions of source code must retain the above copyright notice,\n    *     this list of conditions and the following disclaimer.\n    *   * Redistributions in binary form must reproduce the above copyright\n    *     notice, this list of conditions and the following disclaimer in the\n    *     documentation and/or other materials provided with the distribution.\n    *   * Neither the name of Redis nor the names of its contributors may be used\n    *     to endorse or promote products derived from this software without\n    *     specific prior written permission.\n    *\n    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n    * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n    * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n    * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n    * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n    * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n    * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n    * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n    * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    * POSSIBILITY OF SUCH DAMAGE.\n    */\n#ifndef __ADLIST_H__\n#define __ADLIST_H__\n/* Node, List, and Iterator are the only data structures used currently. */\n// 双向链表节点\ntypedef struct listNode {\n    struct listNode *prev; // 前向指针\n    struct listNode *next; // 后向指针\n    void *value; // 节点值\n} listNode; // 结构自定义名\n// 列表迭代器\ntypedef struct listIter {\n    listNode *next; // 迭代下一个节点\n    int direction; // 迭代方向\n} listIter;\n// 列表(这个结构体是c++类的雏形，下面的三个函数指针就是类方法，而其他的变量就是类变量)\ntypedef struct list {\n    listNode *head; // 列表头节点\n    listNode *tail; // 列表尾节点\n    void *(*dup)(void *ptr); // 复制函数指针\n    void (*free)(void *ptr); // 释放内存函数指针\n    int (*match)(void *ptr, void *key); // 匹配函数指针\n    unsigned long len; // 列表长度\n} list;\n/* Functions implemented as macros */\n/**** 被定义为宏的函数实现 ****/\n// 对list结构的操作,输入的\"l\"是list类型\n#define listLength(l) ((l)->len) // 获取列表长度\n#define listFirst(l) ((l)->head) // 获取列表头结点\n#define listLast(l) ((l)->tail) // 获取列表尾节点\n// 对listNode结构的操作,输入的\"n\"是listNode类型\n#define listPrevNode(n) ((n)->prev) // 列表节点前指针\n#define listNextNode(n) ((n)->next) // 列表节点后指针\n#define listNodeValue(n) ((n)->value) // 列表节点值\n//对list结构中的函数进行的操作，就像c++中的set函数. \"l\"是list类型。\n// \"m\"是一个*(*dup)(void *ptr)类型的函数，在这里被回调\n#define listSetDupMethod(l,m) ((l)->dup = (m)) // 设置列表复制函数\n#define listSetFreeMethod(l,m) ((l)->free = (m)) // 设置释放列表内存函数\n#define listSetMatchMethod(l,m) ((l)->match = (m)) // 设置匹配列表函数\n// 对list结构中的函数的get操作,\"l\"是list结构\n#define listGetDupMethod(l) ((l)->dup) // 获取列表的复制函数\n#define listGetFree(l) ((l)->free) // 获取列表的释放内存函数\n#define listGetMatchMethod(l) ((l)->match) // 获取列表的匹配函数\n/* Prototypes */\n// 函数原型\nlist *listCreate(void);  // 列表创建函数\nvoid listRelease(list *list); // 列表释放函数\nvoid listEmpty(list *list); // 清空列表\nlist *listAddNodeHead(list *list, void *value); // 增加列表头结点\nlist *listAddNodeTail(list *list, void *value); // 增加列表尾节点\nlist *listInsertNode(list *list, listNode *old_node, void *value, int after); // 增加列表普通节点\nvoid listDelNode(list *list, listNode *node); // 删除列表节点\nlistIter *listGetIterator(list *list, int direction); // 获取列表迭代器\nlistNode *listNext(listIter *iter); // 通过列表迭代器获取列表的下一个节点\nvoid listReleaseIterator(listIter *iter); // 释放列表迭代器\nlist *listDup(list *orig); // 复制列表\nlistNode *listSearchKey(list *list, void *key); // 通过key值搜索列表中匹配的节点\nlistNode *listIndex(list *list, long index); // 通过列表索引获取列表匹配的节点\nvoid listRewind(list *list, listIter *li); // 初始化迭代器(重置迭代器)，也就是将迭代器充值到开始位置，重新迭代\nvoid listRewindTail(list *list, listIter *li); // 将迭代器重置的末尾重新迭代\nvoid listRotate(list *list); // 按方向旋转列表(将头变为尾，将尾变为头)\nvoid listJoin(list *l, list *o); // 将一个列表加入一个列表\n/* Directions for iterators */\n// 列表方向\n#define AL_START_HEAD 0 // 从头遍历\n#define AL_START_TAIL 1 // 从尾遍历\n#endif /* __ADLIST_H__ */\n```\n\n### adlist.c\n```C\n/* adlist.c - A generic doubly linked list implementation\n    *\n    * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>\n    * All rights reserved.\n    *\n    * Redistribution and use in source and binary forms, with or without\n    * modification, are permitted provided that the following conditions are met:\n    *\n    *   * Redistributions of source code must retain the above copyright notice,\n    *     this list of conditions and the following disclaimer.\n    *   * Redistributions in binary form must reproduce the above copyright\n    *     notice, this list of conditions and the following disclaimer in the\n    *     documentation and/or other materials provided with the distribution.\n    *   * Neither the name of Redis nor the names of its contributors may be used\n    *     to endorse or promote products derived from this software without\n    *     specific prior written permission.\n    *\n    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n    * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n    * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n    * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n    * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n    * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n    * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n    * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n    * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    * POSSIBILITY OF SUCH DAMAGE.\n    */\n#include <stdlib.h>\n#include \"adlist.h\" // 提供列表结构和操作列表的函数原型\n#include \"zmalloc.h\" // 提供操作内存的函数原型\n/* Create a new list. The created list can be freed with\n    * AlFreeList(), but private value of every node need to be freed\n    * by the user before to call AlFreeList().\n    *\n    * On error, NULL is returned. Otherwise the pointer to the new list. */\n    // 创建新列表\nlist *listCreate(void)\n{\n    struct list *list; // 创建一个列表结构\n    if ((list = zmalloc(sizeof(*list))) == NULL) // 为列表结构分配初始内存\n        return NULL;\n    // 初始化列表结构中的各个元素\n        list->head = list->tail = NULL; \n        list->len = 0;\n        list->dup = NULL;\n        list->free = NULL;\n        list->match = NULL;\n        return list;\n    }\n        /* Remove all the elements from the list without destroying the list itself. */\n    // 从列表中移除所有元素，但不销毁列表结构。\n    void listEmpty(list *list)\n    {\n        unsigned long len; // 列表长度\n        listNode *current, *next; // 当前节点和下一个节点\n            current = list->head; // 当前节点初始化为指向头节点\n        len = list->len; // 将列表长度赋值给len\n        while(len--) {\n            next = current->next; // 下一个节点指向当前节点的下一个节点\n            if (list->free) list->free(current->value); // 如果free函数指针返回不为空，表示有内存需要释放，通过节点值释放节点\n            zfree(current);// 释放当前节点所占内存\n            current = next; // 将当前节点指向下一个节点\n        }\n        list->head = list->tail = NULL; // 当头节点和尾节点之间的节点都释放完毕，就将头节点和尾节点置NULL\n        list->len = 0; // 列表长度置0\n        // 此时保留列表结构\n    }\n        /* Free the whole list.\n        *\n        * This function can't fail. */\n    // 释放整个列表，列表元素和列表结构一起释放\n    void listRelease(list *list)\n    {\n        listEmpty(list); // 释放列表元素\n        zfree(list); // 释放列表结构\n    }\n        /* Add a new node to the list, to head, containing the specified 'value'\n        * pointer as value.\n        *\n        * On error, NULL is returned and no operation is performed (i.e. the\n        * list remains unaltered).\n        * On success the 'list' pointer you pass to the function is returned. */\n        // 从头插入新节点(将新节点作为头节点)\n    list *listAddNodeHead(list *list, void *value)\n    {\n        listNode *node;\n            // 为新节点分配内存空间\n        if ((node = zmalloc(sizeof(*node))) == NULL)\n            return NULL;\n        node->value = value; // 为新节点赋值\n        if (list->len == 0) { // 如果列表为空\n            list->head = list->tail = node; // 先让列表头指针和尾指针指向该节点，让节点加入列表\n            node->prev = node->next = NULL; // 然后让节点前指针和后指针为空，这就使节点成为列表的第一个节点\n        } else { // 列表中有元素，则从头插入\n            node->prev = NULL; // 新节点前指针为空，后指针指向列表原来的头节点,这就让新节点成为列表头节点\n            node->next = list->head;\n            list->head->prev = node; // 新节点与列表建立了关系，之后就需要列表元素与新节点建立关系，让列表原来的头节点的前指针指向新节点\n            list->head = node; // 然后让现在的列表头指针指向新节点，让新节点成为头节点\n        }\n        list->len++;\n        return list;\n    }\n        /* Add a new node to the list, to tail, containing the specified 'value'\n        * pointer as value.\n        *\n        * On error, NULL is returned and no operation is performed (i.e. the\n        * list remains unaltered).\n        * On success the 'list' pointer you pass to the function is returned. */\n        // 从尾加入节点\n    list *listAddNodeTail(list *list, void *value)\n    {\n        listNode *node;\n            if ((node = zmalloc(sizeof(*node))) == NULL)\n            return NULL;\n        node->value = value;\n        if (list->len == 0) {\n            list->head = list->tail = node;\n            node->prev = node->next = NULL;\n        } else {\n            node->prev = list->tail;\n            node->next = NULL;\n            list->tail->next = node;\n            list->tail = node;\n        }\n        list->len++;\n        return list;\n    }\n        // 在列表中间新增节点(默认是向指定节点的后方添加节点)\n    list *listInsertNode(list *list, listNode *old_node, void *value, int after) {\n        listNode *node;\n            if ((node = zmalloc(sizeof(*node))) == NULL)\n            return NULL;\n        node->value = value;\n        if (after) { // 为真，则向后增加\n            // 使新节点代替老节点在列表中的关系\n                node->prev = old_node; // 新节点前指针指向老节点\n                node->next = old_node->next; // 新节点的后指针指向老节点的下一个节点\n                if (list->tail == old_node) { // 如果老节点就是尾节点,新节点就作为新的尾节点\n                    list->tail = node; \n                }\n            } else { // 为假，向前增加\n                node->next = old_node;\n                node->prev = old_node->prev;\n                if (list->head == old_node) {\n                    list->head = node;\n                }\n            }\n                    // 前面判断语句里面只有设置了新节点是列表头节点和尾节点的可能，这里则判断新节点不是头节点或尾节点\n            if (node->prev != NULL) {\n                node->prev->next = node; // 让新节点的前指针指向的节点(也就是老节点的前指针指向的节点)的后指针指向新节点\n            }\n            if (node->next != NULL) {\n                node->next->prev = node;\n            }\n            list->len++;\n            return list;\n        }\n                /* Remove the specified node from the specified list.\n            * It's up to the caller to free the private value of the node.\n            *\n            * This function can't fail. */\n        // 从列表中删除节点\n        void listDelNode(list *list, listNode *node)\n        {\n            if (node->prev) // 如果删除节点的前指针不为空，表示删除节点不是头节点\n                node->prev->next = node->next; // 则将删除节点前指针指向的节点的后指针指向删除节点的下一个节点\n            else\n                list->head = node->next;\n            if (node->next) // 如果删除节点不是尾节点\n                node->next->prev = node->prev; // 将删除节点的后指针指向的节点的前指针指向删除节点的上一个节点\n            else\n                list->tail = node->prev;\n            if (list->free) list->free(node->value); // 如果列表中的释放内存函数返回值不为空，表示需要释放内存，首先释放节点值内存\n            zfree(node); // 然后释放节点结构内存\n            list->len--;\n        }\n                /* Returns a list iterator 'iter'. After the initialization every\n            * call to listNext() will return the next element of the list.\n            *\n            * This function can't fail. */\n        // 获取列表迭代器(自定义迭代方向)\n        listIter *listGetIterator(list *list, int direction)\n        {\n            listIter *iter;\n                    // 先分配为迭代器分配内存\n            if ((iter = zmalloc(sizeof(*iter))) == NULL) return NULL;\n            if (direction == AL_START_HEAD) // 如果是从头开始\n                iter->next = list->head; // 将迭代器的后指针(指向需要迭代的一个节点)指向列表的头节点，从头开始迭代\n            else\n                iter->next = list->tail;\n            iter->direction = direction; // 这里为迭代器定义迭代方向\n            return iter;\n        }\n                /* Release the iterator memory */\n        // 释放迭代器内存\n        void listReleaseIterator(listIter *iter) {\n            zfree(iter);\n        }\n                /* Create an iterator in the list private iterator structure */'\n        // 在列表私有迭代器结构中创建迭代器\n                // 重置迭代器游标，默认重置到头节点，并从头节点开始遍历\n        void listRewind(list *list, listIter *li) {\n            li->next = list->head;\n            li->direction = AL_START_HEAD;\n        }\n                // 重置迭代器游标到尾节点，并从尾节点开始遍历\n        void listRewindTail(list *list, listIter *li) {\n            li->next = list->tail;\n            li->direction = AL_START_TAIL;\n        }\n                /* Return the next element of an iterator.\n            * It's valid to remove the currently returned element using\n            * listDelNode(), but not to remove other elements.\n            *\n            * The function returns a pointer to the next element of the list,\n            * or NULL if there are no more elements, so the classical usage patter\n            * is:\n            *\n            * iter = listGetIterator(list,<direction>);\n            * while ((node = listNext(iter)) != NULL) {\n            *     doSomethingWith(listNodeValue(node));\n            * }\n            *\n            * */\n        // 通过迭代器获取下一个元素\n        listNode *listNext(listIter *iter)\n        {\n            listNode *current = iter->next; // 初始化当前节点(需要获取的节点)为指向迭代器的下一个节点\n                    if (current != NULL) { // 当前节点不为空(需要获取的节点不为空)\n                if (iter->direction == AL_START_HEAD) // 如果迭代器是从头开始遍历\n                    iter->next = current->next; // 迭代器的游标指向当前节点的下一个节点\n                else\n                    iter->next = current->prev;\n                }\n                return current; \n            }\n                        /* Duplicate the whole list. On out of memory NULL is returned.\n                * On success a copy of the original list is returned.\n                *\n                * The 'Dup' method set with listSetDupMethod() function is used\n                * to copy the node value. Otherwise the same pointer value of\n                * the original node is used as value of the copied node.\n                *\n                * The original list both on success or error is never modified. */\n            // 复制整个列表\n            list *listDup(list *orig)\n            {\n                list *copy; // 创建复制列表的结构\n                listIter iter; // 创建迭代器，迭代源列表的元素到复制列表\n                listNode *node; \n                            if ((copy = listCreate()) == NULL) // 使用列表创建函数创建复制列表的列表结构\n                    return NULL;\n                // 将源列表的属性复制给目标列表\n                copy->dup = orig->dup; \n                copy->free = orig->free;\n                copy->match = orig->match;\n                listRewind(orig, &iter); // 将迭代器游标重置到源列表的头节点处\n                while((node = listNext(&iter)) != NULL) { // 一个节点一个节点的遍历\n                    void *value;\n                                    if (copy->dup) { \n                        value = copy->dup(node->value);\n                        if (value == NULL) {\n                            listRelease(copy);\n                            return NULL;\n                        }\n                    } else\n                        value = node->value;\n                    if (listAddNodeTail(copy, value) == NULL) {\n                        listRelease(copy);\n                        return NULL;\n                    }\n                }\n                return copy;\n            }\n                        /* Search the list for a node matching a given key.\n                * The match is performed using the 'match' method\n                * set with listSetMatchMethod(). If no 'match' method\n                * is set, the 'value' pointer of every node is directly\n                * compared with the 'key' pointer.\n                *\n                * On success the first matching node pointer is returned\n                * (search starts from head). If no matching node exists\n                * NULL is returned. */\n            // 通过列表值搜索列表节点\n            listNode *listSearchKey(list *list, void *key)\n            {\n                listIter iter;\n                listNode *node;\n                            listRewind(list, &iter); // 先重置迭代器游标到头节点\n                while((node = listNext(&iter)) != NULL) {\n                    if (list->match) {\n                        if (list->match(node->value, key)) {\n                            return node;\n                        }\n                    } else {\n                        if (key == node->value) {\n                            return node;\n                        }\n                    }\n                }\n                return NULL;\n            }\n                        /* Return the element at the specified zero-based index\n                * where 0 is the head, 1 is the element next to head\n                * and so on. Negative integers are used in order to count\n                * from the tail, -1 is the last element, -2 the penultimate\n                * and so on. If the index is out of range NULL is returned. */\n            // 通过索引搜索列表节点(从头节点开始是0,1,2,...;从尾开始则是-1,-2,-3...)\n            listNode *listIndex(list *list, long index) {\n                listNode *n;\n                            if (index < 0) { // 如果从尾开始索引\n                    index = (-index)-1; // 相当于i++\n                    n = list->tail; // 搜寻节点的初始值是尾节点\n                    while(index-- && n) n = n->prev; // index初始大小表名需要遍历多少个节点才能找到\n                } else {\n                    n = list->head;\n                    while(index-- && n) n = n->next;\n                }\n                return n;\n            }\n                        /* Rotate the list removing the tail node and inserting it to the head. */\n            // 将列表头节点和尾节点掉头，相当于翻转列表\n            void listRotate(list *list) {\n                listNode *tail = list->tail;\n                            if (listLength(list) <= 1) return;\n                            /* Detach current tail */\n                list->tail = tail->prev;\n                list->tail->next = NULL;\n                /* Move it as head */\n                list->head->prev = tail;\n                tail->prev = NULL;\n                tail->next = list->head;\n                list->head = tail;\n            }\n                        /* Add all the elements of the list 'o' at the end of the\n                * list 'l'. The list 'other' remains empty but otherwise valid. */\n            // 将列表o的元素加入列表l的末尾\n            void listJoin(list *l, list *o) {\n                            // 1和3只能存在一个如果头节点有值，则与头节点对接，如果只有尾节点，则与尾节点对接\n                            /**************************************************\n                    前提是两个链表结构都存在\n                ***************************************************/\n                // 1. 先让o列表与l列表建立关系\n                if (o->head) // 如果列表o存在\n                    o->head->prev = l->tail; // 列表o的头节点的前指针指向列表l的尾节点\n                                    // 2. 让l列表与o列表建立关系\n                    if (l->tail) // 如果列表l的尾节点存在\n                        l->tail->next = o->head; // 列表l的尾节点的后指针指向列表o的头节点\n                    else // 如果尾节点为空，表示l没有元素\n                        l->head = o->head; // 使得列表l头节点就是列表o的头节点，也就是新的列表l就是列表o\n                                        // 3. 如果o头节点为空,只有尾节点\n                    if (o->tail) l->tail = o->tail; // 上面我们已经判断了\n                    l->len += o->len;\n                                    /* Setup other as an empty list. */\n                    o->head = o->tail = NULL;\n                    o->len = 0;\n                }\n```\n","tags":["源码阅读"],"categories":["数据结构"]},{"title":"redis源码阅读-zmalloc(内存分配)","url":"%2F2019%2F12%2F16%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FC%2Fredis%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-zmalloc-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F","content":"\n##  redis源码阅读-zmalloc(内存分配)\n\n### zmalloc介绍\n  + redis支持使用tcmalloc,jemalloc内存分配器分配内存，也支持操作系统平台提供的内存分配库。\n  + zmalloc是redis封装的内存分配函数。redis将多种内存分配方法封装为统一的接口zmalloc，让其统一对外提供功能，避免跨平台不兼容问题。\n\n### zmalloc.h\n```C\n/* zmalloc - total amount of allocated memory aware version of malloc()\n    *\n    * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>\n    * All rights reserved.\n    *\n    * Redistribution and use in source and binary forms, with or without\n    * modification, are permitted provided that the following conditions are met:\n    *\n    *   * Redistributions of source code must retain the above copyright notice,\n    *     this list of conditions and the following disclaimer.\n    *   * Redistributions in binary form must reproduce the above copyright\n    *     notice, this list of conditions and the following disclaimer in the\n    *     documentation and/or other materials provided with the distribution.\n    *   * Neither the name of Redis nor the names of its contributors may be used\n    *     to endorse or promote products derived from this software without\n    *     specific prior written permission.\n    *\n    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n    * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n    * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n    * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n    * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n    * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n    * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n    * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n    * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    * POSSIBILITY OF SUCH DAMAGE.\n    */\n#ifndef __ZMALLOC_H\n#define __ZMALLOC_H\n/* Double expansion needed for stringification of macro values. */\n// 使用宏对象双向链表进行细化扩展\n#define __xstr(s) __str(s)\n#define __str(s) #s // 给s加上双引号\"\"; #@s(给s加单引号); s##s(连接两个字符串)\n// 这段对内存分配器的定义，是为了将内存分配器抽象为zmalloc，不用管内存分配器的基础库是什么\n#if defined(USE_TCMALLOC) // 使用tcmalloc内存分配器(还有一个jemalloc)\n#define ZMALLOC_LIB (\"tcmalloc-\" __xstr(TC_VERSION_MAJOR) \".\" __xstr(TC_VERSION_MINOR)) // 定义zmalloc库版本(tcmalloc-主版本-小版本)\n#include <google/tcmalloc.h>\n#if (TC_VERSION_MAJOR == 1 && TC_VERSION_MINOR >= 6) || (TC_VERSION_MAJOR > 1) // 如果tcmalloc主版本等于1且小版本大于等于6或者是主版本大于1，就将tc_malloc_size重命名为zmalloc_size函数，否则tcmalloc版本太旧\n#define HAVE_MALLOC_SIZE 1 // 表示存在malloc_size函数\n#define zmalloc_size(p) tc_malloc_size(p) // 定义tzmalloc_size(p)为zmalloc_size(p)\n#else\n#error \"Newer version of tcmalloc required\"\n#endif\n#elif defined(USE_JEMALLOC) // 如果用的是jemalloc内存分配器\n#define ZMALLOC_LIB (\"jemalloc-\" __xstr(JEMALLOC_VERSION_MAJOR) \".\" __xstr(JEMALLOC_VERSION_MINOR) \".\" __xstr(JEMALLOC_VERSION_BUGFIX)) // 定义zmalloc库版本(jemalloc-主版本-小版本-bug修复版本)\n#include <jemalloc/jemalloc.h>\n#if (JEMALLOC_VERSION_MAJOR == 2 && JEMALLOC_VERSION_MINOR >= 1) || (JEMALLOC_VERSION_MAJOR > 2)\n#define HAVE_MALLOC_SIZE 1\n#define zmalloc_size(p) je_malloc_usable_size(p)\n#else\n#error \"Newer version of jemalloc required\"\n#endif\n#elif defined(__APPLE__) // 如果是mac平台\n#include <malloc/malloc.h>\n#define HAVE_MALLOC_SIZE 1\n#define zmalloc_size(p) malloc_size(p)\n#endif\n#ifndef ZMALLOC_LIB // 如果没有内存分配器被定义，则使用原生malloc\n#define ZMALLOC_LIB \"libc\"\n#ifdef __GLIBC__\n#include <malloc.h>\n#define HAVE_MALLOC_SIZE 1\n#define zmalloc_size(p) malloc_usable_size(p)\n#endif\n#endif\n/* We can enable the Redis defrag capabilities only if we are using Jemalloc\n    * and the version used is our special version modified for Redis having\n    * the ability to return per-allocation fragmentation hints. */\n// 用jemalloc是会定义HAVE_DEFRAG\n#if defined(USE_JEMALLOC) && defined(JEMALLOC_FRAG_HINT)\n#define HAVE_DEFRAG\n#endif\nvoid *zmalloc(size_t size); // 分配长度为size的内存(需要手动计算分配空间大小),不会设置初始值，效率高\nvoid *zcalloc(size_t size); // 并不需要人为计算分配空间大小，会给每一个分配的空间设置初始值，效率比较低\nvoid *zrealloc(void *ptr, size_t size); // 动态内存扩容,ptr指向原来的空间地址，size是需要分配的空间大小\nvoid zfree(void *ptr); // 释放被分配的内存\nchar *zstrdup(const char *s); // 字符串复制\nsize_t zmalloc_used_memory(void); // 分配被用的内存\nvoid zmalloc_set_oom_handler(void (*oom_handler)(size_t)); // 设置内存用完了的句柄\n// 获取实际使用的物理内存\n// VSS：Virtual Set Size 虚拟耗用的内存(包含与其他进程共享占用的虚拟内存)\n// RSS：Resident Set Size 实际使用的物理内存(包含与其他进程共享占用的内存)\n// PSS：Proportional Set Size 实际使用的物理内存(按比例包含与其他进程共享占用的内存)\n// USS：Unique Set Size 进程独自占用的物理内存(不包含与其他进程共享占用的内存)\nsize_t zmalloc_get_rss(void);\n// 获取被分配的内存信息\nint zmalloc_get_allocator_info(size_t *allocated, size_t *active, size_t *resident);\nsize_t zmalloc_get_private_dirty(long pid); // 通过进程pid获取私有脏数据\nsize_t zmalloc_get_smap_bytes_by_field(char *field, long pid); // 通过字段和pid获取\nsize_t zmalloc_get_memory_size(void); // 获取内存长度\nvoid zlibc_free(void *ptr); // 释放内存\n#ifdef HAVE_DEFRAG // 如果使用的是jemalloc\nvoid zfree_no_tcache(void *ptr);\nvoid *zmalloc_no_tcache(size_t size);\n#endif\n#ifndef HAVE_MALLOC_SIZE\nsize_t zmalloc_size(void *ptr);\nsize_t zmalloc_usable(void *ptr);\n#else\n#define zmalloc_usable(p) zmalloc_size(p)\n#endif\n#ifdef REDIS_TEST // 如果定义了redis测试\nint zmalloc_test(int argc, char **argv);\n#endif\n#endif /* __ZMALLOC_H */\n```\n### zmalloc.c\n```C\n/* zmalloc - total amount of allocated memory aware version of malloc()\n    *\n    * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>\n    * All rights reserved.\n    *\n    * Redistribution and use in source and binary forms, with or without\n    * modification, are permitted provided that the following conditions are met:\n    *\n    *   * Redistributions of source code must retain the above copyright notice,\n    *     this list of conditions and the following disclaimer.\n    *   * Redistributions in binary form must reproduce the above copyright\n    *     notice, this list of conditions and the following disclaimer in the\n    *     documentation and/or other materials provided with the distribution.\n    *   * Neither the name of Redis nor the names of its contributors may be used\n    *     to endorse or promote products derived from this software without\n    *     specific prior written permission.\n    *\n    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n    * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n    * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n    * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n    * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n    * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n    * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n    * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n    * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    * POSSIBILITY OF SUCH DAMAGE.\n    */\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n/* This function provide us access to the original libc free(). This is useful\n    * for instance to free results obtained by backtrace_symbols(). We need\n    * to define this function before including zmalloc.h that may shadow the\n    * free implementation if we use jemalloc or another non standard allocator. */\n// 这个方法提供给我们的是libc原生的free函数,通过backtrace_symbols()函数释放栈\nvoid zlibc_free(void *ptr) {\n    free(ptr);\n}\n#include <string.h>\n#include <pthread.h>\n#include \"config.h\"\n#include \"zmalloc.h\" // 提供内存操作函数原型\n#include \"atomicvar.h\" // 原子性(线程安全)\n// 如果定义了HAVE_MALLOC_SIZE，表示使用了tcmalloc或mac, 不需要记录申请内存大小\n// 如果没有定义HAVE_MALLOC_SIZE，表示使用了linux或sun,需要记录申请内存大小\n#ifdef HAVE_MALLOC_SIZE // tcmalloc 和 Mac平台下的 malloc 函数族提供了计算已分配空间大小的函数（分别是tcmallocsize和mallocsize），所以就不需要单独分配一段空间记录大小了\n#define PREFIX_SIZE (0)\n#else\n// sun平台和linux没有提供计算分配空间大小的函数，需要一段初始的空间来记录当前申请的内存空间大小(PREFIX_SIZE)\n#if defined(__sun) || defined(__sparc) || defined(__sparc__)\n#define PREFIX_SIZE (sizeof(long long)) // sun平台使用sizeof(long long)定长字段记录\n#else\n#define PREFIX_SIZE (sizeof(size_t)) // linux使用sizeof(size_t)定长字段记录\n#endif\n#endif\n/* Explicitly override malloc/free etc when using tcmalloc. */\n// 如果用tcmalloc，直接重写malloc/free等原生函数\n#if defined(USE_TCMALLOC)\n#define malloc(size) tc_malloc(size)\n#define calloc(count,size) tc_calloc(count,size)\n#define realloc(ptr,size) tc_realloc(ptr,size)\n#define free(ptr) tc_free(ptr)\n#elif defined(USE_JEMALLOC)\n#define malloc(size) je_malloc(size)\n#define calloc(count,size) je_calloc(count,size)\n#define realloc(ptr,size) je_realloc(ptr,size)\n#define free(ptr) je_free(ptr)\n#define mallocx(size,flags) je_mallocx(size,flags)\n#define dallocx(ptr,flags) je_dallocx(ptr,flags)\n#endif\n#define update_zmalloc_stat_alloc(__n) do { \\\n    size_t _n = (__n); \\\n    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \\\n    atomicIncr(used_memory,__n); \\\n} while(0)\n#define update_zmalloc_stat_free(__n) do { \\\n    size_t _n = (__n); \\\n    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \\\n    atomicDecr(used_memory,__n); \\\n} while(0)\n// 初始化被用内存\nstatic size_t used_memory = 0;\n// 被用内存的线程互斥量，用于多线程中的线程安全\npthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;\n// 默认的内存溢出函数\nstatic void zmalloc_default_oom(size_t size) {\n    fprintf(stderr, \"zmalloc: Out of memory trying to allocate %zu bytes\\n\",\n        size);\n    fflush(stderr);\n    abort();\n}\n// 默认的内存溢出函数指针，用于zmalloc_set_oom_handler函数\nstatic void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;\n// 将malloc函数包装 , 空类型指针，并不是返回空，在这里表示可以返回任何类型的指针\nvoid *zmalloc(size_t size) {\n    void *ptr = malloc(size+PREFIX_SIZE); // 先分配内存\n    if (!ptr) zmalloc_oom_handler(size); // 如果分配的内存为空，表示内存溢出\n#ifdef HAVE_MALLOC_SIZE // 如果定义了HAVE_MALLOC_SIZE,表示使用了tcmalloc或mac , 不需要PREFIX_SIZE,直接获取ptr中的内存大小\n    update_zmalloc_stat_alloc(zmalloc_size(ptr)); // 获取分配的内存信息(size+0)\n    return ptr; // 只返回申请的内存空间\n#else // 没有则使用原生的\n    *((size_t*)ptr) = size; // 为指针重新赋值为size\n    update_zmalloc_stat_alloc(size+PREFIX_SIZE); // size+sizeof(long long) 或者 size+sizeof(size_t)\n    return (char*)ptr+PREFIX_SIZE; // 返回分配的内存空间+记录申请内存空间的空间\n#endif\n}\n/* Allocation and free functions that bypass the thread cache\n    * and go straight to the allocator arena bins.\n    * Currently implemented only for jemalloc. Used for online defragmentation. */\n    // 仅用jemalloc实现，被用于碎片整理\n#ifdef HAVE_DEFRAG\nvoid *zmalloc_no_tcache(size_t size) {\n    void *ptr = mallocx(size+PREFIX_SIZE, MALLOCX_TCACHE_NONE);\n    if (!ptr) zmalloc_oom_handler(size);\n    update_zmalloc_stat_alloc(zmalloc_size(ptr));\n    return ptr;\n}\nvoid zfree_no_tcache(void *ptr) {\n    if (ptr == NULL) return;\n    update_zmalloc_stat_free(zmalloc_size(ptr));\n    dallocx(ptr, MALLOCX_TCACHE_NONE);\n}\n#endif\n// 为分配的内存设初始值 calloc函数的包装\nvoid *zcalloc(size_t size) {\n    void *ptr = calloc(1, size+PREFIX_SIZE);\n    if (!ptr) zmalloc_oom_handler(size);\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_alloc(zmalloc_size(ptr));\n    return ptr;\n#else\n    *((size_t*)ptr) = size;\n    update_zmalloc_stat_alloc(size+PREFIX_SIZE);\n    return (char*)ptr+PREFIX_SIZE;\n#endif\n}\n// 动态分配内存 realloc函数的包装\n// 分配内存步骤\n// 1. 判断原内存有没有，如果没有，则使用malloc进行分配\n// 2. 如果有，先将老内存+新指定的内存，然后释放老内存，重新分配新内存\nvoid *zrealloc(void *ptr, size_t size) {\n#ifndef HAVE_MALLOC_SIZE // 如果没定义，则是使用sun和linux平台\n    void *realptr;\n#endif\n    size_t oldsize;\n    void *newptr;\n    if (ptr == NULL) return zmalloc(size); // 如果原来分配的内存为空，就直接使用malloc分配size\n#ifdef HAVE_MALLOC_SIZE // PREFIX_SIZE=0,不需要记录分配内存大小\n    oldsize = zmalloc_size(ptr);\n    newptr = realloc(ptr,size);\n    if (!newptr) zmalloc_oom_handler(size);\n    update_zmalloc_stat_free(oldsize);\n    update_zmalloc_stat_alloc(zmalloc_size(newptr));\n    return newptr;\n#else // PREFIX_SIZE 需要记录分配内存大小\n    realptr = (char*)ptr-PREFIX_SIZE; // 已分配的内存需要将记录大小的空间去掉，才是真实的分配的内存\n    oldsize = *((size_t*)realptr); // 这才是原来的被分配的内存\n    newptr = realloc(realptr,size+PREFIX_SIZE); // 扩充szie大小的内存+PREFIX_SIZE(记录大小)\n    if (!newptr) zmalloc_oom_handler(size);\n    *((size_t*)newptr) = size;\n    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);\n    update_zmalloc_stat_alloc(size+PREFIX_SIZE);\n    return (char*)newptr+PREFIX_SIZE;\n#endif\n}\n/* Provide zmalloc_size() for systems where this function is not provided by\n    * malloc itself, given that in that case we store a header with this\n    * information as the first bytes of every allocation. */\n// 获取分配的总内存\n#ifndef HAVE_MALLOC_SIZE // 如果没有定义，则需要有记录申请空间大小\nsize_t zmalloc_size(void *ptr) {\n    void *realptr = (char*)ptr-PREFIX_SIZE;\n    size_t size = *((size_t*)realptr);\n    /* Assume at least that all the allocations are padded at sizeof(long) by\n        * the underlying allocator. */\n    // 按位与操作,判断是否分配的是整long型的字节，如果有字节不能填充long型，则使用size += sizeof(long)-(size&(sizeof(long)-1))将剩余的字节填充为long型\n    // 总是分配整个long型字节数,将分配的字节填充为long型 ; 例如,size=63(0011 1111)=sizeof(long)-1  , 就是一个long型size&(sizeof(long)-1)=0，表示为假条件\n    // size=65(0100 0001) size&(sizeof(long)-1)=0000 0001 ,为真，进入语句。size = 65+(63-1) = 127(0111 1111) ,这就补充为一个long型\n        if (size&(sizeof(long)-1)) size += sizeof(long)-(size&(sizeof(long)-1));\n        return size+PREFIX_SIZE;\n    }\n    // 获取分配的可用内存(可用的被分配的内存，减去记录大小的空间)\n    size_t zmalloc_usable(void *ptr) {\n        return zmalloc_size(ptr)-PREFIX_SIZE;\n    }\n    #endif\n        // 释放内存\n    void zfree(void *ptr) {\n    #ifndef HAVE_MALLOC_SIZE\n        void *realptr;\n        size_t oldsize;\n    #endif\n            if (ptr == NULL) return;\n    #ifdef HAVE_MALLOC_SIZE\n        update_zmalloc_stat_free(zmalloc_size(ptr));\n        free(ptr);\n    #else\n        realptr = (char*)ptr-PREFIX_SIZE;\n        oldsize = *((size_t*)realptr);\n        update_zmalloc_stat_free(oldsize+PREFIX_SIZE);\n        free(realptr);\n    #endif\n    }\n        // 复制字符串\n    char *zstrdup(const char *s) {\n        size_t l = strlen(s)+1; // 字符串是char类型(1个字节,不需要扩充)\n        char *p = zmalloc(l);\n        // 使用内存复制函数\n    //  void *memcpy(void *dest, const void *src, size_t n);\n    // dest : 目标字符串\n    // src : 需要复制的字符串\n    // n: 复制字符串的大小\n        memcpy(p,s,l);\n        return p;\n    }\n        // 获取被用内存(原子计数器值)\n    size_t zmalloc_used_memory(void) {\n        size_t um;\n        atomicGet(used_memory,um); // 获取原子计数器值，存入um\n        return um;\n    }\n        // 设置内存溢出句柄(回调函数)\n    void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {\n        zmalloc_oom_handler = oom_handler;\n    }\n        /* Get the RSS information in an OS-specific way.\n        *\n        * WARNING: the function zmalloc_get_rss() is not designed to be fast\n        * and may not be called in the busy loops where Redis tries to release\n        * memory expiring or swapping out objects.\n        *\n        * For this kind of \"fast RSS reporting\" usages use instead the\n        * function RedisEstimateRSS() that is a much faster (and less precise)\n        * version of the function. */\n    // 通过proc里面的stat文件获取使用内存信息\n    #if defined(HAVE_PROC_STAT)\n    #include <unistd.h>\n    #include <sys/types.h>\n    #include <sys/stat.h>\n    #include <fcntl.h>\n    // 获取实际物理内存(不能用于频繁的循环中，比如释放过期内存和交换出对象)\n    size_t zmalloc_get_rss(void) {\n        int page = sysconf(_SC_PAGESIZE); // linux系统调用,获取运行时的配置信息，_SC_PAGESIZE是系统定义的内存页大小\n        size_t rss; // 定义存放实际物理内存大小的变量\n        char buf[4096];\n        char filename[256]; // 文件名(linux中文件名长度最大为256)\n        int fd, count; // 定义文件符和计数\n        char *p, *x;\n        //int snprintf(char *str, size_t size, const char *format, ...);\n    // 将/proc/getpid()/stat这个文件名放入filename中(当前进程产生的进程状态文件)\n        snprintf(filename,256,\"/proc/%d/stat\",getpid());\n        if ((fd = open(filename,O_RDONLY)) == -1) return 0; // 用只读方式打开/proc/getpid()/stat文件\n        if (read(fd,buf,4096) <= 0) { // 将读取的数据放入buf中\n            close(fd);\n            return 0;\n        }\n        close(fd);\n            p = buf; // 让指针p指向数组buf，指针p指向的是一个连续的内存区域\n    // 从/proc/getpid()/stat中读取的信息\n    // 1 (init) S 0 1 1 0 -1 4202752 6006 112996409400 582 3211148 242 1303 712327273 324618393 20 0 1 0 4 19828736 170 18446744073709551615 1 1 0 0 0 0 0 4096 536962595 18446744073709551615 0 0 0 1 0 0 380 0 0\n        count = 23; /* RSS is the 24th field in /proc/<pid>/stat */ // rss是第24个字段\n            // 循环结束后得到的p就是第24个字段的字符串(rss)\n    while(p && count--) {\n    /* char *strchr(const char *s, int c);\n    const char* s : 输入的字符串\n    c : 字符串中的字符\n    return : 返回字符串s中第一个c字符的位置(返回的值是这个位置的后面字符串，包括字符c)\n    */\n        p = strchr(p,' ');\n        if (p) p++;  // 忽略空格，指向空格空面的区域\n    }\n// 如果该字段不为空就不执行return\n    if (!p) return 0;\n    x = strchr(p,' '); // 将指针p指向内存区域的第一个空格以及其后面的字符返回给指针x,指针p现在指向的就只有rss段的内存区域\n    if (!x) return 0;\n    *x = '\\0'; // 将指针x指向的内存区域设置为'\\0'\n// long int strtol(const char *nptr, char **endptr, int base);\n// 将字符串转换为一个长整型(获取数字部分) 10表示10进制\n    rss = strtoll(p,NULL,10);\n    rss *= page; // 将分布在多个内存页上的数据相乘，获取实际使用的物理内存\n    return rss;\n}\n// 通过TASKINF获取实际使用内存\n#elif defined(HAVE_TASKINFO)\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#include <mach/task.h>\n#include <mach/mach_init.h>\n// 通过task函数获取\nsize_t zmalloc_get_rss(void) {\n    task_t task = MACH_PORT_NULL;\n    struct task_basic_info t_info;\n    mach_msg_type_number_t t_info_count = TASK_BASIC_INFO_COUNT;\n    if (task_for_pid(current_task(), getpid(), &task) != KERN_SUCCESS)\n        return 0;\n    task_info(task, TASK_BASIC_INFO, (task_info_t)&t_info, &t_info_count);\n    return t_info.resident_size;\n}\n#else\n// 当我们不能使用操作系统给的方法获取rss，我们就用zmalloc获取分配的内存\nsize_t zmalloc_get_rss(void) {\n    /* If we can't get the RSS in an OS-specific way for this system just\n        * return the memory usage we estimated in zmalloc()..\n        *\n        * Fragmentation will appear to be always 1 (no fragmentation)\n        * of course... */\n    return zmalloc_used_memory();\n}\n#endif\n// 如果使用jemalloc\n#if defined(USE_JEMALLOC)\n//\nint zmalloc_get_allocator_info(size_t *allocated,\n    size_t *active,\n    size_t *resident) {\nuint64_t epoch = 1;\nsize_t sz;\n*allocated = *resident = *active = 0;\n/* Update the statistics cached by mallctl. */\nsz = sizeof(epoch);\nje_mallctl(\"epoch\", &epoch, &sz, &epoch, sz);\nsz = sizeof(size_t);\n/* Unlike RSS, this does not include RSS from shared libraries and other non\n    * heap mappings. */\nje_mallctl(\"stats.resident\", resident, &sz, NULL, 0);\n/* Unlike resident, this doesn't not include the pages jemalloc reserves\n    * for re-use (purge will clean that). */\nje_mallctl(\"stats.active\", active, &sz, NULL, 0);\n/* Unlike zmalloc_used_memory, this matches the stats.resident by taking\n    * into account all allocations done by this process (not only zmalloc). */\nje_mallctl(\"stats.allocated\", allocated, &sz, NULL, 0);\nreturn 1;\n}\nvoid set_jemalloc_bg_thread(int enable) {\n/* let jemalloc do purging asynchronously, required when there's no traffic\n    * after flushdb */\nchar val = !!enable;\nje_mallctl(\"background_thread\", NULL, 0, &val, 1);\n}\n#else\nint zmalloc_get_allocator_info(size_t *allocated,\nsize_t *active,\nsize_t *resident) {\n*allocated = *resident = *active = 0;\nreturn 1;\n}\n#endif\n/* Get the sum of the specified field (converted form kb to bytes) in\n* /proc/self/smaps. The field must be specified with trailing \":\" as it\n* apperas in the smaps output.\n*\n* If a pid is specified, the information is extracted for such a pid,\n* otherwise if pid is -1 the information is reported is about the\n* current process.\n*\n* Example: zmalloc_get_smap_bytes_by_field(\"Rss:\",-1);\n*/\n// 通过/proc/getpid()/smaps文件获取内存信息(smaps使用key-value格式，通过\":\"隔开)\n#if defined(HAVE_PROC_SMAPS)\nsize_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {\nchar line[1024];\nsize_t bytes = 0;\nint flen = strlen(field);\nFILE *fp;\nif (pid == -1) {\nfp = fopen(\"/proc/self/smaps\",\"r\");\n} else {\nchar filename[128];\nsnprintf(filename,sizeof(filename),\"/proc/%ld/smaps\",pid);\nfp = fopen(filename,\"r\");\n}\nif (!fp) return 0;\nwhile(fgets(line,sizeof(line),fp) != NULL) { // 读取一行，存入line\nif (strncmp(line,field,flen) == 0) { // 比较flen长度的字符是否相等，使用strncmp防止内存泄漏 ; 这里是匹配key\n    char *p = strchr(line,'k'); // 指针p指向\"kB\"字符串\n    if (p) {\n        *p = '\\0'; // 将\"kB\"设置为空\n        bytes += strtol(line+flen,NULL,10) * 1024; // line表示数组首地址，line+flen表示从line[flen]开始，这过滤掉key，直接获取数字\n    }\n}\n}\nfclose(fp);\nreturn bytes;\n}\n#else\n// 系统中没有smaps文件，直接置0\nsize_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {\n((void) field);\n((void) pid);\nreturn 0;\n}\n#endif\n// 从/proc/getpid()/smaps文件获取字段\"Private_Dirty:\"的值\nsize_t zmalloc_get_private_dirty(long pid) {\nreturn zmalloc_get_smap_bytes_by_field(\"Private_Dirty:\",pid);\n}\n/* Returns the size of physical memory (RAM) in bytes.\n* It looks ugly, but this is the cleanest way to achieve cross platform results.\n* Cleaned up from:\n*\n* http://nadeausoftware.com/articles/2012/09/c_c_tip_how_get_physical_memory_size_system\n*\n* Note that this function:\n* 1) Was released under the following CC attribution license:\n*    http://creativecommons.org/licenses/by/3.0/deed.en_US.\n* 2) Was originally implemented by David Robert Nadeau.\n* 3) Was modified for Redis by Matt Stancliff.\n* 4) This note exists in order to comply with the original license.\n*/\n// 获取物理内存字节数(最适合跨平台使用)\nsize_t zmalloc_get_memory_size(void) {\n#if defined(__unix__) || defined(__unix) || defined(unix) || \\\n(defined(__APPLE__) && defined(__MACH__))\n#if defined(CTL_HW) && (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))\nint mib[2];\nmib[0] = CTL_HW;\n#if defined(HW_MEMSIZE)\nmib[1] = HW_MEMSIZE;            /* OSX. --------------------- */\n#elif defined(HW_PHYSMEM64)\nmib[1] = HW_PHYSMEM64;          /* NetBSD, OpenBSD. --------- */\n#endif\nint64_t size = 0;               /* 64-bit */\nsize_t len = sizeof(size);\nif (sysctl( mib, 2, &size, &len, NULL, 0) == 0)\nreturn (size_t)size;\nreturn 0L;          /* Failed? */\n#elif defined(_SC_PHYS_PAGES) && defined(_SC_PAGESIZE)\n/* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */\nreturn (size_t)sysconf(_SC_PHYS_PAGES) * (size_t)sysconf(_SC_PAGESIZE);\n#elif defined(CTL_HW) && (defined(HW_PHYSMEM) || defined(HW_REALMEM))\n/* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */\nint mib[2];\nmib[0] = CTL_HW;\n#if defined(HW_REALMEM)\nmib[1] = HW_REALMEM;        /* FreeBSD. ----------------- */\n#elif defined(HW_PHYSMEM)\nmib[1] = HW_PHYSMEM;        /* Others. ------------------ */\n#endif\nunsigned int size = 0;      /* 32-bit */\nsize_t len = sizeof(size);\nif (sysctl(mib, 2, &size, &len, NULL, 0) == 0)\nreturn (size_t)size;\nreturn 0L;          /* Failed? */\n#else\nreturn 0L;          /* Unknown method to get the data. */\n#endif\n#else\nreturn 0L;          /* Unknown OS. */\n#endif\n}\n#ifdef REDIS_TEST\n#define UNUSED(x) ((void)(x))\nint zmalloc_test(int argc, char **argv) {\nvoid *ptr;\nUNUSED(argc);\nUNUSED(argv);\nprintf(\"Initial used memory: %zu\\n\", zmalloc_used_memory());\nptr = zmalloc(123);\nprintf(\"Allocated 123 bytes; used: %zu\\n\", zmalloc_used_memory());\nptr = zrealloc(ptr, 456);\nprintf(\"Reallocated to 456 bytes; used: %zu\\n\", zmalloc_used_memory());\nzfree(ptr);\nprintf(\"Freed pointer; used: %zu\\n\", zmalloc_used_memory());\nreturn 0;\n}\n#endif\n```\n","tags":["源码阅读"],"categories":["redis封装类"]},{"title":"redis源码阅读-序","url":"%2F2019%2F12%2F15%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2FC%2Fredis%2Fredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BA%8F%2F","content":"\n## redis源码阅读\n\n### 序言\n>>    redis是由c语言编写的一款高性能nosql数据库，其代码量小，使用的数据结构和算法也非常的经典，很有利于我们学习数据结构和算法。\n>>    当前，redis缓存数据库被应用于各个大型项目中作为缓存中间件，其应用范围很广泛，研读其源码能让我们更加清楚redis的内部机制，更好的操作redis。\n>>    现在让我们一起进入redis的源码世界，畅游数据结构与算法的海洋。\n\n### 阅读源码的准备\n在阅读源码之前，我们首先要有两手准备，手头要有一本解析redis的书，能够让你快速的认识redis的各大模块，将redis的各个源码文件编组，一个模块一个模块的慢慢吃透。在这里，我给大家推荐一本书------![redis设计与实现(第二版)](redis设计与实现(第二版).pdf) ，它非常透彻的解析redis中采用的数据结构和算法，搭配这本书看源码，着实是一种享受。\n好了，现在开始!\n\n### redis源码编组\n>> 为了便于阅读源码，我根据自己理解，通过给源码文件功能不同分组。\n#### 事件驱动\n```C\nae.h\nae.c\nae_epoll.c\nae_evport.c\nae_kqueue.c\nae_select.c\n```\n#### 网络\n```C\nanet.c\nanet.h\nnetworking.c\n```\n#### 数据结构\n```C\nadlist.h\nadlist.c // 使用双向链表实现列表\nziplist.h\nziplist.c // 压缩列表,哈希键和列表键的底层实现\nzipmap.h\nzipmap.c // 压缩字典\nquicklist.h\nquicklist.c // 快速列表\ndict.h\ndict.c // 字典\nsds.h\nsdsalloc.h\nsds.c // 简单动态字符串\nintset.h\nintset.c // 整数集合\nrax.h\nrax_malloc.h\nrax.c // 基数数\nt_hash.c // 哈希对象\nt_list.c // 列表对象\nt_set.c // 集合对象\nstream.h\nt_stream.c // 流对象\nt_string.c // 字符串对象\nt_zset.c // 有序集合对象\nlistpack.h\nlistpack_malloc.h\nlistpack.c // redis5.0新特性，紧凑列表\ngeo.h\ngeo.c\ngeohash.h\ngeohash.c\ngeohash_helper.h\ngeohash_helper.c // 存储地理位置信息\nsiphash.c // 字典(hashtable)\n```\n#### 工具\n```C\ncrc64.h\ncrc16.c\ncrc64.c // 循环冗余校验码\nrand.h\nrand.c // 随机数\nsha1.h\nsha1.c // sha1加密算法\nsort.c // 排序\nutil.h\nutil.c // 工具\npqsort.h\npqsort.c // 部分快速算法\nbitops.c // 位操作\ndebug.c\ndebugmacro.h\ndefrag.c // debug用的\nlzf.h\nlzfP.h\nlzf_c.c\nlzf_d.c // lzf压缩算法\nrelease.c\nhelp.h\nsparkline.h\nsparkline.c // 微线图\nendianconv.h\nendianconv.c // 大端与小端存储\nsetproctitle.c // 修改进程名称\n```\n\n#### 封装类\n```C\natomicvar.h // 封装的gcc内置原子操作函数\nzmalloc.h\nzmalloc.c // 封装的内存分配函数\nbio.h\nbio.c // 封装的io(background io)开启后台线程\nsyncio.c // 同步io\nnotify.c // 通知类\nobject.c // 创建和释放redisObject对象\npubsub.c // 发布订阅实现\nlatency.h\nlatency.c // 延迟类\nrio.h\nrio.c // redis定义的io\nslowlog.h\nslowlog.c\nhyperloglog.c // redis定义的日志类型\n```\n#### 测试\n```C\nmemtest.c // 内存测试\nredis-benchmark.c // 性能测试\ntesthelp.h // c风格小型测试框架\nredis-check-aof.c // aof测试\n```\n#### 数据操作\n```C\naof.c // aof实现\nrdb.h\nrdb.c // rdb实现\ndb.c // 数据库操作实现\nconfig.h\nconfig.c // 对配置文件的操作\nmulti.c // 事务处理操作\nreplication.c // 主从数据库复制操作实现\n```\n#### 平台兼容问题\n```C\nfmacros.h // 兼容mac\nsolarisfixes.h // 兼容solaris\n```\n#### redis基本信息\n```C\nversion.h // redis版本信息\nasciilogo.h // redis logo\n```\n# redis核心功能\n```C\nblocked.c // 阻塞实现\nchildinfo.c // 持久化优化(管道)\ncluster.h\ncluster.c // redis集群实现\nevict.c // 内存淘汰机制\nexpire.c // 过期机制\nredismodule.h\nmodule.c // 定义reids模块\nredis-trib.rb //\nscripting.c // redis脚本，使用lua解释器\nsentinel.c // 哨兵实现\nserver.h\nserver.c // 服务器端实现\nredis-cli.c // 客户端\nlazyfree.c // redis4.0新特性，解决Big Key(主要指定元素较多集合类型Key)删除的风险\nlocaltime.c // 时间实现函数\n```\n#### 其他\n```C\nlolwut5.c\nlolwut.c // 一个有趣的命令，redis的一个彩蛋\nmkreleasehdr.sh // 制作发布redis\nredisassert.h // 断言\n```\n以上，列举了redis的所有源码文件，并给源码文件做了简单的功能说明\n\n### 参考文献\n  + [redis源码分析](https://mp.weixin.qq.com/mp/homepage?__biz=MzU2MTkwMTE4Nw==&hid=1&sn=53a267891b540fad9158d048718c2fa9&scene=18#wechat_redirect)\n\n","tags":["源码阅读"],"categories":["redis"]},{"title":"C语言使用cJSON解析json文件","url":"%2F2019%2F12%2F07%2FC%2Fclib%2FC%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8cJSON%E8%A7%A3%E6%9E%90json%E6%96%87%E4%BB%B6%2F"},{"title":"C语言使用libxml库解析xml文件","url":"%2F2019%2F12%2F07%2FC%2Fclib%2FC%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8libxml%E5%BA%93%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6%2F","content":"\n## C语言使用libxml库解析xml文件\n\n### libxml\n#### libxml介绍\n\n#### libxml主要函数和类型\n\n### c语言解析xml实例\n","tags":["libxml"],"categories":["libxml"]},{"title":"varnish安装与应用","url":"%2F2019%2F11%2F28%2F%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%2Fvarnish%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8%2F","content":"\n## varnish\n\n### 引言\n> varnish是一款高性能的开源的方向代理服务器和http加速器。\n\n### 安装部署\n```\nuseradd  -s /sbin/nologin  varnish\nmkdir  /data/vanish/cache -pv\nmkdir  /data/vanish/log\nchown  -R varnish:varnish /data/vanish/cache/\nchown  -R varnish:varnish /data/vanish/log/\n```\n#### 源码安装\n```\nsudo yum install \\\n    make \\\n    autoconf \\\n    automake \\\n    jemalloc-devel \\\n    libedit-devel \\\n    libtool \\\n    ncurses-devel \\\n    pcre-devel \\\n    pkgconfig \\\n    python3-docutils \\\n    python3-sphinx\n\nyum install graphviz\nyum install git\n\ncd varnish\nsh autogen.sh\nsh configure\nmake\nmake test\nmake install\n```\n\n#### 从源安装(推荐)\n```\n创建varn.repo\n[varnishcache_varnish60lts]\nname=varnishcache_varnish60lts\nbaseurl=https://packagecloud.io/varnishcache/varnish60lts/el/6/$basearch\nrepo_gpgcheck=1\ngpgcheck=0\nenabled=1\ngpgkey=https://packagecloud.io/varnishcache/varnish60lts/gpgkey\nsslverify=1\nsslcacert=/etc/pki/tls/certs/ca-bundle.crt\nmetadata_expire=300\n\n[varnishcache_varnish60lts-source]\nname=varnishcache_varnish60lts-source\nbaseurl=https://packagecloud.io/varnishcache/varnish60lts/el/6/SRPMS\nrepo_gpgcheck=1\ngpgcheck=0\nenabled=1\ngpgkey=https://packagecloud.io/varnishcache/varnish60lts/gpgkey\nsslverify=1\nsslcacert=/etc/pki/tls/certs/ca-bundle.crt\nmetadata_expire=300\n\nyum clean all\nyum makecache\nyum install varnish\n```\n\n### 初步配置\n```\n# 开启服务\nservice varnish start\n# 默认从rack-leen.top的80端口中拉取数据缓存 varnish可以定义几个backend,并将其加入负载均衡\n/etc/varnish/default.vcl\nbackend default {\n    .host = \"rack-leen.top\";\n    .port = \"80\";\n}\n\n# 更改监听端口\n# 原理： varnish相当于一堵墙，用户请求的时候是先经过varnish，如果其后是varnish代理用户拉取目标服务器的数据，因此用户访问的是varnish服务器\n/etc/varnish/varnish.params\n# 将监听端口改为需要访问的端口\nVARNISH_LISTEN_PORT=6081\n```\n\n### 注意\nvarnish6.3依赖systemed python3\n\nvarnish默认只缓存get和head请求\n\n### 原理解析\n![a](052056081203728.gif)  \n首先，varnish接收到访问请求(vcl_recv)\n然后，有三个选项，(本地查询，直接pass和pipe) 默认本地查询\n  + pipe，用户将请求直接传递至后端主机，在请求和返回的内容没有改变的情况下，将不变的内容返回给客户端，直到这个链接被关闭。\n  + pass,直接拉取backend服务器数据。\n  + 本地查询，查询varnish服务器中是否存在缓存  \n    如果有，则访问这个缓存，之后有两个选项，是否将缓存发送到客户端，是则直接将缓存发送(deliver)给客户端，如果不是则进入pass状态，然后拉取backend服务器数据。  \n    如果没有，直接拉取backend服务器数据。\n  \n拉取(fetch)backend中的服务器数据。然后判断是否缓存，如果不缓存，直接将服务器数据传给客户端，如果缓存，则先将数据缓存到varnish，再发送给客户端。\n### 使用vcl编写配置\n编写/etc/varnish/default.vcl[下载](default.vcl)\n```vcl\nimport directors;\nimport std ;\n\n# 访问控制，清理varnish缓存的角色\nacl purge {\n    \"127.0.0.1\";\n    \"localhost\";\n}\n\n# 需要请求的目标服务器\nbackend default {\n    .host = \"\";\n    .port = \"\";\n}\n\nbackend nginx1 {\n    .host = \"\";\n    .port = \"\";\n}\n\nbackend nginx2 {\n    .host = \"\";\n    .port = \"\";\n}\n\n# 刚开始初始化的方法\nsub vcl_init {\n    new bar = directors.round_robin(); # 创建负载均衡的服务器组,采用轮询方式\n    bar.add_backend(nginx1) ;\n    bar.add_backend(nginx2) ;\n}\n\n# 接收方法\nsub vcl_recv {\n    set req.backend_hint = bar.backend() ; # 接收请求命中的服务器是bar组中的服务器\n\n    if (req.method == \"PURGE\") { # 清理缓存\n        if (!client.ip ~ purge) { # 如果不是本机，不能清理缓存\n            return (synth(405 , \"This IP is not allowed to send PURGE requests.\"));\n        }\n\n        return (purge) ;\n    }\n\n    # 如果不是这些方法，就使用pipe模式，直接与服务器连接,直到pipe连接关闭\n    if (req.method != \"GET\" && \n            req.method != \"HEAD\" && \n            req.method != \"PUT\" && \n            req.method != \"POST\" && \n            req.method != \"TRACE\" &&\n            req.method != \"OPTIONS\" &&\n            req.method != \"PATCH\" &&\n            req.method != \"DELETE\") {\n                return (pipe) ;\n            }\n    \n    # 如果请求方法不是GET和HEAD，就直接访问服务器拉取数据，因为GET和HEAD访问的比较频繁，而且获取的内容相同，需要做缓存\n    if (req.method != \"GET\" && req.method != \"HEAD\") {\n        return (pass) ;\n    }\n\n    # 如果请求的是大文件，就不要把它放到cookie里面了\n    if (req.url ~ \"^[^?]*\\.(bmp|bz2|css|doc|eot|flv|gif|gz|ico|jpeg|jpg|js|less|pdf|png|rtf|swf|txt|woff|xml)(\\?.*)?$\") {\n        unset req.http.Cookie ;\n        # 先本地查询\n        return (hash) ;\n    }\n\n    # 没有足够权限获取缓存，就直接拉取\n    if (req.http.Authorization) {\n        return (pass) ;\n    }\n\n    # 如果是上诉其他情况，请求之后，就进入本地查询\n    return (hash) ;\n}\n\n# 管道直连，直到pipe关闭，连接才关闭\nsub vcl_pipe {\n    return (pipe) ;\n}\n\n# 将请求进行hash算法，得到唯一值\nsub vcl_hash {\n    hash_data(req.url); # 获取请求url的hash\n    if (req.http.host) { # 如果请求的是域名\n        hash_data(req.http.host);\n    }else { # 否则直接使用主机ip\n        hash_data(server.ip) ;\n    }\n    # 如果存在cookie\n    if (req.http.Cookie) {\n        hash_data(req.http.Cookie) ;\n    }\n}\n\n# 命中varnish 中的缓存\nsub vcl_hit {\n    return (deliver) ; # 命中之后就直接返回给客户端\n}\n\nsub vcl_miss {\n    std,log(\"url miss! the url= \" + req.url) ; # 输出未命中的url\n    return (fetch) ; # 如果没有缓存，就拉取服务器的数据\n}\n\n# 这个函数可以设置缓存生命周期\nsub vcl_backend_response {\n    # 如果被请求的是大文件\n    if (bereq.url ~ \"^[^?]*\\.(bmp|bz2|doc|eot|flv|gif|gz|ico|jpeg|jpg|less|mp[34]|pdf|png|rar|rtf|swf|tar|tgz|txt|wav|woff|xml|zip)(\\?.*)?$\") {\n        unset beresp.http.set-cookie ; # 取消设置缓存\n        set beresp.ttl = 1h ; # 设置生命周期为1小时\n    }\n\n    # 如果请求的是静态文件\n    if (bereq.url ~ \"^[^?]*\\.(css|js|html)(\\?.*)?$\") {\n        set beresp.ttl = 10m ; # 设置生命周期为10分钟\n    } \n\n    if (beresp.ttl <= 0s || beresp.http.Set-Cookie || beresp.http.Vary == \"*\") {\n        set beresp.ttl = 120s ;\n        set beresp.uncacheable = true ; # 设置不缓存\n        return (deliver) ;\n    }\n\n    set beresp.grace = 1h;\n\n    return (deliver) ;\n}\nsub vcl_deliver {\n    if (obj.hits > 0) { # 如果命中缓存次数大于0，表示varnish中有缓存，直接使用缓存\n        set resp.http.X-Cache = \"Cache\" ;\n    }else { # 否则就从目标服务器拉取数据\n        set resp.http.X-Cache = \"UnCache\" ;\n    }\n\n    return (deliver) ; # 最终返回客户端\n}\n```\n\n### 测试\n```\ncurl -I rack-leen.top:6081 # 首次获取header信息\nHTTP/1.1 200 OK\nDate: Thu, 31 Oct 2019 09:47:07 GMT\nServer: Apache\nX-Frame-Options: SAMEORIGIN\nLast-Modified: Mon, 29 Jul 2019 10:16:47 GMT\nVary: Accept-Encoding\nContent-Type: text/html\nX-Varnish: 98307\nAge: 0\nVia: 1.1 varnish-v4\nETag: W/\"2602a-58ecf3085c1c0-gzip\"\nX-Cache: UnCache # 这里表示varnish还没有缓存，直接拉取的目标服务器数据\nConnection: keep-alive\n\ncurl -I rack-leen.top:6081 # 再次获取header信息\nHTTP/1.1 200 OK\nDate: Thu, 31 Oct 2019 09:10:48 GMT\nServer: Apache\nX-Frame-Options: SAMEORIGIN\nLast-Modified: Mon, 29 Jul 2019 10:16:47 GMT\nVary: Accept-Encoding\nContent-Type: text/html\nX-Varnish: 65555 65551\nAge: 2117\nVia: 1.1 varnish-v4\nETag: W/\"2602a-58ecf3085c1c0-gzip\"\nX-Cache: Cache # 之前已经将信息缓存下来，这里已经开始访问缓存\nConnection: keep-alive\n\ncurl -X PURGE rack-leen.top:6081 # 清除缓存\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>200 Purged</title>\n  </head>\n  <body>\n    <h1>Error 200 Purged</h1>\n    <p>Purged</p>\n    <h3>Guru Meditation:</h3>\n    <p>XID: 32778</p>\n    <hr>\n    <p>Varnish cache server</p>\n  </body>\n</html>\n```","tags":["工具安装与部署"],"categories":["工具安装与部署"]},{"title":"zookeeper安装与应用","url":"%2F2019%2F11%2F26%2F%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%2Fzookeeper%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8%2F","content":"\n## zookeeper安装与应用\n\n### zookeeper介绍\n\n> Apache ZooKeeper is an effort to develop and maintain an open-source server which enables highly reliable distributed coordination.\n\n- zookeeper是Apache下属的一个顶级开源项目[官网](https://zookeeper.apache.org/)，是一个分布式下高可用的开源服务。\n\n  \n\n### zookeeper功能\n\n> ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. \n\n- 在apache项目中，许多项目是以动物命名。zookeeper，动物管理员，顾名思义，管理动物园中的各种动物(各种开源项目)。按其官网所描述，zookeeper是一个集中式服务，功能包括集中管理配置信息，名字服务，分布式锁以及集群管理。zookeeper主要用于分布式项目中，作为服务注册中心。\n\n1. 集中管理配置信息\n\n   如果在单机环境下，配置量较小，我们可以直接使用配置文件。但是在分布式环境下，多台服务器共同运行，有的服务器需要相同的配置，还需要动态更改，如果还是使用配置文件，我们修改配置文件就需要一台台的修改，有时还会修改错，这样即耗时又耗力。\n\n   还有一种选择，将配置信息保存到数据库(创建配置表)，所有需要配置的服务都去数据库读取配置。但是使用这种方式在分布式环境下并不是最优选择，因为分布式下所有服务都依赖这个数据库，数据库并不可靠(分布式下的并发问题)。\n\n   在分布式下，zookeeper是一个比较好的选择，采用集中式配置服务来管理配置信息。zookeeper具有可复制性，一般使用集群来提供配置服务，使其具有高可靠性，并且还要使用一致性协议服务保持分布式下的一致性。\n\n2. 名字服务\n\n   zookeeper提供名字服务，它有点像linux标准文件系统，以\"/\"为根目录，其下的为子目录项，这些目录项被称为znode(目录节点)，它比文件系统的目录多一个功能，可以存储数据。\n\n![zknamespace](zknamespace.jpg)\n\n有四种znode\n\n中文名称 | 英文名称 | 功能\n-|-|-|\n持久化目录节点| PERSISTENT|断开连接后节点仍然存在\n持久化顺序编号目录节点|PERSISTENT_SEQUENTIAL|断开连接后节点仍然存在但重新顺序编号\n临时目录节点|EPHEMERAL|节点由客户端创建，断开连接后节点删除\n临时顺序编号目录节点|EPHEMERAL_SEQUENTIAL|断开连接后节点删除但重新顺序编号\n\n3. 分布式锁\n\n   zookeeper是一个分布式协调服务，可以通过分布式锁协调多个分布式服务。比如，一个集群中，同一服务被复制到多台服务器上提高可靠性。但是做一件事只能一个服务进行，这就需要分布式锁，同一时刻只能一个服务工作，直到出错释放。这种设计被称为leader选举(leader election)。\n\n![zookeeper集群](zookeeper集群.jpg)\n\n4. 集群管理\n\n   在多台服务器组成的集群中，需要监控每台服务器状态，集群可以主动感知节点的死亡和节点的加入。在集群中，每个服务器需要在zk服务器创建临时节点，当服务器挂掉，临时节点会被删除，并触发监视器，通知其他服务器。\n\n### zookeeper安装\n\n### zookeeper配置\n\n\n\n### 文献参考\n\n1. [Zookeeper到底是干嘛的](https://www.cnblogs.com/ultranms/p/9585191.html)\n2. [zookeeper官网](https://zookeeper.apache.org/doc/current/zookeeperOver.html)\n3. [Zookeeper入门看这篇就够了](https://blog.csdn.net/java_66666/article/details/81015302)\n4. [学习笔记和总结](https://www.cnblogs.com/luangeng/)"},{"title":"kibana安装与应用","url":"%2F2019%2F11%2F26%2F%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%2Fkibana%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8%2F","content":"\n### kibana安装\n\n```\ncurl -o kibana-7.4.0-linux-x86_64.tar.gz https://artifacts.elastic.co/downloads/kibana/kibana-7.4.0-linux-x86_64.tar.gz\ntar -zxvf kibana-7.4.0-linux-x86_64.tar.gz -C /opt/elk\n\ncd kibana-7.4.0\n\n```"},{"title":"elasticsearch安装与应用","url":"%2F2019%2F11%2F26%2F%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%2Felasticsearch%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8%2F","content":"## elasticsearch\n\n### elasticsearch介绍\n```\nelasticsearch ， 是一个基于[Lucene](https://lucene.apache.org/)的搜索服务器。它提供了一个基于RESTFul web 接口的分布式多用户能力的全文搜索引擎。它处理大数据非常的快，支持非结构化数据的搜索。\n```\n### elasticsearch安装\n  1. 下载elasticsearch-7.4.3\n```\nwget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.4.2-linux-x86_64.tar.gz\n```\n  2. 安装\n```\ntar -zxvf elasticsearch-7.4.2-linux-x86_64.tar.gz -C /opt/elk/\n\n# 创建elasticsearch账户\nuseradd elasticsearch\nchown -R elasticsearch:elasticsearch elasticsearch-7.4.0\n\ncd /opt/elk\ncd elasticsearch-7.4.2\n# es目录结构\nls -l\ndrwxr-xr-x  2 gnome gnome   4096  9月 27 16:40 bin        # 可执行文件目录\ndrwxr-xr-x  2 gnome gnome   4096 10月 20 17:11 config     # 配置文件目录\ndrwxr-xr-x 10 gnome gnome   4096  9月 27 16:40 jdk  \t\t# 自带jdk目录\ndrwxr-xr-x  3 gnome gnome   4096  9月 27 16:40 lib\t\t# 库目录\n-rw-r--r--  1 gnome gnome  13675  9月 27 16:35 LICENSE.txt \ndrwxr-xr-x  2 gnome gnome   4096  9月 27 16:40 logs\t\t# 日志目录\ndrwxr-xr-x 37 gnome gnome   4096  9月 27 16:40 modules\t# 模块目录\n-rw-r--r--  1 gnome gnome 523209  9月 27 16:40 NOTICE.txt\ndrwxr-xr-x  2 gnome gnome   4096  9月 27 16:40 plugins\t# 插件目录\n-rw-r--r--  1 gnome gnome   8500  9月 27 16:35 README.textile\n```\n### elasticsearch配置\n\n#### 单机配置\n  1. 进入配置目录\n```\ncd config\n\nls\n-rw-r----- 1 gnome gnome  2867 10月 20 17:11 elasticsearch.yml # es配置文件\n-rw-r----- 1 gnome gnome  3593  9月 27 16:35 jvm.options # jvm虚拟机选项\n-rw-r----- 1 gnome gnome 17545  9月 27 16:40 log4j2.properties # 日志文件\n-rw-r----- 1 gnome gnome   473  9月 27 16:40 role_mapping.yml  # 角色映射文件\n-rw-r----- 1 gnome gnome   197  9月 27 16:40 roles.yml  # 角色文件\n-rw-r----- 1 gnome gnome     0  9月 27 16:40 users  # 用户文件\n-rw-r----- 1 gnome gnome     0  9月 27 16:40 users_roles # 用户角色\n\n```\n  2. elasticsearch.yml配置文件\n```bash\n# ======================== Elasticsearch Configuration =========================\n#\n# NOTE: Elasticsearch comes with reasonable defaults for most settings.\n#       Before you set out to tweak and tune the configuration, make sure you\n#       understand what are you trying to accomplish and the consequences.\n#\n# The primary way of configuring a node is via this file. This template lists\n# the most important settings you may want to configure for a production cluster.\n#\n# Please consult the documentation for further information on configuration options:\n# https://www.elastic.co/guide/en/elasticsearch/reference/index.html\n#\n# ---------------------------------- Cluster -----------------------------------\n#\n# Use a descriptive name for your cluster:\n#\ncluster.name: elasticsearch # 集群名称，一般需要有意义\n#\n# ------------------------------------ Node ------------------------------------\n#\n# Use a descriptive name for the node:\n#\nnode.name: node-master # 节点名\nnode.master: true # 是主节点\n# node.data: false \n#\n# Add custom attributes to the node:\n#\n#node.attr.rack: r1\n#\n# ----------------------------------- Paths ------------------------------------\n#\n# Path to directory where to store the data (separate multiple locations by comma):\n#\npath.data: /opt/elk/elasticsearch-7.4.0/data # 数据存储路径\n#\n# Path to log files:\n#\npath.logs: /opt/elk/elasticsearch-7.4.0/logs\t# 日志文件路径\n#\n# ----------------------------------- Memory -----------------------------------\n#\n# Lock the memory on startup:\n#\n# 内存\nbootstrap.memory_lock: false\nbootstrap.system_call_filter: false\n\n# 允许跨域\nhttp.cors.enabled: true\nhttp.cors.allow-origin: \"*\"\n#\n# Make sure that the heap size is set to about half the memory available\n# on the system and that the owner of the process is allowed to use this\n# limit.\n#\n# Elasticsearch performs poorly when the system is swapping the memory.\n#\n# ---------------------------------- Network -----------------------------------\n#\n# Set the bind address to a specific IP (IPv4 or IPv6):\n#\nnetwork.host: 0.0.0.0 # 本节点绑定主机\n#\n# Set a custom port for HTTP:\n#\nhttp.port: 9200 # es开放端口\ntransport.tcp.port: 9300\n#\n# For more information, consult the network module documentation.\n#\n# --------------------------------- Discovery ----------------------------------\n#\n# Pass an initial list of hosts to perform discovery when this node is started:\n# The default list of hosts is [\"127.0.0.1\", \"[::1]\"]\n#\n#discovery.seed_hosts: [\"host1\", \"host2\"]\n#\n# Bootstrap the cluster using an initial set of master-eligible nodes:\n\ncluster.initial_master_nodes: [\"127.0.0.1\"]\n#\n#cluster.initial_master_nodes: [\"node-1\", \"node-2\"]\n#\n# For more information, consult the discovery and cluster formation module documentation.\n#\n# ---------------------------------- Gateway -----------------------------------\n#\n# Block initial recovery after a full cluster restart until N nodes are started:\n#\n#gateway.recover_after_nodes: 3\n#\n# For more information, consult the gateway module documentation.\n#\n# ---------------------------------- Various -----------------------------------\n#\n# Require explicit names when deleting indices:\n#\n#action.destructive_requires_name: true\n\n```\n  3. jvm.options配置(一般默认)\n```\n## JVM configuration\n\n################################################################\n## IMPORTANT: JVM heap size\n################################################################\n##\n## You should always set the min and max JVM heap\n## size to the same value. For example, to set\n## the heap to 4 GB, set:\n##\n## -Xms4g\n## -Xmx4g\n##\n## See https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html\n## for more information\n##\n################################################################\n\n# Xms represents the initial size of total heap space\n# Xmx represents the maximum size of total heap space\n\n-Xms1g\t# java虚拟机初始堆容量\n-Xmx1g\t# java虚拟机最大堆容量\n\n################################################################\n## Expert settings\n################################################################\n##\n## All settings below this section are considered\n## expert settings. Don't tamper with them unless\n## you understand what you are doing\n##\n################################################################\n\n## GC configuration 垃圾回收配置\n-XX:+UseConcMarkSweepGC\n-XX:CMSInitiatingOccupancyFraction=75\n-XX:+UseCMSInitiatingOccupancyOnly\n\n## G1GC Configuration\n# NOTE: G1GC is only supported on JDK version 10 or later.\n# To use G1GC uncomment the lines below.\n# 10-:-XX:-UseConcMarkSweepGC\n# 10-:-XX:-UseCMSInitiatingOccupancyOnly\n# 10-:-XX:+UseG1GC\n# 10-:-XX:G1ReservePercent=25\n# 10-:-XX:InitiatingHeapOccupancyPercent=30\n\n## DNS cache policy\n# cache ttl in seconds for positive DNS lookups noting that this overrides the\n# JDK security property networkaddress.cache.ttl; set to -1 to cache forever\n-Des.networkaddress.cache.ttl=60\n# cache ttl in seconds for negative DNS lookups noting that this overrides the\n# JDK security property networkaddress.cache.negative ttl; set to -1 to cache\n# forever\n-Des.networkaddress.cache.negative.ttl=10\n\n## optimizations\n\n# pre-touch memory pages used by the JVM during initialization\n-XX:+AlwaysPreTouch\n\n## basic\n\n# explicitly set the stack size\n-Xss1m\n\n# set to headless, just in case\n-Djava.awt.headless=true\n\n# ensure UTF-8 encoding by default (e.g. filenames)\n-Dfile.encoding=UTF-8\n\n# use our provided JNA always versus the system one\n-Djna.nosys=true\n\n# turn off a JDK optimization that throws away stack traces for common\n# exceptions because stack traces are important for debugging\n-XX:-OmitStackTraceInFastThrow\n\n# flags to configure Netty\n-Dio.netty.noUnsafe=true\n-Dio.netty.noKeySetOptimization=true\n-Dio.netty.recycler.maxCapacityPerThread=0\n-Dio.netty.allocator.numDirectArenas=0\n\n# log4j 2\n-Dlog4j.shutdownHookEnabled=false\n-Dlog4j2.disable.jmx=true\n\n-Djava.io.tmpdir=${ES_TMPDIR}\n\n## heap dumps\n\n# generate a heap dump when an allocation from the Java heap fails\n# heap dumps are created in the working directory of the JVM\n-XX:+HeapDumpOnOutOfMemoryError\n\n# specify an alternative path for heap dumps; ensure the directory exists and\n# has sufficient space\n-XX:HeapDumpPath=data\n\n# specify an alternative path for JVM fatal error logs\n-XX:ErrorFile=logs/hs_err_pid%p.log\n\n## JDK 8 GC logging\n\n8:-XX:+PrintGCDetails\n8:-XX:+PrintGCDateStamps\n8:-XX:+PrintTenuringDistribution\n8:-XX:+PrintGCApplicationStoppedTime\n8:-Xloggc:logs/gc.log\n8:-XX:+UseGCLogFileRotation\n8:-XX:NumberOfGCLogFiles=32\n8:-XX:GCLogFileSize=64m\n\n# JDK 9+ GC logging\n9-:-Xlog:gc*,gc+age=trace,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m\n# due to internationalization enhancements in JDK 9 Elasticsearch need to set the provider to COMPAT otherwise\n# time/date parsing will break in an incompatible way for some date patterns and locals\n9-:-Djava.locale.providers=COMPAT\n\n```\n\n  4. 错误\n```\n# 虚拟内存问题\n[1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]\n# 解决\necho \"vm.max_map_count = 262144\" >> /etc/sysctl.conf\nsudo sysctl -p\n\n# 问题2\n[1]: the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured\n\n# 解决\ncluster.initial_master_nodes: [\"127.0.0.1\"]\n```\n  5. 配置完成\n```\ncurl http://localhost:9200/\n{\n  \"name\" : \"node-master\",\n  \"cluster_name\" : \"elasticsearch\",\n  \"cluster_uuid\" : \"_na_\",\n  \"version\" : {\n    \"number\" : \"7.4.0\",\n    \"build_flavor\" : \"default\",\n    \"build_type\" : \"tar\",\n    \"build_hash\" : \"22e1767283e61a198cb4db791ea66e3f11ab9910\",\n    \"build_date\" : \"2019-09-27T08:36:48.569419Z\",\n    \"build_snapshot\" : false,\n    \"lucene_version\" : \"8.2.0\",\n    \"minimum_wire_compatibility_version\" : \"6.8.0\",\n    \"minimum_index_compatibility_version\" : \"6.0.0-beta1\"\n  },\n  \"tagline\" : \"You Know, for Search\"\n}\n\n```\n#### 集群\n\n### 文献引用\n  1. [elasticsearch与solr对比](https://www.cnblogs.com/jajian/p/9801154.html)\n  2. [基于elasticsearch2.x的官方文档](https://www.elastic.co/guide/cn/elasticsearch/guide/current/running-elasticsearch.html)\n  3. [elastic中文社区](https://elasticsearch.cn/)\n  4. [elasticsearch安装与配置介绍](https://www.jianshu.com/p/1d2ddb92f6fb)\n  5. [Elasticsearch入门（三）：Elasticsearch 7.0.0 集群搭建](https://blog.csdn.net/Zereao/article/details/89373246)\n  6. [Elasticsearch 重要配置详解](https://blog.csdn.net/qq_28851503/article/details/83113966#_Elasticsearch_1)\n  7. [虚拟内存问题解决](https://blog.csdn.net/jiankunking/article/details/65448030)\n","tags":["工具安装与部署"],"categories":["工具安装与部署"]},{"title":"logstash安装与应用","url":"%2F2019%2F11%2F26%2F%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%2Flogstash%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8%2F","content":"\n## logstash\n\n### logstash介绍\n> logstash是一个开源的数据收集引擎，可以动态的将不同数据源的数据统一收集，并将数据按自定义配置规则标准化输入到指定输出源。\n\n### logstash安装\n  1. 下载安装\n```\nwget https://artifacts.elastic.co/downloads/logstash/logstash-7.4.2.tar.gz\ntar -zxvf logstash-7.4.2.tar.gz -C /opt/elk/\ncd logstash-7.4.0\n```\n  2. 配置文件\n```\nls config/*\n\n-rw-r--r-- 1 gnome gnome 2.0K  9月 27 18:20 jvm.options  # jvm选项\n-rw-r--r-- 1 gnome gnome 5.0K  9月 27 18:20 log4j2.properties # 日志配置\n-rw-r--r-- 1 gnome gnome  342  9月 27 18:20 logstash-sample.conf # logstash配置样例\n-rw-r--r-- 1 gnome gnome 8.1K  9月 27 18:20 logstash.yml  # logstash配置，一般不用管\n-rw-r--r-- 1 gnome gnome 3.1K  9月 27 18:20 pipelines.yml\n-rw-r--r-- 1 gnome gnome 1.7K  9月 27 18:20 startup.options # logstash启动选项\n\n# 我们一般是复制logstash-sample.conf，重命名为我们想要的配置文件名，最终的配置都是在新的conf文件。\n# 一般我们只需要更改conf配置文件就行了，其他默认。\n```\n\n### logstash配置解析\n> 详细配置请查看[官方文档](https://www.elastic.co/guide/en/logstash/current/index.html)\n> logstash配置主要是用ruby写过滤器(官方推荐尽量使用ruby脚本)\n```bash\ninput {\n    file{\n     \tpath => \"/opt/elk/logstash-7.4.0/test/*\"\n\t\tstart_position => \"beginning\"\n    }\n}\n\nfilter {\n\n    ruby {\n        path => \"/opt/elk/logstash-7.4.0/config/filter_file.rb\"\n\n    }\n\n#    mutate{\n#        remove_field => [\"input\",\"agent\",\"ecs\",\"log\",\"@version\",\"fields\",\"sort\"]\n#    }\n    \n}\n\noutput {\n\telasticsearch {\n        user => elastic\n        password => changeme\n        pool_max => 1000\n        pool_max_per_route => 200\n        hosts => [\"127.0.0.1:9200\"]\n        index => \"logstash-to-es-test-%{+YYYY.MM.dd}\"\n    }\n\n}\n\n```\n\n  ruby脚本\n\n```ruby\nrequire 'rubygems'\nrequire 'json'\nrequire 'pp'\n\n\ndef register(params)\n    @message = params[\"message\"]\nend\n\ndef filter(event)\n\t# 获取message中的数据\n\tmessage = event.get(\"message\")\n\n\t# 开始对message信息过滤\n\n\tpath = event.get('path')\n\tfilename = path.split('/')[path.split('/').length-1]\n\tname = filename.split('.')[0]\n\n\tif message != nil\n\t\tevent.set(\"filename\" , name)\n\t\tevent.set(\"message\" , message)\n\t\treturn [event]\n\telse\n\t\treturn []\nend\n\n```\n\n### logstash启动\n\n  1. 编写启动脚本\n```bash\n#! /bin/bash\n\n/opt/elk/logstash-7.4.0/bin/logstash -f  /opt/elk/logstash-7.4.0/config/filter_file.conf\n```","tags":["工具安装与部署"],"categories":["工具安装与部署"]},{"title":"kafka安装与应用","url":"%2F2019%2F11%2F26%2F%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%2Fkafka%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8%2F","content":"\n# kafka安装与应用\n\n## kafka介绍\n### kafka文档\n  1. 官网下载地址：https://downloads.apache.org/kafka/2.6.0/kafka_2.13-2.6.0.tgz\n  2. 国内源下载地址：https://mirrors.tuna.tsinghua.edu.cn/apache/kafka/2.6.0/kafka_2.13-2.6.0.tgz\n  3. 官方文档：https://kafka.apache.org/documentation/\n  4. 中文文档：https://kafka.apachecn.org/\n\n### kafka与zookeeper\nzookeeper是kafka不可分割的一部分，是kafka实现分布式下一致性的关键部件(kafka只实现了高可用性和分区容错性)。\nzookeeper+kafka组合实现了分布式的CAP理论(C:一致性+A:高可用性+P:分区容错性)。\nzookeeper存储了kafka的consumer和borker的信息，可以让kafka实现一致性。\n\n## kafka安装\n### kafka下载\n```shell\ncurl https://mirrors.tuna.tsinghua.edu.cn/apache/kafka/2.6.0/kafka_2.13-2.6.0.tgz -o kafka_2.13-2.6.0.tgz\nsudo tar -xvf kafka_2.13-2.6.0.tgz -C /opt/\ncd /opt/kafka_2.13-2.6.0\n```\n### 单机安装\n### 集群安装\n\n## kafka实现思想\n### kafka术语\n  1. broker\n  2. topic\n  3. partation\n  4. segment\n  5. replication\n\n### kafka原理图\n\n## kafka功能\n### kafka connect\n### kafka streams\n### kafka admin\n\n## kafka集群配置与问题\n### 脑裂问题\n\n## kafka应用\n### kafka用于收集日志\n### kafka用于消息队列"},{"title":"filebeat安装与应用","url":"%2F2019%2F11%2F26%2F%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%2Ffilebeat%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8%2F","content":"\n## filebeat\n\n### filebeat介绍\n> beats是一个elastic提供的轻量级的logstash，体积小，功能单一，性能强大，消耗内存小，通常作为收集日志链的前端。\n\nelastic提供了可以收集不同日志类型的beat\n名称 | 简介 | 功能\n-|-|-|-|\nauditbeat | audit data | 采集系统审计日志\nfilebeat | log files | 采集日志文件\nheartbeat | availabitily | 将资源（IP以及程序服务等资源）从一台已经故障的计算机快速转移到另一台正常运转的机器上继续提供服务，一般称之为高可用的服务\nmetricbeat | metrics | 从系统和服务收集指标\npacketbeat | network traffic | 网络抓包、嗅探以及分析工具\nwinlogbeat | windows event logs | 采集windows各种事件日志\n\n### filebeat安装\n\n```\ncurl https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.4.2-linux-x86_64.tar.gz -o filebeat-7.4.2.tar.gz\n\ntar -zxvf filebeat-7.4.2.tar.gz\ncd filebeat-7.4.2\n\nls\n\n-rw-r--r--  1 root root 266K 10月 29 03:46 fields.yml\n-rwxr-xr-x  1 root root  72M 10月 29 03:47 filebeat\n-rw-r--r--  1 root root  80K 10月 29 03:46 filebeat.reference.yml\n-rw-------  1 root root 8.0K 10月 29 03:46 filebeat.yml\ndrwxr-xr-x  3 root root 4.0K 10月 29 03:46 kibana\n-rw-r--r--  1 root root  14K 10月 29 03:09 LICENSE.txt\ndrwxr-xr-x 36 root root 4.0K 10月 29 03:46 module\ndrwxr-xr-x  2 root root 4.0K 10月 29 03:46 modules.d\n-rw-r--r--  1 root root 244K 10月 29 03:09 NOTICE.txt\n-rw-r--r--  1 root root  802 10月 29 03:48 README.md\n\n```\n\n### filebeat配\n\n\n\n### 文献参考\n\n1. [开始使用filebeat](https://www.cnblogs.com/cjsblog/p/9445792.html)\n\n","tags":["工具安装与部署"],"categories":["工具安装与部署"]},{"title":"caffeine缓存库","url":"%2F2019%2F11%2F26%2FJava%2FJava%E7%BC%93%E5%AD%98%2Fcaffeine%E7%BC%93%E5%AD%98%E5%BA%93%2F","content":"\n## caffeine缓存库\n\n### caffeine介绍\ncaffeine是基于guava cache的java缓存库，其api与guava相似。\n\n### 缓存结构\n![缓存结构](缓存结构.png)\n\n### java缓存发展\n![java缓存发展](java缓存发展.png)\n\n### caffeine驱逐策略\n\n#### 基于时间驱逐策略\n\n> caffeine为缓存设置过期时间来进行淘汰驱逐。基于时间驱逐策略默认使用jvm内存，jvm内存有多大，就可以缓存多大。\n\n  1. 设置写入时间过期\n\n```java\n// 设置写入时间过期\nCache<String , String> cache = Caffeine.newBuilder()\n                                        .expireAfterWrite(1 , TimeUnit.SECONDS)\n                                        .recordStats() // 获取命中率\n                                        .build();\n// 解释：数据写入缓存之后的时间，这里设置数据写入缓存1秒钟后过期。\n```\n  2. 设置访问时间过期\n```java\n// 设置访问时间过期\nCache<String , String> cache = Caffeine.newBuilder()\n                                        .expireAfterAccess(10 , TimeUnit.SECONDS)\n                                        .recordStats() // 获取命中率\n                                        .build();\n//解释：数据写入缓存后，下一次有相同的数据通过get访问缓存之后的时间，这里设置访问缓存10秒钟后过期。\n```\n#### 基于缓存大小驱逐策略\n> caffeine设置缓存容量大小，超出这个容量则采用Window TinyLfu策略删除缓存。\n\n  1. 设置缓存容量最大值\n```java\n// 设置缓存容量最大值过期\nCache<String , String> cache = Caffeine.newBuilder()\n                                        .maximumSize(200000) // 缓存最大容量,如果缓存量大，需要\n                                        .recordStats() // 获取命中率\n                                        .build();\n// 解释：这里设置缓存最大能容纳200000条数据，如果超出这个限制，就会通过Window TinyLfu策略删除缓存。\n```\n\n#### 基于引用驱逐策略\n> caffeine通过key的引用强度，使用垃圾回收器对key进行回收。\n\n引用类型 | 被垃圾回收时间 | 用途 | 生存时间\n-|-|-|-\n强引用|    从来不会    |   对象的一般状态|    JVM停止运行时终止\n软引用|    在内存不足时| 对象缓存|   内存不足时终止\n弱引用|    在垃圾回收时| 对象缓存|   gc运行后终止\n虚引用|    Unknown|    Unknown|    Unknown\n\n  1. 强引用\n    强引用从来不会被垃圾回收，当内存满之后抛出OutOfMemoryError异常，直接退出。\n\n```java\n    @Test\n    void test1() {\n        ArrayList<byte[]> objects = new ArrayList<>();\n        try {\n            while (true) {\n                objects.add(new byte[1024]);\n            }\n        }catch (OutOfMemoryError e) {\n            e.printStackTrace();\n        }\n    }\n```\n```\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n2019-11-28 16:14:14.970  INFO 240500 --- [extShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'\n*** java.lang.instrument ASSERTION FAILED ***: \"!errorOutstanding\" with message can't create name string at JPLISAgent.c line: 807\n```\n  2. 软引用\n    软引用在内存不足时(虚拟机即将抛出OutOfMemoryError异常),jvm会发起一次gc回收，将堆中只被非强引用的对象回收。如果回收之后虚拟机仍然内存不足，则抛出OutOfMemoryError异常。\n```java\n @Test\n    void test2(){\n        ArrayList<SoftReference<byte[]>> softReferences = new ArrayList<>();\n        ReferenceQueue<Object> objectReferenceQueue = new ReferenceQueue<>();\n        try {\n            while (true) {\n                softReferences.add(new SoftReference<>(new byte[1024] , objectReferenceQueue));\n            }\n        }catch (OutOfMemoryError e) {\n            e.printStackTrace();\n        }\n    }\n```\n  3. 弱引用\n    和软引用类似，比软引用强度更弱。弱引用对象只能活到下一次jvm执行垃圾回收之前(每一次jvm垃圾回收都会回收那些弱引用对象)。\n```java\n @Test\n    void test3() {\n        ArrayList<WeakReference<byte[]>> weakReferences = new ArrayList<>();\n        ReferenceQueue<Object> objectReferenceQueue = new ReferenceQueue<>();\n\n        try {\n            while (true) {\n                weakReferences.add(new WeakReference<>(new byte[1024] , objectReferenceQueue));\n            }\n        }catch (OutOfMemoryError e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n  4. 虚引用\n    一个对象是否被回收和指向它的虚引用没关系，也不能通过虚引用得到其指向的对象(get方法直接返回null)。\n    虚引用一般会配合 引用队列（ReferenceQueue）来使用。当某个被虚引用指向的对象被回收时，我们可以在其引用队列中得到这个虚引用的对象作为其所指向的对象被回收的一个通知。\n```java\n @Test\n    void test4() {\n        ArrayList<PhantomReference<byte[]>> phantomReferences = new ArrayList<>();\n        ReferenceQueue<Object> objectReferenceQueue = new ReferenceQueue<>();\n\n        try {\n            while (true) {\n                phantomReferences.add(new PhantomReference<>(new byte[1024] , objectReferenceQueue));\n            }\n        }catch (OutOfMemoryError e) {\n            e.printStackTrace();\n        }\n    }\n```\n  5. 基于引用驱逐策略\n```java\n// 当key和value都没有引用时驱逐缓存\nCache<String , String> cache = Caffeine.newBuilder()\n    .weakKeys()\n    .weakValues()\n    .build();\n\n// Evict when the garbage collector needs to free memory\n// 当垃圾收集器需要释放内存时驱逐\nCache<String , String> cache = Caffeine.newBuilder()\n    .softValues()\n    .build();\n```\n### caffeine缓存策略\n\n#### Window TinyLfu缓存策略\n  1. [Window TinyLfu缓存策略](https://github.com/ben-manes/caffeine/wiki/Efficiency) 介绍 \n    TinyLfu策略是结合了LFU和LRU以及其他一些算法的特点，它不是纯粹的LFU算法。\n  2. Window TinyLfu缓存策略原理解析\n    在TinyLfu中使用Count-Min Sketch(访问最低频次)记录访问频次。\n    ![访问频次](tinylfu.png)\n    如图所示，四行表示有四种hash算法，key指向每行中的一个数，分别表示key这个数据在每个hash运算中对应的访问频次，然后取出其中最低访问频次作为最终的记录频次。\n    为什么要算四次呢？\n    对应场景：hash算法会出现冲突。在只有一个hash算法时，现在有数据A和数据B，它们有可能有hash值是相同的。查询访问记录时，数据A和数据B找到同一个hash值，记录同时+1，这个hash保存的频次为最大的那一个频次记录，最终两个数据查询到的访问频次都是一样的。\n    两个数据使用hash算法运算四次，就算有几次值都是一样，只要有一次不一样，这两个数据都是不一样的。最终，得到的频次是这四次hash中的最低频次。\n    在caffeine中规定最大访问频次为15，15的二进制为1111，总共四位。每个long型64位，被分为四段，存储四种hash算法，因此一条记录占16位。现在有100条记录缓存，按2的幂次，获得最接近100的数(2^7=128)，如果是一次hash，就占128位，四次hash就是128\\*4位。\n### caffeine动态设置缓存配置\n> 如果要动态设置参数，这个参数必须已经初始化用build()初始化。\n#### 动态设置缓存最大值\n```java\nCache<String , String> cache = Caffeine.newBuilder()\n                .maximumSize(200000) // 缓存最大容量,如果缓存量大，需要\n                .recordStats() // 获取命中率\n                .build();\n        cache.policy().eviction().ifPresent(eviction -> eviction.setMaximum(eviction.getMaximum()/2)); // 动态设置缓存最大值\n        Policy.Eviction<String, String> eviction = cache.policy().eviction().get(); // 动态获取缓存最大值\n        @NonNegative long maximum = eviction.getMaximum();\n```\n#### 动态设置访问过期时间\n```java\nCache<String , String> cache = Caffeine.newBuilder()\n                .expireAfterAccess(10 , TimeUnit.SECONDS)\n                .recordStats() // 获取命中率\n                .build();\n        cache.policy().expireAfterAccess().我们可以通过\".\"运算符获取返回对象中的执行方法eviction()(access -> access.setExpiresAfter(10 , TimeUnit.SECONDS)); // 动态设置访问过期时间\n        Policy.Expiration<String, String> expiration = cache.policy().expireAfterAccess().get(); // 动态获取访问过期时间\n        @NonNegative long expiresAfter = expiration.getExpiresAfter(TimeUnit.SECONDS);\n```\n#### 动态设置写入过期时间\n```java\nCache<String , String> cache = Caffeine.newBuilder()\n                .expireAfterWrite(1 , TimeUnit.SECONDS)\n                .recordStats() // 获取命中率\n                .build();\n        cache.policy().expireAfterWrite().ifPresent(write -> write.setExpiresAfter(10 ,TimeUnit.SECONDS)); // 动态设置写入过期时间\n        Policy.Expiration<String, String> write = cache.policy().expireAfterWrite().get(); // 动态获取写入过期时间\n        @NonNegative long writeExpiresAfter = write.getExpiresAfter(TimeUnit.SECONDS);\n```\n\n#### 动态缓存设置源码分析\n\n首先，我们进入Cache类，可以看到Cache类信息。\n![cache](cache.png)\n红色箭头标记的policy方法就是实现cache动态配置的代理方法,其返回值是一个Policy对象。\n![cache_policy](cache_policy.png)\n我们可以看到Policy类信息。\n![policy](policy.png)\n我们可以通过\".\"运算符获取返回对象中的执行方法eviction()\n![policy_eviction](policy_eviction.png)\neviction()方法的返回值类型是Optional<Eviction<K, V>>，我们可以看到Eviction类信息\n![eviction](eviction.png)\n我们可以通过\".\"运算符获取返回对象中的执行方法ifPresent()。这里，就是整个执行链的最底端。我们可以看出，ifPresent()方法的参数是一个函数(这是java8新特性-函数式编程)。\n它要求我们输入一个Consumer<? super T>对象，这个对象是一段执行函数，而这个函数的输入值类型就是T，这个T就是Eviction类型，这段函数就是Eviction类型中的方法。\n![policy_ifpresent](policy_ifpresent.png)\n\n我们最开始的时候就创建了一个Cache对象，这个对象就是被操作对象，最终的操作者就是Consumer<? super T>类型的执行函数，我们可以通过调用get()方法获取cache对象中的信息，也可以通过set方法设置参数进cache对象。\n\n\n### caffeine加载策略\n> 主要使用的就是手动加载。**手动加载、同步加载和异步加载都可以使用动态设置。** \n\n  1. 手动加载\n    手动加载比较灵活，可以让我们显示的控制缓存的检索，更新和删除。\n    手动加载需要我们自己使用put(),get()方法来设置缓存和获取缓存。\n```java\nCache<String , String> cache = Caffeine.newBuilder()\n                .expireAfterAccess(10 , TimeUnit.SECONDS)\n                .maximumSize(200000) // 缓存最大容量,如果缓存量大，需要\n                .recordStats() // 获取命中率\n                .build();\ncache.put(\"hello\" , \"world\");\ncache.getIfPresent(\"hello\"); // 直接通过key获取，如果key不存在，返回null\ncache.get(\"hello\" , k -> k) ; // 通过key获取，如果缓存不存在，则通过function得到一个新key设置入缓存\n```\n  2. 同步加载\n    LoadingCache是使用CacheLoader来构建的缓存的值。\n    批量查找可以使用getAll方法。默认情况下，getAll将会对缓存中没有值的key分别调用CacheLoader.load方法来构建缓存的值。我们可以重写CacheLoader.loadAll方法来提高getAll的效率。\n    注意：您可以编写一个CacheLoader.loadAll来实现为特别请求的key加载值。例如，如果计算某个组中的任何键的值将为该组中的所有键提供值，则loadAll可能会同时加载该组的其余部分。\n```java\nLoadingCache<String, Object> loadingCache = Caffeine.newBuilder()\n        .maximumSize(10_000)\n        .expireAfterWrite(10, TimeUnit.MINUTES)\n        .build(key -> createExpensiveTest(key));\n    \nString key = \"test\";\n// 采用同步方式去获取一个缓存和上面的手动方式是一个原理。在build Cache的时候会提供一个getKey函数。\n// 如果查询的时候缓存中没有这个key，createExpensiveTest()将会构建一个新缓存\nObject test = loadingCache.get(key);\n\n// 获取组key的值返回一个Map\nList<String> keys = new ArrayList<>();\nkeys.add(key);\nMap<String, Object> tests = loadingCache.getAll(keys);\n\nprivate String getKey(String key){\n        return key ;\n    }\n```\n  3. 异步加载\n    AsyncLoadingCache是继承自LoadingCache类的，异步加载使用Executor去调用方法并返回一个CompletableFuture。异步加载缓存使用了响应式编程模型。\n    如果要以同步方式调用时，应提供CacheLoader。要以异步表示时，应该提供一个AsyncCacheLoader，并返回一个CompletableFuture。\n    synchronous()这个方法返回了一个LoadingCacheView视图，LoadingCacheView也继承自LoadingCache。调用该方法后就相当于你将一个异步加载的缓存AsyncLoadingCache转换成了一个同步加载的缓存LoadingCache。\n    默认使用ForkJoinPool.commonPool()来执行异步线程，但是我们可以通过Caffeine.executor(Executor) 方法来替换线程池。\n```java\nAsyncLoadingCache<String, Object> asyncLoadingCache = Caffeine.newBuilder()\n            .maximumSize(10_000)\n            .expireAfterWrite(10, TimeUnit.MINUTES)\n            // Either: Build with a synchronous computation that is wrapped as asynchronous\n            .buildAsync(key -> createExpensiveGraph(key));\n            // Or: Build with a asynchronous computation that returns a future\n            // .buildAsync((key, executor) -> createExpensiveTestAsync(key, executor));\n\n String key = \"test\";\n\n// 查询并在缺失的情况下使用异步的方式来构建缓存\nCompletableFuture<Object> test = asyncLoadingCache.get(key);\n// 查询一组缓存并在缺失的情况下使用异步的方式来构建缓存\nList<String> keys = new ArrayList<>();\nkeys.add(key);\nCompletableFuture<Map<String, Object>> tests = asyncLoadingCache.getAll(keys);\n// 异步转同步\nloadingCache = asyncLoadingCache.synchronous();\n```\n### caffeine实战(测试)\n```java\n    @Test\n    void contextLoads1() throws InterruptedException {\n        String key = \"https://www.test.com\" ;\n        String value = \"test\";\n\n        // 基于时间驱逐策略 : 设置缓存时间(写入时间或者访问时间)过期\n        // 基于缓存大小驱逐策略 : 设置缓存容量最大值，超出最大值使用Window TinyLfu策略删除缓存\n        Cache<String , String> cache = Caffeine.newBuilder()\n                .expireAfterAccess(10 , TimeUnit.SECONDS)\n//                .expireAfterWrite(1 , TimeUnit.SECONDS) // 先注释掉\n                .maximumSize(200000) // 缓存最大容量,如果缓存量大，需要\n                .recordStats() // 获取命中率\n                .build();\n                \n        cache.policy().eviction().ifPresent(eviction -> eviction.setMaximum(eviction.getMaximum()/2));\n        Policy.Eviction<String, String> eviction = cache.policy().eviction().get();\n        @NonNegative long maximum = eviction.getMaximum();\n        \n        cache.policy().expireAfterAccess().ifPresent(access -> access.setExpiresAfter(10 , TimeUnit.SECONDS));\n        Policy.Expiration<String, String> expiration = cache.policy().expireAfterAccess().get();\n        @NonNegative long expiresAfter = expiration.getExpiresAfter(TimeUnit.SECONDS);\n        \n        // 没有设置expireAfterWrite\n//        cache.policy().expireAfterWrite().ifPresent(write -> write.setExpiresAfter(10 ,TimeUnit.SECONDS));\n//        Policy.Expiration<String, String> write = cache.policy().expireAfterWrite().get();\n//        @NonNegative long writeExpiresAfter = write.getExpiresAfter(TimeUnit.SECONDS);\n//        System.out.println(\"max: \" + maximum);\n        System.out.println(\"duration: \" + expiresAfter);\n        // 获取当前使用内存\n        Runtime runtime = Runtime.getRuntime();\n        long start_memory = runtime.totalMemory() - runtime.freeMemory() ;\n        Long start_time = System.currentTimeMillis() ;\n        // 设置进缓存,如果设进缓存的量大于最大值，\n        for (int i=0 ; i<190000 ; i++) {\n            cache.put(key+i , value);\n//            cache.get(key+i , s->\"error\");\n        }\n        // 如果超出内存容量，会使用最近不常用算法剔除\n        for (int i=0 ; i<200000 ; i++) {\n            cache.getIfPresent(key+i);\n        }\n        System.out.println(\"命中率：%\" + cache.stats());\n\n        /*cache.policy().eviction().ifPresent(exviction -> exviction.setMaximum(200000));\n        for (int i=200000 ; i<400000 ; i++) {\n            cache.put(key+i , value);\n//            cache.get(key+i , s->\"error\");\n        }\n        // 如果超出内存容量，会使用最近不常用算法剔除\n        for (int i=200000 ; i<400000 ; i++) {\n            cache.get(key+i , s -> \"error\");\n        }*/\n//        System.out.println(\"命中率：%\" + cache.stats());\n        ConcurrentMap<String, String> map = cache.asMap();\n        int size = map.size();\n        long end_memory = runtime.totalMemory() - runtime.freeMemory() ;\n        Long end_time = System.currentTimeMillis();\n        Double l = (Double.parseDouble(String.valueOf(cache.stats().hitCount()))/Double.parseDouble(String.valueOf((cache.stats().hitCount()+cache.stats().missCount()))))*100;\n        System.out.println(\"命中率：%\" + l);\n        System.out.println(\"缓存执行时间： \" + (end_time-start_time) + \"ms\");\n        System.out.println(\"内存使用情况： \" + ((end_memory - start_memory)/1024/1024) + \"MB\");\n        System.out.println(\"count: \" + size);\n    }\n```\n#### springboot使用caffeine实战\n  1. 首先在pom.xml中添加caffeine依赖\n```xml\n        <!-- https://mvnrepository.com/artifact/com.github.ben-manes.caffeine/caffeine -->\n        <dependency>\n            <groupId>com.github.ben-manes.caffeine</groupId>\n            <artifactId>caffeine</artifactId>\n            <version>2.8.0</version>\n        </dependency>\n```\n  2. 然后创建config配置类CacheConfig.java(这里使用的是手动加载)\n```java\nimport com.github.benmanes.caffeine.cache.Cache;\nimport com.github.benmanes.caffeine.cache.Caffeine;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport java.util.concurrent.TimeUnit;\n\n@Configuration\npublic class CacheConfig {\n\n    @Bean\n    public Cache<String , String> cache() {\n        Cache<String , String> cache = Caffeine.newBuilder()\n                .expireAfterAccess(10 , TimeUnit.MINUTES)\n                .maximumSize(2000000) // 缓存最大容量,如果缓存量大，需要\n                .recordStats() // 获取命中率\n                .build() ;\n        return cache ;\n    }\n}\n```\n\n  3. 创建CacheService.java\n```java\nimport com.github.benmanes.caffeine.cache.Cache;\nimport com.github.benmanes.caffeine.cache.Policy;\nimport org.checkerframework.checker.index.qual.NonNegative;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\n@Service\npublic class CacheService {\n    @Autowired\n    private ConnectorListUpdate connectorListUpdate ;\n    @Autowired\n    private Cache<String , String> cache ;\n\n    /**\n     * 设置缓存参数\n     * @param maxSize\n     * @param duration\n     * @return\n     */\n    public Map<String , String> setCache(Long maxSize , Long duration) {\n        HashMap<String, String> hashMap = new HashMap<>();\n        // 如果传入的maxSize参数不为空，则修改这个参数\n        try {\n            if (maxSize == null && duration == null) {\n                hashMap.put(\"code\" , \"success\");\n                hashMap.put(\"desc\" , \"设置的缓存参数为空\");\n            }\n            if (maxSize != null) {\n                cache.policy().eviction().ifPresent(eviction -> eviction.setMaximum(maxSize));\n            }\n\n            if (duration != null) {\n                cache.policy().expireAfterAccess().ifPresent(access -> access.setExpiresAfter(duration , TimeUnit.MINUTES));\n            }\n            connectorListUpdate.uriListUpdate();\n            hashMap.put(\"code\" , success);\n            hashMap.put(\"desc\" , \"缓存参数设置成功\");\n        }catch (Exception e) {\n            hashMap.put(\"code\" , \"faild\");\n            hashMap.put(\"desc\" , \"缓存参数设置失败\");\n        }\n\n        return hashMap ;\n    }\n\n    /**\n     * 获取缓存参数\n     * @return\n     */\n    public Map<String , Object> getCache(){\n        HashMap<String , Object> data = new HashMap<>();\n        HashMap<String, Object> map = new HashMap<>();\n        try {\n            // 获取最大缓存值\n            Policy.Eviction<String, String> eviction = cache.policy().eviction().get();\n            @NonNegative long maximum = eviction.getMaximum();\n\n            // 获取时间\n            Policy.Expiration<String, String> expiration = cache.policy().expireAfterAccess().get();\n            @NonNegative long duration = expiration.getExpiresAfter(TimeUnit.MINUTES);\n\n            // 获取当前缓存条数\n            long size = cache.estimatedSize() ;\n\n            data.put(\"maxSize\" , String.valueOf(maximum));\n            data.put(\"duration\" , String.valueOf(duration));\n            data.put(\"size\" , String.valueOf(size));\n            map.put(\"code\" , \"success\");\n            map.put(\"desc\" , \"缓存参数获取成功\");\n            map.put(\"data\" , data);\n        }catch (Exception e) {\n            map.put(\"code\" , \"faild\");\n            map.put(\"desc\" , \"缓存参数获取失败\");\n        }\n\n        return map ;\n    }\n}\n```\n  4. 创建TestController.java\n```java\nimport org.apache.commons.lang.StringUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.kafka.config.StreamsBuilderFactoryBean;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\n\n@RestController\n@RequestMapping(value = \"/test\")\npublic class TestController {\n    @Autowired\n    private CacheService cacheService ;\n    \n    @RequestMapping(value = \"/setCache\" , method = RequestMethod.GET)\n    public Map<String , String> setCache(@RequestParam(name = \"maxSize\") String maxSize ,\n                                         @RequestParam(name = \"duration\") String duration) {\n        Map<String, String> map = cacheService.setCache(Long.valueOf(maxSize), Long.valueOf(duration));\n        return map ;\n    }\n\n    @RequestMapping(value = \"/getCache\" , method = RequestMethod.GET)\n    public Map<String , Object> getCache(){\n        Map<String, Object> cache = cacheService.getCache();\n        return cache ;\n    }\n}\n```\n### 文献参考\n  1. [你应该知道的缓存进化史](https://juejin.im/post/5b7593496fb9a009b62904fa)\n  2. [深入解密来自未来的缓存-Caffeine](https://juejin.im/post/5b8df63c6fb9a019e04ebaf4)\n  3. [如何优雅的设计和使用缓存？](https://juejin.im/post/5b849878e51d4538c77a974a)\n  4. [Caffeine缓存](https://www.jianshu.com/p/9a80c662dac4)\n  5. [现代化的缓存设计方案](http://ifeve.com/design-of-a-modern-cache/#more-31244)\n  6. [springboot使用caffeine](https://www.jianshu.com/p/2e2e9b6b1853)\n  7. [springboot学习(十二)：缓存caffeine的使用](https://blog.csdn.net/sinat_36553913/article/details/86417114)  \n  8. [caffeine源码分析——淘汰策略tinylfu](https://www.jianshu.com/p/62757d2a592c)\n  9. [二分钟快速掌握Caffeine 三种填充策略：手动、同步和异步](https://blog.csdn.net/Z0157/article/details/83663129) \n  10. [详解 Java 中的四种引用](https://blog.csdn.net/hacker_zhidian/article/details/83043270#_11) "},{"title":"日志收集系统","url":"%2F2019%2F11%2F24%2F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F%2F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F%2F","content":"\n## 日志收集系统\n\n### 所需工具\n  1. [filebeat](http://rack-leen.github.io/2019/11/26/工具安装与部署/filebeat安装与应用/)\n  2. [kafka](http://rack-leen.github.io/2019/11/26/工具安装与部署/kafka安装与应用/)\n  3. [logstash](http://rack-leen.github.io/2019/11/26/工具安装与部署/logstash安装与应用/)\n  4. [elasticsearch](http://rack-leen.github.io/2019/11/26/工具安装与部署/elasticsearch安装与应用/)\n  5. [kibana](http://rack-leen.github.io/2019/11/26/工具安装与部署/kibana安装与应用/)\n  6. [zookeeper](http://rack-leen.github.io/2019/11/26/工具安装与部署/zookeeper安装与应用/)\n\n### 工具链\n#### 用logstash收集日志\n   1. 所需工具\n```\n  elasticsearch(与zookeeper组成集群)+logstash+kibana\n```\n  2. 工作流程\n![logstash收集日志](logstash收集日志.png)\n  3. 详细解析\n     用logstash作为收集日志的工具，可以以日志文件/kafka/filebeat等(可以自己为logstash配置输入插件，详情见[官网](https://www.elastic.co/guide/en/logstash/current/index.html))为输入源，将输入源的数据通过logstash的filter插件(可以自己配置需要的过滤插件，最常用的是用ruby插件写脚本)进行过滤，过滤成功后，就将数据输出到输出源(输出源可以自己配置插件，可以输出到kafka/文件/es等)elasticsearch中，最终使用kibana将elasticsearch中的数据显示在web端。\n\n#### 用kafka收集日志\n   1. 所需工具\n```\n  elasticsearch(与zookeeper组成集群)+logstash+kibana+kafka(与zookeeper组成集群)\n```\n  2. 工作流程\n  ![kafka收集日志](kafka收集日志.png)\n  3. 详细解析\n   用kafka从日志文件或者项目输出收集日志，用logstash连接kafka，将kafka作为输入源，将输入源的数据通过logstash的filter插件(可以自己配置需要的过滤插件，最常用的是用ruby插件写脚本)进行过滤，过滤成功后，就将数据输出到输出源(输出源可以自己配置插件，可以输出到kafka/文件/es等)elasticsearch中，最终使用kibana将elasticsearch中的数据显示在web端。\n#### 用filebeat收集日志\n  1. 所需工具\n```\n  elasticsearch(与zookeeper组成集群)+logstash+kibana+kafka(与zookeeper组成集群)+filebeat\n```\n  2. 工作流程\n![filebeat收集日志](filebeat收集日志.png)\n  3. 详细解析\n  用filebeat从日志文件收集日志，用kafka从filebeat获取日志到特定的topic，用logstash连接kafka，将kafka作为输入源，将输入源的数据通过logstash的filter插件(可以自己配置需要的过滤插件，最常用的是用ruby插件写脚本)进行过滤，过滤成功后，就将数据输出到输出源(输出源可以自己配置插件，可以输出到kafka/文件/es等)elasticsearch中，最终使用kibana将elasticsearch中的数据显示在web端。\n","tags":["日志收集系统"],"categories":["日志收集系统"]},{"title":"chapter10-完整的示例","url":"%2F2019%2F08%2F17%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%2Fpart-1%2Fchapter10-%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A4%BA%E4%BE%8B%2F"},{"title":"chapter9-协同程序","url":"%2F2019%2F08%2F17%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%2Fpart-1%2Fchapter9-%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F%2F"},{"title":"chapter8-编译、执行与错误","url":"%2F2019%2F08%2F17%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%2Fpart-1%2Fchapter8-%E7%BC%96%E8%AF%91%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8E%E9%94%99%E8%AF%AF%2F"},{"title":"chapter5-函数","url":"%2F2019%2F08%2F17%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%2Fpart-1%2Fchapter5-%E5%87%BD%E6%95%B0%2F","tags":["Lua程序设计笔记"],"categories":["part-1"]},{"title":"chapter4-语句","url":"%2F2019%2F08%2F17%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%2Fpart-1%2Fchapter4-%E8%AF%AD%E5%8F%A5%2F","content":"\n## 语句\n\n### 赋值\n\n  1. 修改变量的值\n```lua\na = \"hello\" .. \"world\"  \nprint(a)\n```\n  2. 修改table的值\n  可以根据key来修改table中对应的value值\n```lua\n-- 修改table的值\nt = {}\nt.n = 1  -- 为table中的key=n赋值value=1\nt.n = t.n+1 -- 自动+1\nprint(t.n) -- 打印出table中key对应的value\n```  \n  3. 多重赋值\n  如果要初始化一组变量，应该为每个变量提供一个值\n```lua\n-- 多重赋值\n\nc ,d = 10 , 20 -- 一次性给c 和d赋值\nprint(c , d)\n\nx , y = 100 , 200 -- 先赋值给x,y\nx,y = y,x -- 再将x和y的值对换\nprint(x,y)\n\ne,f,g = 1,2 --三个变量只赋值两个，默认是从左往右赋值。如果要初始化一组变量，应该为每个变量提供一个值\nprint(e,f,g)\n```\n\n### 局部变量与块\n局部变量的作用域仅限于它们声明的块。所声明的局部变量的作用域从声明语句开始，直至所在块的结尾。\n尽可能的使用局部变量，局部变量可以避免将一些无用的名称引入全局环境中。此外，访问局部变量比访问全局变量快。\n```lua\n-- 程序块\n\nx = 10 -- 定义一个全局变量\n\nlocal  i = 1 -- 定义一个局部变量\n\nwhile i < x do -- 这里是用全局变量x循环\n    local x = i*10 --这里重新定义一个局部变量x\n    print(\"test\" .. i .. \"  \" .. x) -- 打印局部变量x\n    i = i+1\nend\n\nif i > 20 then\n    -- body\n    local x \n    x = 20\n    print(x+2) -- 打印if肯定程序块中的局部变量x\nelse \n    -- body\n    print(x) -- 这里没有局部变量，因此打印全局变量\nend\n\nprint(x)\n```\n声明的语句可以包含**初始化赋值**，**额外的值**会被丢弃，**额外的变量**会被赋予**nil**。\n```lua\nlocal a , b = 1 , 10\n\nif a < b then\n    -- body\n    print(a) -- 这里打印开始定义的局部变量a\n    local a    -- 定义一个内部局部变量a\n    print(a)  -- 打印内部局部变量a\nend\n\nprint(a , b)  -- 这里的a , b 打印的是最外边的局部变量a , b\n```\n\n在lua中局部变量有一个习惯写法\n```lua\nfoo = 1   -- 定义一个全局变量\nlocal foo = foo -- 将一个全局变量的值赋值给局部变量，作为局部变量的初值\nprint(foo)\n```\n\n### 控制结构\n\n","tags":["Lua程序设计笔记"],"categories":["part-1"]},{"title":"chapter7-迭代器与泛型for","url":"%2F2019%2F08%2F17%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%2Fpart-1%2Fchapter7-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E6%B3%9B%E5%9E%8Bfor%2F","tags":["Lua程序设计笔记"],"categories":["part-1"]},{"title":"chapter3-表达式","url":"%2F2019%2F08%2F17%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%2Fpart-1%2Fchapter3-%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F","content":"\n## 表达式\n\n### 算术操作符\n    二元算术操作符: +(加) 、-(减)、*(乘)、/(除)、^(指数)、%(取模)\n    一元算术操作符: -(负号)\n```lua\na = math.pi; b = 20 \nprint(a%b == a-math.floor(a/b)*b ) -- 取模规则\nprint(a-a%1) -- 取整数部分\nprint(a-a%0.01) -- 精确到两位小数\n```\n### 关系操作符\n\n### 逻辑操作符\n### 字符串连接\n### 优先级\n![优先级](1.png)\n### table构造式\n","tags":["Lua程序设计笔记"],"categories":["part-1"]},{"title":"chapter6-深入函数","url":"%2F2019%2F08%2F17%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%2Fpart-1%2Fchapter6-%E6%B7%B1%E5%85%A5%E5%87%BD%E6%95%B0%2F","tags":["Lua程序设计笔记"],"categories":["part-1"]},{"title":"chapter2-类型与值","url":"%2F2019%2F08%2F17%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%2Fpart-1%2Fchapter2-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%80%BC%2F","content":"\n## 类型与值\n\n### Lua8种基本类型\nnil类型(空)、boolean(布尔类型)、number(数字类型)、string(字符串)、userdata(自定义)、function(函数)、thread(线程)和table(表)。\n\n```lua\nprint(type(\"Hello World !\"))  -- string类型\nprint(type(10*3))             -- number类型\nprint(type(print))            -- function类型\nprint(type(type))             -- function类型\nprint(type(true))             -- boolean类型\nprint(type(nil))              -- nil类型\nprint(type(type(X)))          -- string类型(type最终返回的是一个字符串)\n\n-- 设变量a\nprint(type(a))  -- 打印出的是nil类型\na = 10\nprint(type(a))  -- 打印的是number类型\na = \"string\"   \nprint(type(a))  -- 打印的是string类型\na = print       -- 这里可以将a看做函数print的别名\na(type(a))      -- 这里使用a表示使用print \n```\n<!--more-->\n#### nil(空)\n**nil** 是一种类型，只有一个 nil 值 ，它的主要能工是用来区别其他任何值。用于表示无效值。\n#### boolean(布尔)\nLua将false和nil值视为假，将除此之外的值视为真。\n#### number(数字)\nnumber类型表示实数。lua中所有的数字可以表示任何一个32位的整数，而不会产生四舍五入的错误。并且现在有的cpu浮点数运算可能更快。\n也可以通过重新编译lua，也可以用其他类型表示数字。具体做法详见发行版中的luaconf.h\n#### string(字符串)\nlua中的字符串通常表示一个字符序列。其采用8位编码，lua字符串中的字符可以具有任何数字值编码，包括数值0，它可以讲任意二进制数据存储到一个字符串中。\nlua的字符串是不可变值，修改字符需要创建一个新的字符串。\n  1. 一对匹配引号(\"\"或'')界定字符串\n  2. 一对匹配双方括号界定字符串\n\n```lua\n function my_string()\n    print(\"用双引号界定打印字符串\")\n    print(\"one line\\n\\\"in quotes \\\",'in quotes'\") -- 用普通的双引号界定打印字符串\n    print(\"用单引号界定打印字符串\")\n    print('a backslash inside quotes : \\'\\\\\\'')   -- 用单引号界定打印字符串\n    print(\"用ascii码打印字符串\")\n    print(\"正常字符\")\n    print(\"alo\\n123\\\"\")\n    print(\"ascii码字符\")\n    print('\\97lo\\10\\04923\"') -- a --> \\97   \\n --> \\10   1 --> \\049\n\n    print(\"用双方括号界定打印字符串\")\n    -- 可以简化那些已经包含了注释块的代码\n    page = [==[\n    --[[\n    a=b[c[i]]\n    --]]\n    ]==]\n\n    page1 = [[\n    <html>\n    <body>\n    <a href=\"http://www.lua.org\">Lua</a>\n    </body>\n    </html>\n    ]]\n    print(page)\n    print(page1)\nend\n--[==[\n--aa\n--]==]\nmy_string()\n```\n  3.  数字与字符串的自动转换\n```lua\nprint(\"10\" + 1) -- 最终转换为string\nprint(\"10 + 1\") -- 本来就是字符串\nprint(\"-5.3e-10\"*\"2\") -- 两个字符串进行相乘，如果是number，自动进行计算\n-- print(\"hello\" + 1) -- 这一行是错误代码，字母不能和数字相计算\nprint(10 .. 20) -- \"..\"作为连字符，将两个数字作为字符串连接起来,中间必须有空格\nprint(\"10\" .. \"20\")  -- 如果\"..\"两边是字符，则不管有没有空格，都能将其连接起来\n```\n  4. 使用tonumber将字符串转换为数字\n\n```lua\n  line = io.read() -- 从标准输入读取字符到line全局变量中\nn = tonumber(line)  -- 将line变量中字符串转换为数字(如果字符串是字母，则返回nil,如果是实数，则返回number类型)\n\nif n == nil then\n    error(line .. \"is not a vaild number\")\nelse\n    print(n*2)\nend\n\ns = tostring(n) -- 将一个数字转换为字符串\n\nprint(s == \"10\") \nprint(10 .. \"\" == \"10\") -- 这样将10连接为一个字符串\n```\n\n  5. 获取字符串的长度\n```lua\na = \"hello world\"\nprint(#a)   -- 在变量名前面加\"#\"就能获取变量的长度，一般都是字符串\nprint(#\"good\\0bye\")  -- 也可以直接在字符串的前面加\"#\"也能获取字符串长度\n```\n\n#### table(表)\n  table类型实现了关联数组，它具有一种特殊的索引方式，可以使用字符串、整数等来索引（除了nil）。\n  table是一个对象，是一种动态分配的对象。\n  lua中通过table表示普通数组、符号表、集合、记录、队列和其他数据结构。\n  lua通过table表示模块、包和对象。比如io.read(),表示使用字符串read作为key来索引table类型的io。\n  1. table的创建是由动态表达式完成的\n```lua\na = {}   -- 创建一个table，并将它的引用存储到a中\nk = \"color\"  -- k是一个变量\na[k] = \"green\" -- 这里k作为a的key , key = k = \"color\"\nprint(a[k])    -- 这里打印的是key为\"k\"的value\na[9] = \"great\" -- a中key=9的value=great\nprint(a[9])   -- 这里打印出key=9的value\na[\"num\"] = 10  -- key=\"num\"的value=10\nprint(a[\"num\"]) \n\nk = 9  -- 这里变量k的值更改\n\nprint(a[k]) -- 打印的是key=k=9的value=great\n\na[\"num\"] = a[\"num\"]+1 \nprint(a[\"num\"])\n```\n  2. table永远是匿名的，table变量和自身没有固定联系\n```lua\na = {}\na[\"x\"] = 10 -- table a 的key=\"x\"的value=10\nb = a   -- 创建table b , table a 将自己赋值给table b\nprint(b[\"x\"]) -- 现在从table b 能获取table a的所有变量\nb[\"x\"] = 20  -- table b 的key有更改，table a也会一起更改\nprint(a[\"x\"])\na = nil -- table a 被回收 ， 现在只有table b 被引用\nb = nil -- table b 被回收， 再也没有对table的引用\n```\n  3. table会自增长\n```lua\na = {}\n\n-- 这使得table a的key从1自动增长到1000\nfor i=1,1000 do\n    a[i] = i*2\nend\n\nprint(a[9])  \na[\"x\"] = 10  -- 在table a中创建一个新的key\nprint(a[\"x\"]) -- 这个key在table a中存在\nprint(a[\"y\"]) -- 这个key不存在\n```\n  4. a.x和a[x]的区别\n    a.x等同于a[\"x\"]，a.x中的x是table中的key(通常这个key是固定不变的)，a[x]中的x是变量，它可以指定一个key。\n  5. table的索引\n    table中的索引以1作为索引起始值。长度操作符\"#\"返回的是最后一个索引值。\n    长度操作符\"#\"用来处理没有空隙的数组。table.maxn用来处理有空隙的数组。\n```lua\na = {}\na[1000] = 1 -- 这个数组是有空隙的数组，只有索引1000有值，其他的都没有值。不能用\"#\"\nprint(table.maxn(a)) -- table.maxn()返回这个table最大正索引数 lua5.1中使用\n\nb = {}\nfor i=1,10 do  -- 这个table 10个索引都有值，这个就是没有空隙的数组\n    b[i]=i*2\nend\nprint(#b)   -- 返回这个数组长度\n```\n  6. key值问题\n  table中任何类型都可以用来索引，如果是数字0和字符\"0\"作索引，它们不是一个索引，会被分为两个。遇到这样的，我们可以用显示转换。\n```lua\ni = 10 ; j = \"10\" ; k = \"+10\"\n\na = {}\na[i] = \"one value\"\na[j] = \"another value\"\na[k] = \"yet another value\"\n\nprint(a[i])\nprint(a[j])\nprint(a[tonumber(j)]) --将字符串\"10\"转换为数字10\nprint(a[tonumber(k)]) -- 将\"+10\"转换为数字10\n```\n\n#### function(函数)\n  函数可以存储到变量中，可以通过参数传递给其他函数，可以作为其他函数的返回值。\n  lua可以调用自身lua语言写的函数，也可以调用 c语言写的函数。\n\n#### userdata(自定义类型)和thread(线程)\n  userdata类型可以将任意c语言数据存储到lua变量中。标准的I/O库就用userdata表示文件。","tags":["Lua程序设计笔记"],"categories":["part-1"]},{"title":"chapter1-开始","url":"%2F2019%2F08%2F17%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%2Fpart-1%2Fchapter1-%E5%BC%80%E5%A7%8B%2F","content":"\n## 开始\n\n### lua环境搭建\n  lua是一个解释型语言，需要有lua解释器。所以，我们需要安装lua解释器。\n  1. 安装解释器\n```bash\nsudo pacman -S -y lua\n```\n  2. 执行lua\n```bash\n-- 执行lua脚本\nlua hello.lua\n\n-- 进入交互界面,与python差不多\nlua\n\nLua 5.3.5  Copyright (C) 1994-2018 Lua.org, PUC-Rio\n> \n\n-- 退出交互式界面\n> os.exit()\n```\n<!--more-->\n### 第一个hello world\n  在下面这个代码块中，function作为一个函数块，以end结尾，当被调用时使用。注释使用\"--\"，输入的数据使用内置标准库io来读取。使用内置的print函数打印最终值。\n```lua\n-- 这是单行注释\n\n--[[\n  这是多行注释\n--]]\n\n---[[\n  这是将多行注释的代码让其起作用\n  原理：\"--[[\"是一个行注释，\"--]]\"也是一个行注释，连起来用就是一个块注释。当一个失效，那么这个块注释就会失效，两个注释符号就变成单个的行注释。\n--]]\n\n-- 第一个打印函数\nfunction hello()\n  -- 打印字符串\n  print(\" hello world ! \")\nend\n\n-- 第一个阶乘函数\nfunction fact(n)\n  -- 如果输入的数是0，则阶乘直接返回1\n  if n == 0 then\n    return 1 \n  else\n    return n*fact(n-1)\n  end\nend\n\n-- 执行第一个函数\nhello()\n\nprint(\"enter a number : \")\na = io.read(\"*number\") -- 读取一个数字\nprint(fact(a))\n```\n  + 执行脚本\n```bash\nlua hello.lua     -- 直接运行脚本程序\nlua -i hello.lua  -- 执行完脚本后就进入交互式界面,这可以用于程序调试\n```\n### 程序块\n\n  一个源代码文件或在交互模式下输入的一行代码，都被称为一个**程序块** ,一个程序块就是一连串的语句或指令。lua的格式不严格，语句之间不需要分隔符(可以用\";\"隔开)。\n  在交互式环境中，解释器检测到代码不足以构成一个完整的程序块，它会等待输入内容，直至可以构成一个完整的程序块。\n```lua\n-- 这四条语句都是合法的并且完全等价\n\na = 1\nb = a*2\n\na = 1;\nb = a*2;\n\na=1;b=a*2\na=1 b=a*2\n```\n#### 将lua代码作为lua库\n\n  1. 库文件\n```lua\n-- 结果是根号下的x的平方加上y的平方\nfunction norm(x , y)\n  return (x^2+y^2)^0.5\nend\n\nfunction twice(x)\n  return 2*x\nend\n```\n\n  2. 在交互模式下加载程序库\n\n```bash\n> dofile(\"lib1.lua\") -- 加载库文件\n> n = norm(3.4,1.0)  -- 使用库文件中的库函数\n> print(twice(n))\n\n```\n  3. 使用代码加载程序库\n\n\n### 词法规范\nlua的标识符可以有任意字母、数字和下划线组成，但是不能以数字开头。以下划线开头，后面跟多个大写字母的标识符在lua中留作特殊用途，通常保留标识符\"\\_\"作为哑变量使用。\n  locale关键字可以将字母作为变量名，但是这些字母不能为关键字和保留字。\n  locale关键字声明的变量是局部变量，只能作用于文件内。\n  而将值赋值给一个字符，那这个字符就成为全局变量。\n  未初始化的变量不会引发错误，访问结果是一个特殊的值nil。\n  如果一个变量只有较短的生命周期，那就用局部变量。通常没必要删除一个全局变量，如果存在一个全局变量，那它必定具有一个非nil的值。\n\n### 解释器参数\n\n  1. lua -e 允许在命令行输入代码 \n```bash\nlua -e \"print(\"aaa\")\"  -- 可以直接打印出双引号中的结果\n```\n  2. lua -l 用于加载库文件\n```bash\nlua -l lib1 -e \"a = norm(3 , 4) print(a)\" -- 先加载库文件lib1，再在后面执行lib1库文件中的函数\n```\n  3. \\_PROMPT 自定义解释器交互界面的提示符\n```bash\nlua -i -e \"_PROMPT='lua>'\"\nlua>\n```\n","tags":["Lua程序设计笔记"],"categories":["part-1"]},{"title":"hadoop生态圈","url":"%2F2019%2F08%2F07%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2Fhadoop%E7%94%9F%E6%80%81%E5%9C%88%2F","content":"\n## hadoop生态圈\n\n### hadoop生态圈图谱\n#### hadoop生态圈图\n![hadoop生态圈](Hadoop生态圈.png)\n#### hadoop各个组件工作模式图\n![hadoop生态圈关系图](hadoop生态圈关系图.png)\n### hadoop生态圈各个组件\n\n#### hadoop组件操作流程\n![hadoop集群工作流程图](hadoop集群工作流程图.png)\n![hadoop操作流程](hadoop操作流程.png)\n\n#### 核心组件\n\n  1. HDFS分布式文件系统\n    源自于Google的GFS论文，HDFS是GFS的克隆版\n    HDFS是Hadoop体系中数据存储管理的基础。它是一个高度容错的系统，能检测和应对硬件故障，用于在低成本硬件上运行。\n    HDFS简化了文件的一致性模型，通过流式数据访问，提供高吞吐量应用程序数据访问功能，适合带有大型数据集的应用程序。\n    它提供了一次写入多次读取的机制，数据以块的形式分布在集群中不同的物理机器上。\n  2. MapReduce计算模型\n    MapReduce是一种用于数据处理的编程模型。\n    源自于google的MapReduce论文，Hadoop MapReduce是google MapReduce 克隆版。\nMapReduce是一种分布式计算模型，用以进行大数据量的计算。同一个程序hadoop可以运行用各种语言编写的MapReduce程序。MapReduce程序本质上是并行的，它的优势在于处理大型数据集。它屏蔽了分布式计算框架细节，将计算抽象成map和reduce两部分。\n    其中Map对数据集上的独立元素进行指定的操作，生成键-值对形式中间结果。Reduce则对中间结果中相同“键”的所有“值”进行规约，以得到最终结果。\n    MapReduce非常适合在大量计算机组成的分布式并行环境里进行数据处理。\n  3. Yarn/mesos资源调度器\n      Yarn是下一代MapReduce，即MRv2，是在第一代MapReduce基础上演变而来的，主要是为了解决原始Hadoop扩展性较差，不支持多计算框架而提出的。\n    Yarn是下一代 Hadoop 计算平台，Yarn是一个通用的运行时框架，用户可以编写自己的计算框架，在该运行环境中运行。\n    Mesos诞生于UC Berkeley的一个研究项目，现已成为Apache项目，当前有一些公司使用Mesos管理集群资源，比如Twitter。与yarn类似，Mesos是一个资源统一管理和调度的平台，同样支持比如MR、steaming等多种运算框架。\n\n#### 协调组件\n  1. Zookeeper分布式应用协调服务\n      Zookeeper就是一个动物管理员(hadoop很多项目都是用动物命名的)\n      Zookeeper是一个分布式服务框架，主要用来解决分布式应用中经常用到的数据管理问题,如统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。\n      Zookeeper维护一个类似文件系统的数据结构，每个子目录项都被称作znode(目录节点)，它们可以存储数据。Zookeeper存储的数据量不大，主要用来保存元数据。\n  2. Core/Common为其他子项目提供支持\n\n#### 计算模型\n  计算模型都是运行在yarn的，MapReduce也是一种计算模型\n  1. Tez(Dag有向无环图计算模型)\n  2. Spark(内存Dag计算模型)\n  3. Giraph(图计算模型)\n  4. GraphX(图计算模型)\n  5. Streaming(流计算模型)\n#### 管理工具\n  1. ranger安全管理工具\n  2. falcon数据周期管理工具\n  3. Ambari安装部署配置管理工具\n      Ambari可以用来快速搭建hadoop生态圈大数据组件\n#### 数据存储\n  1. Hlive数据仓库\n  2. HBase分布式NoSQL数据库\n  3. Cassanda混合型NoSQL\n  4. redis分布式NoSQL缓存数据库\n\n#### 数据处理\n  1. Pig数据分析平台\n  2. Mahout数据挖掘算法库\n  3. Hama大规模并行计算框架\n  4. ChuKWa数据收集系统\n  5. Avro数据序列化系统\n  6. MLib机器学习库\n\n#### 其他组件\n  1. Sqoop数据同步工具\n  2. Flume日志收集工具\n  3. Oozie工作流调度器\n  4. Tachyon分布式内存文件系统\n  5. Phoenix(HBase的sql接口)\n  6. knox(hadoop的安全网关)\n","categories":["hadoop生态圈"]},{"title":"文件系统的管理方法和xfs文件系统备份恢复","url":"%2F2019%2F07%2F23%2FLinux%2FRHCE%2Fchapter4%2F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E5%92%8Cxfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D%2F","content":"\nopenssl passwd -1 -salt '1823456' 123456\n"},{"title":"Linux基本操作","url":"%2F2019%2F07%2F23%2FLinux%2FRHCE%2Fchapter1%2FLinux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F","content":"\n### 网络相关概念\n#### 网卡命名规则\n  + 在centos6之前，网络接口使用eth0,eth1方式命令\n  + centos7采用dmidecode采集明令方案，以此采集主板信息，可以实现网卡名字永久化\n    1.如果固件或BIOS为主板上集成的设备提供可用的索引信息，则可根据索引进行命名(ifcfg-ens33)\n    2.如果固件或者BIOS为PCI-E扩展槽锁提供可用索引信息，则可根据此索引进行明名(ifcfg-enp33)\n    3.如果硬件接口的物理位置信息可用，则根据此信息命名，下面就是我的网卡名，这就是根据物理位置命名的\n{% codeblock lang:shell %}\n➜  ~ ifconfig | grep \"enp*\" \n        ether 76:94:6b:38:7a:82  txqueuelen 0  (Ethernet)\nenp2s0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500\n        ether 30:5a:3a:b7:9e:b8  txqueuelen 1000  (Ethernet)\n        inet6 ::1  prefixlen 128  scopeid 0x10<host>\n        loop  txqueuelen 1000  (Local Loopback)\n        inet6 fe80::e9e1:434c:efe5:77f8  prefixlen 64  scopeid 0x20<link>\n        ether 28:c2:dd:35:21:82  txqueuelen 1000  (Ethernet)\n{% endcodeblock %}\n  4.传统命名方式(eth0,eth1)\n\n#### 网卡命名结构\n  en表示ethernet以太网\n  enX:\n    o:主板板载网卡，集成设备的设备索引号\n    p:独立网卡，PCI网卡\n    s:热插拨网卡,usb网卡,扩展槽的索引号\n    nnn(数字)表示：MAC地址+主板信息计算得出唯一的序列\n\n### ip地址修改\n#### 临时修改\n{% codeblock lang:shell %}\n# 临时修改\nsudo ifconfig enp2s0 down\nsudo ifconfig enp2s0 10.7.189.209 netmask 255.255.255.0\nsudo ip r a default via 10.7.189.1\nsudo ifconfig enp2s0 up\n\n# 添加多个临时ip\nsudo ifconfig enp2s0:0 10.7.189.201 netmask 255.255.255.0\nsudo ifconfig enp2s0:1 10.7.189.202 netmask 255.255.255.0\n\n# 临时删除\nsudo ifconfig enp2s0:0 10.7.189.201 del\n\n# 永久删除，重启会失效\ncentos7 : systemctl restart network\ncentod6 : service network restart\n\n\n{% endcodeblock %}\n\n#### 永久修改\n{% codeblock lang:shell %}\n# 方法1\nnmtui #图形化界面修改\nvim /etc/sysconfig/network-scripts/ifcfg-enp0s3 #更改这个文件\nTYPE=\"Ethernet\" \nPROXY_METHOD=\"none\"\nBROWSER_ONLY=\"no\"\nBOOTPROTO=\"dhcp\" #协议类型，有dhcp和static\nDEFROUTE=\"yes\"\nIPV4_FAILURE_FATAL=\"no\"\nIPV6INIT=\"yes\" #允许ipv6\nIPV6_AUTOCONF=\"yes\" #自动配置\nIPV6_DEFROUTE=\"yes\" #默认路由\nIPV6_FAILURE_FATAL=\"no\"\nIPV6_ADDR_GEN_MODE=\"stable-privacy\"\nNAME=\"enp0s3\" #网卡名\nUUID=\"23da12e6-accc-4f9b-93aa-978129994f19\" #网卡id\nDEVICE=\"enp0s3\" #设备名\nONBOOT=\"yes\" #网卡自动启动\nZONE=public\n{% endcodeblock %}\n\n### NetworkManager工具\n  + NetworkManager服务是管理和监控网络设置的守护进程，centos7更加注重使用其来实现网罗的配置和管理。7以前是通过network服务管理网络，7以后通过NetworkManager服务来维护。它是一个动态的，事件驱动的网络管理服务。\n\n### 防火墙与selinux\n{% codeblock lang:shell %}\n\n{% endcodeblock %}\n\n"},{"title":"安装KVM虚拟机","url":"%2F2019%2F07%2F23%2FLinux%2FRHCE%2F%E5%AE%89%E8%A3%85KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%2F","content":"\n## 安装kvm虚拟机\n\n### 环境准备\n  1. 查看cpu是否支持虚拟化技术\n```\negrep --color 'vmx|svm' /proc/cpuinfo # vmx是intel的,svm是amd的\n```"},{"title":"使用docker-compose编排容器","url":"%2F2019%2F07%2F12%2FDocker%2F%E4%BD%BF%E7%94%A8docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8%2F"},{"title":"docker容器安装和使用","url":"%2F2019%2F07%2F12%2FDocker%2Fdocker%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F","content":"\n### docker容器安装和使用\n\n#### 安装docker\n\n{% codeblock lang:shell %}\n{% endcodeblock %}\n{% codeblock lang:shell %}\n{% endcodeblock %}\n{% codeblock lang:shell %}\n{% endcodeblock %}\n#### 使用docker基本命令\n"},{"title":"docker容器化部署项目","url":"%2F2019%2F07%2F11%2FDocker%2Fdocker%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%2F"},{"title":"手机刷kali-NetHunter","url":"%2F2019%2F06%2F30%2F%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD%2F%E5%88%B7%E6%9C%BA%2F%E6%89%8B%E6%9C%BA%E5%88%B7kali-NetHunter%2F","content":"\n### 手机刷kali-NetHunter\n\n#### 刷机包\n  1. 下载官方镜像\n{% codeblock lang:sh %}\nwget https://build.nethunter.com/nightly/2019.03-13-0514/kernel-nethunter-oneplus5-oos-nougat-2019.03-13-0514.zip\n{% endcodeblock %}\n  2. 自己制作镜像\n{% codeblock lang:sh %}\ngit clone https://github.com/offensive-security/kali-nethunter\ncd kali-nethunter\n#如果里面没有任何东西，那么可以执行一下命令\ngit checkout origin/origin/master\ncd nethunter-installer\n./bootstrap.sh\n{% endcodeblock %}\n\n"},{"title":"SpringBoot整合Redis","url":"%2F2019%2F06%2F26%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FSpringBoot%2FSpringBoot%E6%95%B4%E5%90%88Redis%2F","content":"\n### SpringBoot整合Redis\n\n#### 创建模块\n\n#### 导入依赖\n  + 如果pom文件中没有对应的依赖，则导入以下依赖\n{% codeblock lang:java %}\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n{% endcodeblock %}\n\n#### 配置application.properties\n{% codeblock lang:java %}\n# Redis数据库索引（默认为0）\nspring.redis.database=0\n# Redis服务器地址\nspring.redis.host=192.168.0.24\n# Redis服务器连接端口\nspring.redis.port=6379\n# Redis服务器连接密码（默认为空）\nspring.redis.password=\n# 连接池最大连接数（使用负值表示没有限制）\nspring.redis.pool.max-active=200\n# 连接池最大阻塞等待时间（使用负值表示没有限制）\nspring.redis.pool.max-wait=-1\n# 连接池中的最大空闲连接\nspring.redis.pool.max-idle=10\n# 连接池中的最小空闲连接\nspring.redis.pool.min-idle=0\n# 连接超时时间（毫秒）\nspring.redis.timeout=1000 \n{% endcodeblock %}\n\n#### 相关链接\n[redis配置]()\n"},{"title":"BLFS构建06-常用库和工具","url":"%2F2019%2F06%2F19%2FBLFS%2FBLFS%E6%9E%84%E5%BB%BA06-%E5%B8%B8%E7%94%A8%E5%BA%93%E5%92%8C%E5%B7%A5%E5%85%B7%2F","content":"\n### BLFS构建06-常用库和工具\n#### apr\n{% codeblock lang:sh %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/a/apr-1.6.5.tar.bz2\ntar -jxvf apr-1.6.5.tar.bz2\ncd apr-1.6.5\n./configure --prefix=/usr    \\\n            --disable-static \\\n            --with-installbuilddir=/usr/share/apr-1/build &&\nmake\nmake install\n{% endcodeblock %}\n#### apr-utils\n{% codeblock lang:sh %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/a/apr-util-1.6.1.tar.bz2\ntar -jxvf apr-util-1.6.1.tar.bz2 \ncd apr-util-1.6.1\n./configure --prefix=/usr       \\\n            --with-apr=/usr     \\\n            --with-gdbm=/usr    \\\n            --with-openssl=/usr \\\n            --with-crypto &&\nmake\nmake install\n{% endcodeblock %}\n#### aspell\n{% codeblock lang:sh %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/a/aspell-0.60.6.1.tar.gz\nwget https://ftp.gnu.org/gnu/aspell/dict\ntar -zxvf aspell-0.60.6.1.tar.gz \ncd aspell-0.60.6.1\nsed -i '/ top.do_check ==/s/top.do_check/*&/' modules/filter/tex.cpp &&\nsed -i '/word ==/s/word/*&/'                  prog/check_funs.cpp\n./configure --prefix=/usr &&\nmake\nmake install &&\nln -svfn aspell-0.60 /usr/lib/aspell &&\n\ninstall -v -m755 -d /usr/share/doc/aspell-0.60.6.1/aspell{,-dev}.html &&\n\ninstall -v -m644 manual/aspell.html/* \\\n    /usr/share/doc/aspell-0.60.6.1/aspell.html &&\n\ninstall -v -m644 manual/aspell-dev.html/* \\\n    /usr/share/doc/aspell-0.60.6.1/aspell-dev.html\n\ninstall -v -m 755 scripts/ispell /usr/bin/\ninstall -v -m 755 scripts/spell /usr/bin/\n\n./configure &&\nmake\nmake install\n{% endcodeblock %}\n  + aspell依赖which\n{% codeblock lang:sh %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/w/which-2.21.tar.gz\ntar -zxvf which-2.21.tar.gz\nwhich-2.21\n./configure --prefix=/usr &&\nmake\nmake install\n#配置\ncat > /usr/bin/which << \"EOF\"\n#!/bin/bash\ntype -pa \"$@\" | head -n 1 ; exit ${PIPESTATUS[0]}\nEOF\nchmod -v 755 /usr/bin/which\nchown -v root:root /usr/bin/which\n{% endcodeblock %}\n{% codeblock lang:sh %}\n{% endcodeblock %}\n{% codeblock lang:sh %}\n{% endcodeblock %}\n{% codeblock lang:sh %}\n{% endcodeblock %}\n{% codeblock lang:sh %}\n{% endcodeblock %}\n"},{"title":"BLFS构建05-文件系统和磁盘管理","url":"%2F2019%2F06%2F16%2FBLFS%2FBLFS%E6%9E%84%E5%BB%BA05-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F","content":"\n### BLFS构建05-文件系统和磁盘管理\n\n#### 构建一个initramfs\n  + 创建安装脚本/sbin/mkinitramfs\n{% codeblock lang:sh %}\ncat > /sbin/mkinitramfs << \"EOF\"\n#!/bin/bash\n# This file based in part on the mkinitramfs script for the LFS LiveCD\n# written by Alexander E. Patrakov and Jeremy Huntwork.\n\ncopy()\n{\n  local file\n\n  if [ \"$2\" == \"lib\" ]; then\n    file=$(PATH=/lib:/usr/lib type -p $1)\n  else\n    file=$(type -p $1)\n  fi\n\n  if [ -n $file ] ; then\n    cp $file $WDIR/$2\n  else\n    echo \"Missing required file: $1 for directory $2\"\n    rm -rf $WDIR\n    exit 1\n  fi\n}\n\nif [ -z $1 ] ; then\n  INITRAMFS_FILE=initrd.img-no-kmods\nelse\n  KERNEL_VERSION=$1\n  INITRAMFS_FILE=initrd.img-$KERNEL_VERSION\nfi\n\nif [ -n \"$KERNEL_VERSION\" ] && [ ! -d \"/lib/modules/$1\" ] ; then\n  echo \"No modules directory named $1\"\n  exit 1\nfi\n\nprintf \"Creating $INITRAMFS_FILE... \"\n\nbinfiles=\"sh cat cp dd killall ls mkdir mknod mount \"\nbinfiles=\"$binfiles umount sed sleep ln rm uname\"\nbinfiles=\"$binfiles readlink basename\"\n\n# Systemd installs udevadm in /bin. Other udev implementations have it in /sbin\nif [ -x /bin/udevadm ] ; then binfiles=\"$binfiles udevadm\"; fi\n\nsbinfiles=\"modprobe blkid switch_root\"\n\n#Optional files and locations\nfor f in mdadm mdmon udevd udevadm; do\n  if [ -x /sbin/$f ] ; then sbinfiles=\"$sbinfiles $f\"; fi\ndone\n\nunsorted=$(mktemp /tmp/unsorted.XXXXXXXXXX)\n\nDATADIR=/usr/share/mkinitramfs\nINITIN=init.in\n\n# Create a temporary working directory\nWDIR=$(mktemp -d /tmp/initrd-work.XXXXXXXXXX)\n\n# Create base directory structure\nmkdir -p $WDIR/{bin,dev,lib/firmware,run,sbin,sys,proc,usr}\nmkdir -p $WDIR/etc/{modprobe.d,udev/rules.d}\ntouch $WDIR/etc/modprobe.d/modprobe.conf\nln -s lib $WDIR/lib64\nln -s ../bin $WDIR/usr/bin\n\n# Create necessary device nodes\nmknod -m 640 $WDIR/dev/console c 5 1\nmknod -m 664 $WDIR/dev/null    c 1 3\n\n# Install the udev configuration files\nif [ -f /etc/udev/udev.conf ]; then\n  cp /etc/udev/udev.conf $WDIR/etc/udev/udev.conf\nfi\n\nfor file in $(find /etc/udev/rules.d/ -type f) ; do\n  cp $file $WDIR/etc/udev/rules.d\ndone\n\n# Install any firmware present\ncp -a /lib/firmware $WDIR/lib\n\n# Copy the RAID configuration file if present\nif [ -f /etc/mdadm.conf ] ; then\n  cp /etc/mdadm.conf $WDIR/etc\nfi\n\n# Install the init file\ninstall -m0755 $DATADIR/$INITIN $WDIR/init\n\nif [  -n \"$KERNEL_VERSION\" ] ; then\n  if [ -x /bin/kmod ] ; then\n    binfiles=\"$binfiles kmod\"\n  else\n    binfiles=\"$binfiles lsmod\"\n    sbinfiles=\"$sbinfiles insmod\"\n  fi\nfi\n\n# Install basic binaries\nfor f in $binfiles ; do\n  if [ -e /bin/$f ]; then d=\"/bin\"; else d=\"/usr/bin\"; fi\n  ldd $d/$f | sed \"s/\\t//\" | cut -d \" \" -f1 >> $unsorted\n  copy $d/$f bin\ndone\n\n# Add lvm if present\nif [ -x /sbin/lvm ] ; then sbinfiles=\"$sbinfiles lvm dmsetup\"; fi\n\nfor f in $sbinfiles ; do\n  ldd /sbin/$f | sed \"s/\\t//\" | cut -d \" \" -f1 >> $unsorted\n  copy $f sbin\ndone\n\n# Add udevd libraries if not in /sbin\nif [ -x /lib/udev/udevd ] ; then\n  ldd /lib/udev/udevd | sed \"s/\\t//\" | cut -d \" \" -f1 >> $unsorted\nelif [ -x /lib/systemd/systemd-udevd ] ; then\n  ldd /lib/systemd/systemd-udevd | sed \"s/\\t//\" | cut -d \" \" -f1 >> $unsorted\nfi\n\n# Add module symlinks if appropriate\nif [ -n \"$KERNEL_VERSION\" ] && [ -x /bin/kmod ] ; then\n  ln -s kmod $WDIR/bin/lsmod\n  ln -s kmod $WDIR/bin/insmod\nfi\n\n# Add lvm symlinks if appropriate\n# Also copy the lvm.conf file\nif  [ -x /sbin/lvm ] ; then\n  ln -s lvm $WDIR/sbin/lvchange\n  ln -s lvm $WDIR/sbin/lvrename\n  ln -s lvm $WDIR/sbin/lvextend\n  ln -s lvm $WDIR/sbin/lvcreate\n  ln -s lvm $WDIR/sbin/lvdisplay\n  ln -s lvm $WDIR/sbin/lvscan\n\n  ln -s lvm $WDIR/sbin/pvchange\n  ln -s lvm $WDIR/sbin/pvck\n  ln -s lvm $WDIR/sbin/pvcreate\n  ln -s lvm $WDIR/sbin/pvdisplay\n  ln -s lvm $WDIR/sbin/pvscan\n\n  ln -s lvm $WDIR/sbin/vgchange\n  ln -s lvm $WDIR/sbin/vgcreate\n  ln -s lvm $WDIR/sbin/vgscan\n  ln -s lvm $WDIR/sbin/vgrename\n  ln -s lvm $WDIR/sbin/vgck\n  # Conf file(s)\n  cp -a /etc/lvm $WDIR/etc\nfi\n\n# Install libraries\nsort $unsorted | uniq | while read library ; do\n  if [ \"$library\" == \"linux-vdso.so.1\" ] ||\n     [ \"$library\" == \"linux-gate.so.1\" ]; then\n    continue\n  fi\n\n  copy $library lib\ndone\n\nif [ -d /lib/udev ]; then\n  cp -a /lib/udev $WDIR/lib\nfi\nif [ -d /lib/systemd ]; then\n  cp -a /lib/systemd $WDIR/lib\nfi\n\n# Install the kernel modules if requested\nif [ -n \"$KERNEL_VERSION\" ]; then\n  find                                                                        \\\n     /lib/modules/$KERNEL_VERSION/kernel/{crypto,fs,lib}                      \\\n     /lib/modules/$KERNEL_VERSION/kernel/drivers/{block,ata,md,firewire}      \\\n     /lib/modules/$KERNEL_VERSION/kernel/drivers/{scsi,message,pcmcia,virtio} \\\n     /lib/modules/$KERNEL_VERSION/kernel/drivers/usb/{host,storage}           \\\n     -type f 2> /dev/null | cpio --make-directories -p --quiet $WDIR\n\n  cp /lib/modules/$KERNEL_VERSION/modules.{builtin,order}                     \\\n            $WDIR/lib/modules/$KERNEL_VERSION\n\n  depmod -b $WDIR $KERNEL_VERSION\nfi\n\n( cd $WDIR ; find . | cpio -o -H newc --quiet | gzip -9 ) > $INITRAMFS_FILE\n\n# Remove the temporary directory and file\nrm -rf $WDIR $unsorted\nprintf \"done.\\n\"\nEOF\n{%endcodeblock %}\n  + 设置权限\n{% codeblock lang:sh %}\nchmod 0755 /sbin/mkinitramfs\n{% endcodeblock %}\n  + 创建需要的目录和文件\n{% codeblock lang:sh %}\nmkdir -p /usr/share/mkinitramfs\ncat > /usr/share/mkinitramfs/init.in << \"EOF\"\n#!/bin/sh\n\nPATH=/bin:/usr/bin:/sbin:/usr/sbin\nexport PATH\n\nproblem()\n{\n   printf \"Encountered a problem!\\n\\nDropping you to a shell.\\n\\n\"\n   sh\n}\n\nno_device()\n{\n   printf \"The device %s, which is supposed to contain the\\n\" $1\n   printf \"root file system, does not exist.\\n\"\n   printf \"Please fix this problem and exit this shell.\\n\\n\"\n}\n\nno_mount()\n{\n   printf \"Could not mount device %s\\n\" $1\n   printf \"Sleeping forever. Please reboot and fix the kernel command line.\\n\\n\"\n   printf \"Maybe the device is formatted with an unsupported file system?\\n\\n\"\n   printf \"Or maybe filesystem type autodetection went wrong, in which case\\n\"\n   printf \"you should add the rootfstype=... parameter to the kernel command line.\\n\\n\"\n   printf \"Available partitions:\\n\"\n}\n\ndo_mount_root()\n{\n   mkdir /.root\n   [ -n \"$rootflags\" ] && rootflags=\"$rootflags,\"\n   rootflags=\"$rootflags$ro\"\n\n   case \"$root\" in\n      /dev/* ) device=$root ;;\n      UUID=* ) eval $root; device=\"/dev/disk/by-uuid/$UUID\"  ;;\n      LABEL=*) eval $root; device=\"/dev/disk/by-label/$LABEL\" ;;\n      \"\"     ) echo \"No root device specified.\" ; problem    ;;\n   esac\n\n   while [ ! -b \"$device\" ] ; do\n       no_device $device\n       problem\n   done\n\n   if ! mount -n -t \"$rootfstype\" -o \"$rootflags\" \"$device\" /.root ; then\n       no_mount $device\n       cat /proc/partitions\n       while true ; do sleep 10000 ; done\n   else\n       echo \"Successfully mounted device $root\"\n   fi\n}\n\ninit=/sbin/init\nroot=\nrootdelay=\nrootfstype=auto\nro=\"ro\"\nrootflags=\ndevice=\n\nmount -n -t devtmpfs devtmpfs /dev\nmount -n -t proc     proc     /proc\nmount -n -t sysfs    sysfs    /sys\nmount -n -t tmpfs    tmpfs    /run\n\nread -r cmdline < /proc/cmdline\n\nfor param in $cmdline ; do\n  case $param in\n    init=*      ) init=${param#init=}             ;;\n    root=*      ) root=${param#root=}             ;;\n    rootdelay=* ) rootdelay=${param#rootdelay=}   ;;\n    rootfstype=*) rootfstype=${param#rootfstype=} ;;\n    rootflags=* ) rootflags=${param#rootflags=}   ;;\n    ro          ) ro=\"ro\"                         ;;\n    rw          ) ro=\"rw\"                         ;;\n  esac\ndone\n\n# udevd location depends on version\nif [ -x /sbin/udevd ]; then\n  UDEVD=/sbin/udevd\nelif [ -x /lib/udev/udevd ]; then\n  UDEVD=/lib/udev/udevd\nelif [ -x /lib/systemd/systemd-udevd ]; then\n  UDEVD=/lib/systemd/systemd-udevd\nelse\n  echo \"Cannot find udevd nor systemd-udevd\"\n  problem\nfi\n\n${UDEVD} --daemon --resolve-names=never\nudevadm trigger\nudevadm settle\n\nif [ -f /etc/mdadm.conf ] ; then mdadm -As                       ; fi\nif [ -x /sbin/vgchange  ] ; then /sbin/vgchange -a y > /dev/null ; fi\nif [ -n \"$rootdelay\"    ] ; then sleep \"$rootdelay\"              ; fi\n\ndo_mount_root\n\nkillall -w ${UDEVD##*/}\n\nexec switch_root /.root \"$init\" \"$@\"\n\nEOF\n{% endcodeblock %}\n  + 需要依赖cpio\n{% codeblock lang:sh %}\nwget https://ftp.gnu.org/gnu/cpio/cpio-2.12.tar.bz2\ntar -jxvf cpio-2.12.tar.bz2\ncd cpio-2.12\n./configure --prefix=/usr  --bindir=/bin --enable-mt  --with-rmt=/usr/libexec/rmt\nmake\nmakeinfo --html            -o doc/html      doc/cpio.texi\nmakeinfo --html --no-split -o doc/cpio.html doc/cpio.texi\nmakeinfo --plaintext       -o doc/cpio.txt  doc/cpio.texi\nmake install\ninstall -v -m755 -d /usr/share/doc/cpio-2.12/html\ninstall -v -m644    doc/html/* /usr/share/doc/cpio-2.12/html\ninstall -v -m644    doc/cpio.{html,txt} /usr/share/doc/cpio-2.12\n{% endcodeblock %}\n  + 也需要依赖lvm(可以不用)\n{% codeblock lang:sh %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/l/LVM2.2.03.02.tgz\ntar -zxvf LVM2.2.03.02.tgz \ncd LVM2.2.03.02\n\nSAVEPATH=$PATH                  &&\nPATH=$PATH:/sbin:/usr/sbin      &&\n./configure --prefix=/usr       \\\n            --exec-prefix=      \\\n            --enable-cmdlib     \\\n            --enable-pkgconfig  \\\n            --enable-udev_sync\n\nmake\nPATH=$SAVEPATH                  &&\nunset SAVEPATH\n\nmake -C tools install_dmsetup_dynamic &&\nmake -C udev  install                 &&\nmake -C libdm install\n\nmake install\n{% endcodeblock %}\n  + lvm依赖libaio\n{% codeblock lang:sh %}\nwget http://ftp.de.debian.org/debian/pool/main/liba/libaio/libaio_0.3.111.orig.tar.gz\ntar -zxvf libaio_0.3.111.orig.tar.gz \ncd libaio-0.3.111/\nsed -i '/install.*libaio.a/s/^/#/' src/Makefile\nmake\nmake install\n{% endcodeblock %}\n  + 创建initramfs文件\n{% codeblock lang:sh %}\nmkinitramfs\n# 编辑grub.cfg文件\n# Generic initramfs and root fs identified by UUID\nmenuentry \"LFS Dev (LFS-7.0-Feb14) initrd, Linux 3.0.4\"\n{\n  linux  /vmlinuz-3.0.4-lfs-20120214 root=UUID=54b934a9-302d-415e-ac11-4988408eb0a8 ro\n  initrd /initrd.img-no-kmods\n}\n#使用blkid命令查看磁盘UUID\n{% endcodeblock %}\n#### btrfs-progs\n{% codeblock lang:sh %}\nwget https://www.kernel.org/pub/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v4.20.1.tar.xz\ntar -xvf btrfs-progs-v4.20.1.tar.xz\ncd btrfs-progs-v4.20.1\n./configure --prefix=/usr --bindir=/bin  --libdir=/lib --disable-zstd\nmake\nmake fssum\nsed -i '/found/s/^/: #/' tests/convert-tests.sh\nmv tests/mkfs-tests/013-reserved-1M-for-single/test.sh{,.broken}          &&\nmv tests/convert-tests/010-reiserfs-basic/test.sh{,.broken}               &&\nmv tests/convert-tests/011-reiserfs-delete-all-rollback/test.sh{,.broken} &&\nmv tests/convert-tests/012-reiserfs-large-hole-extent/test.sh{,.broken}   &&\nmv tests/convert-tests/013-reiserfs-common-inode-flags/test.sh{,.broken}  &&\nmv tests/convert-tests/014-reiserfs-tail-handling/test.sh{,.broken}       &&\nmv tests/misc-tests/004-shrink-fs/test.sh{,.broken}                       &&\nmv tests/misc-tests/013-subvolume-sync-crash/test.sh{,.broken}            &&\nmv tests/misc-tests/025-zstd-compression/test.sh{,.broken}                &&\nmv tests/fuzz-tests/003-multi-check-unmounted/test.sh{,.broken}           &&\nmv tests/fuzz-tests/009-simple-zero-log/test.sh{,.broken}\n\n#测试\npushd tests\n   ./fsck-tests.sh\n   ./mkfs-tests.sh\n   ./cli-tests.sh\n   ./convert-tests.sh\n   ./misc-tests.sh\n   ./fuzz-tests.sh\npopd\n\nmake install\n\nln -sfv ../../lib/$(readlink /lib/libbtrfs.so) /usr/lib/libbtrfs.so &&\nln -sfv ../../lib/$(readlink /lib/libbtrfsutil.so) /usr/lib/libbtrfsutil.so &&\nrm -fv /lib/libbtrfs.{a,so} /lib/libbtrfsutil.{a,so} &&\nmv -v /bin/{mkfs,fsck}.btrfs /sbin\n{% endcodeblock %}\n  + 安装依赖LZO\n{% codeblock lang:sh %}\nwget http://www.oberhumer.com/opensource/lzo/download/lzo-2.10.tar.gz\ntar -zxvf lzo-2.10.tar.gz\ncd lzo-2.10\n./configure --prefix=/usr --enable-shared --disable-static --disable-static\nmake\nmake install\n{% endcodeblock %}\n  + 安装依赖xmlto\n{% codeblock lang:sh %}\nhttps://releases.pagure.org/xmlto/xmlto-0.0.28.tar.bz2\n{% endcodeblock %}\n  + 安装docbook-xml的依赖libxml2,sgml-common和unzip\n{% codeblock lang:sh %}\nwget http://xmlsoft.org/sources/libxml2-2.9.9.tar.gz\nwget http://www.w3.org/XML/Test/xmlts20130923.tar.gz \ntar -zxvf libxml2-2.9.9.tar.gz \ncd libxml2-2.9.9\n./configure --prefix=/usr --disable-static --with-history --with-python=/usr/bin/python3\nmake\ntar xf ../xmlts20130923.tar.gz\nmake install\n\nwget wget http://ftp.lfs-matrix.net/pub/blfs/8.4/s/sgml-common-0.6.3.tgz\nwget http://www.linuxfromscratch.org/patches/blfs/8.4/sgml-common-0.6.3-manpage-1.patch\ntar -zxvf sgml-common-0.6.3.tgz\ncd sgml-common-0.6.3\npatch -Np1 -i ../sgml-common-0.6.3-manpage-1.patch\nautoreconf -f -i\n./configure --prefix=/usr --sysconfdir=/etc\nmake\nmake docdir=/usr/share/doc install\ninstall-catalog --add /etc/sgml/sgml-ent.cat /usr/share/sgml/sgml-iso-entities-8879.1986/catalog\ninstall-catalog --add /etc/sgml/sgml-docbook.cat /etc/sgml/sgml-ent.cat\n\nwget wget http://ftp.lfs-matrix.net/pub/blfs/8.4/u/unzip60.tar.gz\ntar -zxvf unzip60.tar.gz\ncd unzip60\nmake -f unix/Makefile generic\nmake prefix=/usr MANDIR=/usr/share/man/man1  -f unix/Makefile install\n{% endcodeblock %}\n  + 安装xmlto的依赖docbook-xml,docbook-xsl和libxslt\n{% codeblock lang:sh %}\n#docbook-xml\nmkdir docbook-xml ;  mv docbook-xml-4.5.zip docbook-xml\ncd docbook-xml\ninstall -v -d -m755 /usr/share/xml/docbook/xml-dtd-4.5\ninstall -v -d -m755 /etc/xml\nchown -R root:root .\ncp -v -af docbook.cat *.dtd ent/ *.mod /usr/share/xml/docbook/xml-dtd-4.5\n\n#配置docbook\nif [ ! -e /etc/xml/docbook ]; then\n    xmlcatalog --noout --create /etc/xml/docbook\nfi &&\nxmlcatalog --noout --add \"public\" \\\n    \"-//OASIS//DTD DocBook XML V4.5//EN\" \\\n    \"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd\" \\\n    /etc/xml/docbook &&\nxmlcatalog --noout --add \"public\" \\\n    \"-//OASIS//DTD DocBook XML CALS Table Model V4.5//EN\" \\\n    \"file:///usr/share/xml/docbook/xml-dtd-4.5/calstblx.dtd\" \\\n    /etc/xml/docbook &&\nxmlcatalog --noout --add \"public\" \\\n    \"-//OASIS//DTD XML Exchange Table Model 19990315//EN\" \\\n    \"file:///usr/share/xml/docbook/xml-dtd-4.5/soextblx.dtd\" \\\n    /etc/xml/docbook &&\nxmlcatalog --noout --add \"public\" \\\n    \"-//OASIS//ELEMENTS DocBook XML Information Pool V4.5//EN\" \\\n    \"file:///usr/share/xml/docbook/xml-dtd-4.5/dbpoolx.mod\" \\\n    /etc/xml/docbook &&\nxmlcatalog --noout --add \"public\" \\\n    \"-//OASIS//ELEMENTS DocBook XML Document Hierarchy V4.5//EN\" \\\n    \"file:///usr/share/xml/docbook/xml-dtd-4.5/dbhierx.mod\" \\\n    /etc/xml/docbook &&\nxmlcatalog --noout --add \"public\" \\\n    \"-//OASIS//ELEMENTS DocBook XML HTML Tables V4.5//EN\" \\\n    \"file:///usr/share/xml/docbook/xml-dtd-4.5/htmltblx.mod\" \\\n    /etc/xml/docbook &&\nxmlcatalog --noout --add \"public\" \\\n    \"-//OASIS//ENTITIES DocBook XML Notations V4.5//EN\" \\\n    \"file:///usr/share/xml/docbook/xml-dtd-4.5/dbnotnx.mod\" \\\n    /etc/xml/docbook &&\nxmlcatalog --noout --add \"public\" \\\n    \"-//OASIS//ENTITIES DocBook XML Character Entities V4.5//EN\" \\\n    \"file:///usr/share/xml/docbook/xml-dtd-4.5/dbcentx.mod\" \\\n    /etc/xml/docbook &&\nxmlcatalog --noout --add \"public\" \\\n    \"-//OASIS//ENTITIES DocBook XML Additional General Entities V4.5//EN\" \\\n    \"file:///usr/share/xml/docbook/xml-dtd-4.5/dbgenent.mod\" \\\n    /etc/xml/docbook &&\nxmlcatalog --noout --add \"rewriteSystem\" \\\n    \"http://www.oasis-open.org/docbook/xml/4.5\" \\\n    \"file:///usr/share/xml/docbook/xml-dtd-4.5\" \\\n    /etc/xml/docbook &&\nxmlcatalog --noout --add \"rewriteURI\" \\\n    \"http://www.oasis-open.org/docbook/xml/4.5\" \\\n    \"file:///usr/share/xml/docbook/xml-dtd-4.5\" \\\n    /etc/xml/docbook\n\n#配置/etc/xml/catalog\nif [ ! -e /etc/xml/catalog ]; then\n    xmlcatalog --noout --create /etc/xml/catalog\nfi &&\nxmlcatalog --noout --add \"delegatePublic\" \\\n    \"-//OASIS//ENTITIES DocBook XML\" \\\n    \"file:///etc/xml/docbook\" \\\n    /etc/xml/catalog &&\nxmlcatalog --noout --add \"delegatePublic\" \\\n    \"-//OASIS//DTD DocBook XML\" \\\n    \"file:///etc/xml/docbook\" \\\n    /etc/xml/catalog &&\nxmlcatalog --noout --add \"delegateSystem\" \\\n    \"http://www.oasis-open.org/docbook/\" \\\n    \"file:///etc/xml/docbook\" \\\n    /etc/xml/catalog &&\nxmlcatalog --noout --add \"delegateURI\" \\\n    \"http://www.oasis-open.org/docbook/\" \\\n    \"file:///etc/xml/docbook\" \\\n    /etc/xml/catalog\n\n#配置docbook-xml-dtd\n    for DTDVERSION in 4.1.2 4.2 4.3 4.4\ndo\n  xmlcatalog --noout --add \"public\" \\\n    \"-//OASIS//DTD DocBook XML V$DTDVERSION//EN\" \\\n    \"http://www.oasis-open.org/docbook/xml/$DTDVERSION/docbookx.dtd\" \\\n    /etc/xml/docbook\n  xmlcatalog --noout --add \"rewriteSystem\" \\\n    \"http://www.oasis-open.org/docbook/xml/$DTDVERSION\" \\\n    \"file:///usr/share/xml/docbook/xml-dtd-4.5\" \\\n    /etc/xml/docbook\n  xmlcatalog --noout --add \"rewriteURI\" \\\n    \"http://www.oasis-open.org/docbook/xml/$DTDVERSION\" \\\n    \"file:///usr/share/xml/docbook/xml-dtd-4.5\" \\\n    /etc/xml/docbook\n  xmlcatalog --noout --add \"delegateSystem\" \\\n    \"http://www.oasis-open.org/docbook/xml/$DTDVERSION/\" \\\n    \"file:///etc/xml/docbook\" \\\n    /etc/xml/catalog\n  xmlcatalog --noout --add \"delegateURI\" \\\n    \"http://www.oasis-open.org/docbook/xml/$DTDVERSION/\" \\\n    \"file:///etc/xml/docbook\" \\\n    /etc/xml/catalog\ndone\n\n#安装docbook-xsl\nwget https://github.com/docbook/xslt10-stylesheets/releases/download/release/1.79.2/docbook-xsl-nons-1.79.2.tar.bz2\nwget http://www.linuxfromscratch.org/patches/blfs/8.4/docbook-xsl-nons-1.79.2-stack_fix-1.patch\ntar -jxvf docbook-xsl-nons-1.79.2.tar.bz2\ncd docbook-xsl-nons-1.79.2\npatch -Np1 -i ../docbook-xsl-nons-1.79.2-stack_fix-1.patch\ntar -xf ../docbook-xsl-doc-1.79.2.tar.bz2 --strip-components=1\ninstall -v -m755 -d /usr/share/xml/docbook/xsl-stylesheets-nons-1.79.2\ncp -v -R VERSION assembly common eclipse epub epub3 extensions fo highlighting html htmlhelp images javahelp lib manpages params profiling roundtrip slides template tests tools webhelp website xhtml xhtml-1_1 xhtml5  /usr/share/xml/docbook/xsl-stylesheets-nons-1.79.2\nln -s VERSION /usr/share/xml/docbook/xsl-stylesheets-nons-1.79.2/VERSION.xsl\ninstall -v -m644 -D README /usr/share/doc/docbook-xsl-nons-1.79.2/README.txt\ninstall -v -m644    RELEASE-NOTES* NEWS* /usr/share/doc/docbook-xsl-nons-1.79.2\ncp -v -R doc/* /usr/share/doc/docbook-xsl-nons-1.79.2\n\n#配置docbook-xsl\nif [ ! -d /etc/xml ]; then install -v -m755 -d /etc/xml; fi &&\nif [ ! -f /etc/xml/catalog ]; then\n    xmlcatalog --noout --create /etc/xml/catalog\nfi &&\n\nxmlcatalog --noout --add \"rewriteSystem\" \\\n           \"https://cdn.docbook.org/release/xsl-nons/1.79.2\" \\\n           \"/usr/share/xml/docbook/xsl-stylesheets-nons-1.79.2\" \\\n    /etc/xml/catalog &&\n\nxmlcatalog --noout --add \"rewriteURI\" \\\n           \"https://cdn.docbook.org/release/xsl-nons/1.79.2\" \\\n           \"/usr/share/xml/docbook/xsl-stylesheets-nons-1.79.2\" \\\n    /etc/xml/catalog &&\n\nxmlcatalog --noout --add \"rewriteSystem\" \\\n           \"https://cdn.docbook.org/release/xsl-nons/current\" \\\n           \"/usr/share/xml/docbook/xsl-stylesheets-nons-1.79.2\" \\\n    /etc/xml/catalog &&\n\nxmlcatalog --noout --add \"rewriteURI\" \\\n           \"https://cdn.docbook.org/release/xsl-nons/current\" \\\n           \"/usr/share/xml/docbook/xsl-stylesheets-nons-1.79.2\" \\\n    /etc/xml/catalog &&\n\nxmlcatalog --noout --add \"rewriteSystem\" \\\n           \"http://docbook.sourceforge.net/release/xsl/current\" \\\n           \"/usr/share/xml/docbook/xsl-stylesheets-nons-1.79.2\" \\\n    /etc/xml/catalog &&\n\nxmlcatalog --noout --add \"rewriteURI\" \\\n           \"http://docbook.sourceforge.net/release/xsl/current\" \\\n           \"/usr/share/xml/docbook/xsl-stylesheets-nons-1.79.2\" \\\n    /etc/xml/catalog\n#安装libxslt\ntar -zxvf libxslt-1.1.33.tar.gz\ncd libxslt-1.1.33\nsed -i s/3000/5000/ libxslt/transform.c doc/xsltproc.{1,xml}\n./configure --prefix=/usr --disable-static\nmake\nmake install\n{% endcodeblock %}\n  + 安装btfs-ptogs依赖xmlto\n{% codeblock lang:sh %}\nwget https://releases.pagure.org/xmlto/xmlto-0.0.28.tar.bz2\ntar -jxvf xmlto-0.0.28.tar.bz2 \ncd xmlto-0.0.28\nLINKS=\"/usr/bin/links\" ./configure --prefix=/usr \nmake\nmake install\n{% endcodeblock %}\n  + 安装btfs-progs依赖asciidoc\n{% codeblock lang:sh %}\nwget https://downloads.sourceforge.net/asciidoc/asciidoc-8.6.9.tar.gz\ntar -zxvf asciidoc-8.6.9.tar.gz\ncd asciidoc-8.6.9\n./configure --prefix=/usr --sysconfdir=/etc --docdir=/usr/share/doc/asciidoc-8.6.9\nmake\nmake install\nmake docs\n{% endcodeblock %}\n  + 安装asciidoc依赖python2.7\n{% codeblock lang:sh %}\nwget https://www.python.org/ftp/python/2.7.15/Python-2.7.15.tar.xz\nwget https://docs.python.org/ftp/python/doc/2.7.15/python-2.7.15-docs-html.tar.bz2\ntar xvf Python-2.7.15.tar.xz\ncd Python-2.7.15\n./configure --prefix=/usr  --enable-shared --with-system-expat --with-system-ffi --with-ensurepip=yes --enable-unicode=ucs4\nmake\nmake install\nchmod -v 755 /usr/lib/libpython2.7.so.1.0\ninstall -v -dm755 /usr/share/doc/python-2.7.15\ntar --strip-components=1 --no-same-owner --directory /usr/share/doc/python-2.7.15  -xvf ../python-2.7.15-docs-html.tar.bz2\nfind /usr/share/doc/python-2.7.15 -type d -exec chmod 0755 {} \\;\nfind /usr/share/doc/python-2.7.15 -type f -exec chmod 0644 {} \\;\n#配置python2\nexport PYTHONDOCS=/usr/share/doc/python-2.7.15\n{% endcodeblock %}\n#### dosfstools\n{% codeblock lang:sh %}\nwget https://github.com/dosfstools/dosfstools/releases/download/v4.1/dosfstools-4.1.tar.xz\ntar xvf dosfstools-4.1.tar.xz\ncd dosfstools-4.1\n./configure --prefix=/  --enable-compat-symlinks --mandir=/usr/share/man --docdir=/usr/share/doc/dosfstools-4.1\nmake\nmake install\n{% endcodeblock %}\n#### fuse\n{% codeblock lang:sh %}\nwget https://github.com/libfuse/libfuse/releases/download/fuse-3.4.1/fuse-3.4.1.tar.xz\ntar xvf fuse-3.4.1.tar.xz\ncd fuse-3.4.1\nsed -i '/^udev/,$ s/^/#/' util/meson.build\nmkdir build &&\ncd    build\nmeson --prefix=/usr ..\nninja\nninja install                                             &&\n\nmv -vf   /usr/lib/libfuse3.so.3*     /lib                 &&\nln -sfvn ../../lib/libfuse3.so.3.4.1 /usr/lib/libfuse3.so &&\n\nmv -vf /usr/bin/fusermount3  /bin         &&\nmv -vf /usr/sbin/mount.fuse3 /sbin        &&\nchmod u+s /bin/fusermount3                &&\n\ninstall -v -m755 -d /usr/share/doc/fuse-3.4.1      &&\ninstall -v -m644    ../doc/{README.NFS,kernel.txt} \\\n                    /usr/share/doc/fuse-3.4.1      &&\ncp -Rv ../doc/html  /usr/share/doc/fuse-3.4.1\n#配置文件\ncat > /etc/fuse.conf << \"EOF\"\n# Set the maximum number of FUSE mounts allowed to non-root users.\n# The default is 1000.\n#\n#mount_max = 1000\n\n# Allow non-root users to specify the 'allow_other' or 'allow_root'\n# mount options.\n#\n#user_allow_other\nEOF\n{% endcodeblock %}\n#### fuse2.9.7\n{% codeblock lang:sh %}\nwget https://github.com/libfuse/libfuse/releases/download/fuse-2.9.7/fuse-2.9.7.tar.gz\ntar -zxvf fuse-2.9.7.tar.gz\ncd fuse-2.9.7\n\n./configure --prefix=/usr    \\\n            --disable-static \\\n            --exec-prefix=/\n\nmake \nmake DESTDIR=$PWD/Dest install\n\ninstall -vm755 Dest/lib/libfuse.so.2.9.7 /lib                  &&\ninstall -vm755 Dest/lib/libulockmgr.so.1.0.1 /lib                 &&\nln -sfv ../../lib/libfuse.so.2.9.7 /usr/lib/libfuse.so         &&\nln -sfv ../../lib/libulockmgr.so.1.0.1 /usr/lib/libulockmgr.so &&\n\ninstall -vm644  Dest/lib/pkgconfig/fuse.pc /usr/lib/pkgconfig  &&\n\ninstall -vm4755 Dest/bin/fusermount       /bin                 &&\ninstall -vm755  Dest/bin/ulockmgr_server  /bin                 &&\n\ninstall -vm755  Dest/sbin/mount.fuse      /sbin                &&\n\ninstall -vdm755 /usr/include/fuse                              &&\n\ninstall -vm644  Dest/usr/include/*.h      /usr/include         &&\ninstall -vm644  Dest/usr/include/fuse/*.h /usr/include/fuse/   &&\n\ninstall -vm644  Dest/usr/share/man/man1/* /usr/share/man/man1  &&\n/sbin/ldconfig -v\n{% endcodeblock %}\n#### jfsutils\n{% codeblock lang:sh %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/j/jfsutils-1.1.15.tar.gz\ntar -zxvf jfsutils-1.1.15.tar.gz\ncd jfsutils-1.1.15\n\nsed -i \"/unistd.h/a#include <sys/types.h>\"    fscklog/extract.c &&\nsed -i \"/ioctl.h/a#include <sys/sysmacros.h>\" libfs/devices.c\n./configure\nmake\nmake install\n{% endcodeblock %}\n#### 软件磁盘阵列mdadm\n{% codeblock lang:sh %}\nwget https://www.kernel.org/pub/linux/utils/raid/mdadm/mdadm-4.0.tar.xz\ntar -xvf mdadm-4.0.tar.xz\ncd mdadm-4.0\nsed 's@-Werror@@' -i Makefile\nmake\nsed -i 's# if.* == \"1\"#& -a -e $targetdir/log#' test\nmake test\n./test --keep-going --logdir=test-logs --save-logs\nmake install\n{% endcodeblock %}\n#### parted\n{% codeblock lang:sh %}\nwget https://ftp.gnu.org/gnu/parted/parted-3.2.tar.xz\nwget http://www.linuxfromscratch.org/patches/blfs/8.4/parted-3.2-devmapper-1.patch\ntar xvf parted-3.2.tar.xz\ncd parted-3.2\npatch -Np1 -i ../parted-3.2-devmapper-1.patch\nsed -i '/utsname.h/a#include <sys/sysmacros.h>' libparted/arch/linux.c\n./configure --prefix=/usr --disable-static\nmake\n\nmake -C doc html                                       &&\nmakeinfo --html      -o doc/html       doc/parted.texi &&\nmakeinfo --plaintext -o doc/parted.txt doc/parted.texi\nsed -i '/t0251-gpt-unicode.sh/d' tests/Makefile\nmake install\n\ninstall -v -m755 -d /usr/share/doc/parted-3.2/html &&\ninstall -v -m644    doc/html/* \\\n                    /usr/share/doc/parted-3.2/html &&\ninstall -v -m644    doc/{FAT,API,parted.{txt,html}} \\\n                    /usr/share/doc/parted-3.2\ninstall -v -m644 doc/FAT doc/API doc/parted.{pdf,ps,dvi} \\\n                    /usr/share/doc/parted-3.2\n{% endcodeblock %}\n#### ntfs-3g(微软ntfs)\n{% codeblock lang:sh %}\nwget https://tuxera.com/opensource/ntfs-3g_ntfsprogs-2017.3.23.tgz\ntar -zxvf ntfs-3g_ntfsprogs-2017.3.23.tgz\ncd ntfs-3g_ntfsprogs-2017.3.23\n\n./configure --prefix=/usr        \\\n            --disable-static     \\\n            --with-fuse=internal\nmake\n\nmake install &&\nln -sv ../bin/ntfs-3g /sbin/mount.ntfs &&\nln -sv ntfs-3g.8 /usr/share/man/man8/mount.ntfs.8\nchmod -v 4755 /bin/ntfs-3g\n{% endcodeblock %}\n#### gptfdisk\n{% codeblock lang:sh %}\nwget https://downloads.sourceforge.net/gptfdisk/gptfdisk-1.0.4.tar.gz\nwget http://www.linuxfromscratch.org/patches/blfs/8.4/gptfdisk-1.0.4-convenience-1.patch\ntar -zxvf gptfdisk-1.0.4.tar.gz\ncd gptfdisk-1.0.4\npatch -Np1 -i ../gptfdisk-1.0.4-convenience-1.patch\nmake\nmake install\n{% endcodeblock %}\n  + gptfdisk依赖popt\n{% codeblock lang:sh %}\nwget ftp://anduin.linuxfromscratch.org/BLFS/popt/popt-1.16.tar.gz\n tar -zxvf popt-1.16.tar.gz\n cd popt-1.16\n./configure --prefix=/usr --disable-static\nmake\nmake install\ninstall -v -m755 -d /usr/share/doc/popt-1.16 &&\ninstall -v -m644 doxygen/html/* /usr/share/doc/popt-1.16\n{% endcodeblock %}\n#### reiserfsprogs\n{% codeblock lang:sh %}\nwget https://www.kernel.org/pub/linux/kernel/people/jeffm/reiserfsprogs/v3.6.27/reiserfsprogs-3.6.27.tar.xz\ntar xvf reiserfsprogs-3.6.27.tar.xz\ncd reiserfsprogs-3.6.27\nsed -i '/parse_time.h/i #define _GNU_SOURCE' lib/parse_time.c\n\nautoreconf -fiv             &&\n./configure --prefix=/usr   \\\n            --sbindir=/sbin\nmake\nmake install\n{% endcodeblock %}\n#### smartmontools\n{% codeblock lang:sh %}\nwget https://downloads.sourceforge.net/smartmontools/smartmontools-7.0.tar.gz\ntar -zxvf smartmontools-7.0.tar.gz\ncd smartmontools-7.0\n./configure --prefix=/usr           \\\n            --sysconfdir=/etc       \\\n            --with-initscriptdir=no \\\n            --docdir=/usr/share/doc/smartmontools-7.0\nmake\nmake install\n#开机启动\ncd /sources/blfs-bootscripts-20180105\nmake install-smartd\n{% endcodeblock %}\n#### sshfs\n  + 需要依赖(fuse(前面已经安装),glib,openssh)\n{% codeblock lang:sh %}\n# pcre \nwget https://ftp.pcre.org/pub/pcre/pcre-8.42.tar.bz2\ntar -jxvf pcre-8.42.tar.bz2\ncd pcre-8.42\n./configure --prefix=/usr                     \\\n            --docdir=/usr/share/doc/pcre-8.42 \\\n            --enable-unicode-properties       \\\n            --enable-pcre16                   \\\n            --enable-pcre32                   \\\n            --enable-pcregrep-libz            \\\n            --enable-pcregrep-libbz2          \\\n            --enable-pcretest-libreadline     \\\n            --disable-static \nmake\nmake install\nmv -v /usr/lib/libpcre.so.* /lib &&\nln -sfv ../../lib/$(readlink /usr/lib/libpcre.so) /usr/lib/libpcre.so\n#glib\nwget http://ftp.gnome.org/pub/gnome/sources/glib/2.58/glib-2.58.3.tar.xz\nwget http://www.linuxfromscratch.org/patches/blfs/8.4/glib-2.58.3-skip_warnings-1.patch\ntar xvf glib-2.58.3.tar.xz\ncd glib-2.58.3\npatch -Np1 -i ../glib-2.58.3-skip_warnings-1.patch\nmkdir build-glib &&\ncd    build-glib\nmeson --prefix=/usr   \\\n      -Dman=true      \\\n      -Dselinux=false \\\n      ..              &&\nninja\n#如果缺失这些库，可以从宿主机复制\ncp /lib/libglib-2.0.so.0 /mnt/lib/\ncp /lib64/libgio-2.0.so.0 /mnt/lib/\ncp /lib64/libgobject-2.0.so.0 /mnt/lib/\ncp /lib64/libgmodule-2.0.so.0 /mnt/lib/\nninja install &&\nmkdir -p /usr/share/doc/glib-2.58.3 &&\ncp -r ../docs/reference/{NEWS,gio,glib,gobject} /usr/share/doc/glib-2.58.3\n\n#openssh\nwget http://ftp.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-7.9p1.tar.gz\nwget http://www.linuxfromscratch.org/patches/blfs/8.4/openssh-7.9p1-security_fix-1.patch\ntar -zxvf openssh-7.9p1.tar.gz\ncd openssh-7.9p1\ninstall  -v -m700 -d /var/lib/sshd &&\nchown    -v root:sys /var/lib/sshd\n\ngroupadd -g 50 sshd        &&\nuseradd  -c 'sshd PrivSep' \\\n         -d /var/lib/sshd  \\\n         -g sshd           \\\n         -s /bin/false     \\\n         -u 50 sshd\n\npatch -Np1 -i ../openssh-7.9p1-security_fix-1.patch\n./configure --prefix=/usr                     \\\n            --sysconfdir=/etc/ssh             \\\n            --with-md5-passwords              \\\n            --with-privsep-path=/var/lib/sshd\nmake\nmake install\n\ninstall -v -m755    contrib/ssh-copy-id /usr/bin     &&\n\ninstall -v -m644    contrib/ssh-copy-id.1 \\\n                    /usr/share/man/man1              &&\ninstall -v -m755 -d /usr/share/doc/openssh-7.9p1     &&\ninstall -v -m644    INSTALL LICENCE OVERVIEW README* \\\n                    /usr/share/doc/openssh-7.9p1\n\n#配置openssh\necho \"PermitRootLogin no\" >> /etc/ssh/sshd_config\n#生成秘钥\nssh-keygen &&\nssh-copy-id -i ~/.ssh/id_rsa.pub REMOTE_USERNAME@REMOTE_HOSTNAME\n\n#如果有安装有linux-pam，则执行下面这些语句\nsed 's@d/login@d/sshd@g' /etc/pam.d/login > /etc/pam.d/sshd &&\nchmod 644 /etc/pam.d/sshd &&\necho \"UsePAM yes\" >> /etc/ssh/sshd_config\n\n#开机启动\ncd /sources/blfs-bootscripts-20180105/\nmake install-sshd\necho \"PasswordAuthentication no\" >> /etc/ssh/sshd_config &&\necho \"ChallengeResponseAuthentication no\" >> /etc/ssh/sshd_config\n{% endcodeblock %}\n{% codeblock lang:sh %}\nwget https://github.com/libfuse/sshfs/releases/download/sshfs-3.5.1/sshfs-3.5.1.tar.xz\ntar xvf sshfs-3.5.1.tar.xz\ncd sshfs-3.5.1\nmkdir build &&\ncd    build\nmeson --prefix=/usr ..\nninja\nninja install\n{% endcodeblock %}\n#### xfsprogs\n{% codeblock lang:sh %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/x/xfsprogs-4.19.0.tar.xz\ntar xvf xfsprogs-4.19.0.tar.xz\ncd xfsprogs-4.19.0\nmake DEBUG=-DNDEBUG     \\\n     INSTALL_USER=root  \\\n     INSTALL_GROUP=root \\\n     LOCAL_CONFIGURE_OPTIONS=\"--enable-readline\"\n\nmake PKG_DOC_DIR=/usr/share/doc/xfsprogs-4.19.0 install     &&\nmake PKG_DOC_DIR=/usr/share/doc/xfsprogs-4.19.0 install-dev &&\n\nrm -rfv /usr/lib/libhandle.a                                &&\nrm -rfv /lib/libhandle.{a,la,so}                            &&\nln -sfv ../../lib/libhandle.so.1 /usr/lib/libhandle.so      &&\nsed -i \"s@libdir='/lib@libdir='/usr/lib@\" /usr/lib/libhandle.la\n{% endcodeblock %}\n{% codeblock lang:sh %}\n{% endcodeblock %}\n{% codeblock lang:sh %}\n{% endcodeblock %}\n"},{"title":"Java技术栈","url":"%2F2019%2F06%2F12%2F%E6%8A%80%E6%9C%AF%E6%A0%88%2FJava%E6%8A%80%E6%9C%AF%E6%A0%88%2F","content":"\n### Java技术栈\n\nSSM : Spring + Springmvc + Mybatis\nSSH : Spring + Springmvc + Hebernate\nSSSM: SpringBoot + Spring + Mybatis + Springmvc\nshiro授权 + cas单点登录\nredis缓存数据库\nzuul网关\neureka注册中心\nSpring cloud\nthymleaf模板引擎\ndruid德鲁伊数据库连接池\nc3p0数据库连接池\nnginx反向代理服务器\njenkins持续集成\ntomcat\nribbin\n\n服务架构\n  1. soa架构\n  2. 微服务架构\n  3. 服务网格架构\n","tags":["技术栈"],"categories":["技术栈"]},{"title":"shiro应用","url":"%2F2019%2F06%2F12%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FShiro%2Fshiro%E5%BA%94%E7%94%A8%2F"},{"title":"Spring整合shiro","url":"%2F2019%2F06%2F12%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FShiro%2FSpring%E6%95%B4%E5%90%88shiro%2F","content":"\n### Spring整合shiro\n\n#### 引言\n> shiro在Spring中最大的作用是授权\n#### shiro主要功能\n\n##### 授权功能\n  + 代码式授权\n    需要在自己的realm中写入授权代码\n  + 注解式授权\n    需要在spring-mvc.xml中配置注解授权支持\n    并且在controller中设置注解\n  + jsp页面授权\n    需要在jsp页面中导入shiro的授权标签库\n##### 缓存功能\n  + 解决问题\n    我们在项目中每一次授权都要去查询数据库，这样的话数据库的压力就会相当的大\n  + 解决方法\n    shiro提供了cache缓存机制，这样会将第一次授权查询数据库所得的数据缓存，以便以后授权使用\n  + 需求\n    导入ehcache依赖，配置ehcache.xml文件,配置bean-shiro.xml文件\n##### session管理功能(没啥用)\n\n##### rememberMe功能\n  + 解决问题\n    我们输入用户信息登录后，不会记住我们的用户信息，这样我们在段时间后登录就需要重新输入数据\n  + 解决方法\n    shiro提供了rememberMe功能，使得用户信息能够保存一定时间\n  + 需求\n    配置bean-shiro.xml文件，编写测试页面\n#### 使用maven管理\n  + 配置pom文件，导入包\n{% codeblock lang:java %}\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.shiro.test</groupId>\n  <artifactId>myShiro</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <packaging>war</packaging>\n\n  <name>myShiro Maven Webapp</name>\n  <!-- FIXME change it to the project's website -->\n  <url>http://www.example.com</url>\n\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n      <scope>test</scope>\n    </dependency>\n\n    <!--导入shiro的相关的包 -->\n    <dependency>\n      <groupId>org.apache.shiro</groupId>\n      <artifactId>shiro-core</artifactId>\n      <version>1.3.2</version>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.shiro</groupId>\n      <artifactId>shiro-web</artifactId>\n      <version>1.3.2</version>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.shiro</groupId>\n      <artifactId>shiro-spring</artifactId>\n      <version>1.3.2</version>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.shiro</groupId>\n      <artifactId>shiro-quartz</artifactId>\n      <version>1.3.2</version>\n    </dependency>\n\n    <!--导入Spring的相关包 -->\n\n    <!--导入我们的Servlet的API -->\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>javax.servlet-api</artifactId>\n      <version>3.1.0</version>\n      <scope>provided</scope>\n    </dependency>\n\n    <!--导入我们jstl的标签库的包 -->\n    <dependency>\n      <groupId>javax.servlet.jsp.jstl</groupId>\n      <artifactId>javax.servlet.jsp.jstl-api</artifactId>\n      <version>1.2.1</version>\n    </dependency>\n\n    <!-- https://mvnrepository.com/artifact/javax.servlet/jsp-api -->\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>jsp-api</artifactId>\n      <version>2.0</version>\n      <scope>provided</scope>\n    </dependency>\n\n    <dependency>\n      <groupId>org.apache.taglibs</groupId>\n      <artifactId>taglibs-standard-impl</artifactId>\n      <version>1.2.5</version>\n    </dependency>\n\n    <!--导入我们的mybatis运行的时候的一些依赖包日志相关的 -->\n    <dependency>\n      <groupId>log4j</groupId>\n      <artifactId>log4j</artifactId>\n      <version>1.2.17</version>\n    </dependency>\n    <!--导入的是日志相关的包 -->\n    <dependency>\n      <groupId>commons-logging</groupId>\n      <artifactId>commons-logging</artifactId>\n      <version>1.2</version>\n    </dependency>\n    <!--带入cglib代理的包 -->\n    <dependency>\n      <groupId>cglib</groupId>\n      <artifactId>cglib</artifactId>\n      <version>3.2.4</version>\n    </dependency>\n    <!--引入junit类 -->\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.12</version>\n      <scope>test</scope>\n    </dependency>\n\n    <!--在使用Spring的时候没有这个包的时候是要报错的-->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context-support</artifactId>\n      <version>4.3.7.RELEASE</version>\n    </dependency>\n\n    <!--导入我们Spring的相关包 -->\n\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n      <version>4.3.7.RELEASE</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-core</artifactId>\n      <version>4.3.7.RELEASE</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-beans</artifactId>\n      <version>4.3.7.RELEASE</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-web</artifactId>\n      <version>4.3.7.RELEASE</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-webmvc</artifactId>\n      <version>4.3.7.RELEASE</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-aop</artifactId>\n      <version>4.3.7.RELEASE</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-jdbc</artifactId>\n      <version>4.3.7.RELEASE</version>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-tx</artifactId>\n      <version>4.3.7.RELEASE</version>\n    </dependency>\n\n    <!--介入aspectj的相关包 -->\n    <!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->\n    <dependency>\n      <groupId>org.aspectj</groupId>\n      <artifactId>aspectjweaver</artifactId>\n      <version>1.8.11</version>\n    </dependency>\n\n\n    <!--配置fastjson -->\n    <dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>fastjson</artifactId>\n      <version>1.2.47</version>\n    </dependency>\n\n    <!--简化实体类的编写，不用写setget方法-->\n    <dependency>\n      <groupId>org.projectlombok</groupId>\n      <artifactId>lombok</artifactId>\n      <version>1.18.6</version>\n      <scope>provided</scope>\n    </dependency>\n\n    <!--引入缓存包-->\n    <dependency>\n      <groupId>org.apache.shiro</groupId>\n      <artifactId>shiro-ehcache</artifactId>\n      <version>1.3.2</version>\n    </dependency>\n  </dependencies>\n\n\n</project>\n{% endcodeblock %}\n\n#### resources资源文件配置\n  + bean-shiro.xml配置(配置shiro过滤器)\n{% codeblock lang:java %}\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <!--1. 配置shiro过滤,这里的id需要与web.xml中保持一致-->\n    <bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n        <!--登录失败则跳转到下面这个地址-->\n        <property name=\"loginUrl\" value=\"/login.action\"></property>\n        <!--注入SecurityManager对象-->\n        <property name=\"securityManager\" ref=\"defaultWebSecurityManager\"></property>\n\n        <property name=\"unauthorizedUrl\" value=\"/refuse.jsp\"></property>\n        <!--定义过滤链-->\n        <property name=\"filterChainDefinitions\">\n            <value>\n                /favicon.ico = anon\n                <!--释放静态资源-->\n                /css/** = anon\n                /js/** = anon\n                <!--配置remmberMe-->\n                /index.jsp = user\n                <!--配置过滤器授权，这个路径的范文用户必须拥有userManager和seller权限-->\n                /filterAuth.action = perms[userManager]\n                /filterAuth.action = roles[seller]\n                <!--退出登录-->\n                /logout.action = logout\n                <!--表示所有资源需要认证后才能通过(需要写到最后)-->\n                /** = authc\n            </value>\n        </property>\n    </bean>\n\n\n    <!--2. 配置安全管理器-->\n    <bean id=\"defaultWebSecurityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n        <property name=\"realm\" ref=\"myRealm\"></property>\n        <!--注入缓存的管理器-->\n        <property name=\"cacheManager\" ref=\"ehCacheManager\"></property>\n\n        <!--注入sessionManager的管理器(没有用)-->\n<!--        <property name=\"sessionManager\" ref=\"sessionManager\"></property>-->\n        <property name=\"rememberMeManager\" ref=\"rememberMeManager\"></property>\n    </bean>\n\n    <!--声明自己的realm对象-->\n    <bean id=\"myRealm\" class=\"com.myShiro.realm.MyRealm\"></bean>\n\n\n\n    <!--3. 配置缓存管理器 -->\n    <bean id=\"ehCacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\">\n        <property name=\"cacheManager\" ref=\"cacheManager\"></property>\n    </bean>\n    <!--配置缓存-->\n    <bean id=\"cacheManager\" class=\"org.springframework.cache.ehcache.EhCacheManagerFactoryBean\">\n        <!--缓存是否共享-->\n        <property name=\"shared\" value=\"true\"></property>\n        <property name=\"configLocation\" value=\"classpath:ehcache.xml\"></property>\n    </bean>\n\n\n    <!--配置session管理器-->\n<!--    <bean id=\"sessionManager\" class=\"org.apache.shiro.session.mgt.DefaultSessionManager\">-->\n        <!--配置session过期之后是否需要删除-->\n<!--        <property name=\"deleteInvalidSessions\" value=\"true\"></property>-->\n        <!--配置session的超时时间-->\n<!--        <property name=\"globalSessionTimeout\" value=\"259200\"></property>-->\n<!--    </bean>-->\n\n    <!--配置记住我管理器-->\n    <bean id=\"rememberMeManager\" class=\"org.apache.shiro.web.mgt.CookieRememberMeManager\">\n        <!--注入cookie-->\n        <property name=\"cookie\" ref=\"cookie\"></property>\n    </bean>\n\n    <!--配置cookie-->\n    <bean id=\"cookie\" class=\"org.apache.shiro.web.servlet.SimpleCookie\">\n        <!--调用有参构造，给存储的cookie取名-->\n        <constructor-arg name=\"name\" value=\"rememberMe\"></constructor-arg>\n        <!--cookie最大生效时间-->\n        <property name=\"maxAge\" value=\"2596000\"></property>\n    </bean>\n</beans>\n{% endcodeblock %}\n  + spring-mvc.xml配置(配置springmvc)\n{% codeblock lang:java %}\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context-4.0.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop-4.0.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx-4.0.xsd\n        http://www.springframework.org/schema/mvc\n        http://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    <!--shiro注解授权配置-->\n    <bean id=\"authorizationAttributeSourceAdvisor\" class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\">\n        <!--注入安全管理器对象,使得授权有安全支持-->\n        <property name=\"securityManager\" ref=\"defaultWebSecurityManager\"></property>\n    </bean>\n    <!--开启aop，代理类-->\n    <aop:config proxy-target-class=\"true\"></aop:config>\n\n    <!--扫描控制器-->\n    <context:component-scan base-package=\"com.myShiro.controller\"></context:component-scan>\n\n    <!--加载注解驱动-->\n    <mvc:annotation-driven></mvc:annotation-driven>\n</beans>\n{% endcodeblock %}\n  + ehcache.xml(配置缓存)\n{% codeblock lang:xml  %}\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"ehcache.xsd\">\n\n    <!--缓存到硬盘的位置-->\n    <diskStore path=\"/tmp\"/>\n    <!--配置的是默认所有的缓存数据的生命周期-->\n    <defaultCache\n            maxElementsInMemory=\"1000\"\n            maxElementsOnDisk=\"10000000\"\n            eternal=\"false\"\n            overflowToDisk=\"false\"\n            timeToIdleSeconds=\"120\"\n            timeToLiveSeconds=\"120\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    </defaultCache>\n</ehcache>\n{% endcodeblock  %}\n  + [ehcache.xsd](/downloaad/Java/Shiro/ehcache.xsd)\n#### webapp配置\n  + web.xml配置(项目配置)\n{% codeblock lang:java %}\n<!DOCTYPE web-app PUBLIC\n \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"\n \"http://java.sun.com/dtd/web-app_2_3.dtd\" >\n\n<web-app>\n  <display-name>Archetype Created Web Application</display-name>\n\n  <!--配置Spring-->\n  <context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>classpath:bean-*.xml</param-value>\n  </context-param>\n\n  <!--配置shiro的过滤器-->\n  <filter>\n    <filter-name>shiroFilter</filter-name>\n    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n    <!--管理生命周期-->\n    <init-param>\n      <param-name>targetFilterLifecycle</param-name>\n      <param-value>true</param-value>\n    </init-param>\n  </filter>\n  <filter-mapping>\n    <filter-name>shiroFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n  \n  <listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n  </listener>\n\n  <!--配置spingmvc-->\n  <servlet>\n    <servlet-name>DispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value>classpath:sping-mvc.xml</param-value>\n    </init-param>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>DispatcherServlet</servlet-name>\n    <url-pattern>*.action</url-pattern>\n  </servlet-mapping>\n</web-app>\n{% endcodeblock %}\n\n#### java源文件\n##### com.myShiro.controller包\n  + UserController\n{% codeblock lang:java %}\npackage com.myShiro.controller;\n\nimport org.apache.shiro.authz.annotation.RequiresPermissions;\nimport org.apache.shiro.authz.annotation.RequiresRoles;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class UserController {\n\n    /**\n     * 认证出错时跳转到login.jsp页面\n     * 收集错误信息\n     * @return\n     */\n    @RequestMapping(\"login\")\n    public String login(){\n        return \"/login.jsp\";\n    }\n\n\n    @RequestMapping(\"filterAuth\")\n    public String filterAuth(){\n        System.out.println(\"过滤器授权已经执行\");\n        return \"/first.jsp\";\n    }\n\n    /**\n     * 使用注解授权\n     * 当前方法必须要具有userManager和seller权限才能访问\n     */\n    @RequestMapping(\"annotationAuth\")\n    @RequiresPermissions(\"userManager\")\n    @RequiresRoles(\"seller\")\n    public String annotationAuth(){\n        System.out.println(\"过滤器已经授权...\");\n        return \"/first.jsp\";\n    }\n}\n{% endcodeblock %}\n  + IndexController\n{% codeblock lang:java %}\npackage com.myShiro.controller;\n\nimport com.myShiro.pojo.User;\nimport org.apache.shiro.SecurityUtils;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class IndexController {\n\n    /**\n     * 登录成功跳转到首页\n     */\n    @RequestMapping(\"jumpIndexPage\")\n    public String jumpIndexPage(Model model){\n        //取出登录用户\n        User user = (User) SecurityUtils.getSubject().getPrincipal();\n        System.out.println(\"取出登录用户：\"+user);\n        //将登录用户对象放入域对象中\n        model.addAttribute(\"user\",user);\n\n        //带值跳转到index.jsp页面\n        return \"/index.jsp\" ;\n    }\n}\n{% endcodeblock %}\n#### com.myShiro.pojo包\n  + User\n{% codeblock lang:java %}\npackage com.myShiro.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport java.io.Serializable;\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@ToString\npublic class User implements Serializable {\n    private int id ;\n    private String username ;\n    private String password ;\n\n}\n{% endcodeblock %}\n#### com.myShiro.realm包\n  + MyRealm\n{% codeblock lang:java %}\npackage com.myShiro.realm;\n\nimport com.myShiro.pojo.User;\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class MyRealm extends AuthorizingRealm {\n\n    /**\n     * 重写Class类中的getName方法\n     * @return\n     */\n    @Override\n    public String getName(){\n        return \"MyRealm\" ;\n    }\n\n    /**\n     * 授权的方法\n     * @param principalCollection\n     * @return\n     */\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        System.out.println(\"我是realm的授权...\");\n        //使用代码进行授权\n        Set<String> perms = new HashSet<>();\n        perms.add(\"userManager\");\n        perms.add(\"adManager\");\n        perms.add(\"deptManager\");\n        perms.add(\"employeeManager\");\n\n        Set<String> roles = new HashSet<>();\n        roles.add(\"seller\");\n        roles.add(\"employee\");\n\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        //将集合中的权限字符串加入authorizationInfo对象中\n        authorizationInfo.setStringPermissions(perms);\n        authorizationInfo.setRoles(roles);\n        return authorizationInfo ;\n    }\n\n    /**\n     * 认证的方法\n     * @param authenticationToken\n     * @return 返回的是一个简单认证信息对象\n     * @throws AuthenticationException\n     *\n     * userName: 输入的authenticationToken对象，也就是用户账户名\n     * user.getPassword: 证书，也就是用户密码，这是从数据库中查询出来用于匹配的\n     * getName():获取的是当前realm类的类名\n     */\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        //从令牌中获取用户名\n        String userName = (String) authenticationToken.getPrincipal();\n        System.out.println(\"输入的用户名：\"+userName);\n        //通过用户名查找对象(如果输入的用户名与指定的用户名不相同则授权失败)\n        if(!(\"rack\".equals(userName))){\n            System.out.println(\"没找到\");\n            return null ;\n        }\n\n        //在这里创建一个用户对象代表从数据库中查找数据\n        User user = new User(1,\"rack\",\"123\");\n        System.out.println(\"数据库中用户信息：\"+user);\n        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user, user.getPassword(), getName());\n        System.out.println(\"info:\"+info);\n        return info ;\n    }\n}\n{% endcodeblock %}\n#### com.myShiro.filter\n  + MyFormAuthenticationFilter(表单验证过滤器)\n{% codeblock lang:java %}\npackage com.myShiro.filter;\n\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.web.filter.authc.FormAuthenticationFilter;\nimport org.apache.shiro.web.util.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\npublic class MyFormAuthenticationFilter extends FormAuthenticationFilter {\n\n    @Override\n    protected boolean onLoginSuccess(AuthenticationToken token, Subject subject,\n                   ServletRequest request, ServletResponse response) throws Exception{\n        //清空请求\n        WebUtils.getAndClearSavedRequest(request);\n        //重定向页面\n        WebUtils.issueRedirect(request , response , \"/first.action\");\n        return false ;\n    }\n}\n{% endcodeblock %}\n#### 测试\n  + 测试登录\n{% codeblock lang:java %}\n{% endcodeblock %}\n  + 测试过滤器授权\n{% codeblock lang:java %}\n{% endcodeblock %}\n  + 测试注解授权\n{% codeblock lang:java %}\n{% endcodeblock %}\n","tags":["Shiro"],"categories":["Shiro"]},{"title":"BLFS构建04-安全问题","url":"%2F2019%2F06%2F12%2FBLFS%2FBLFS%E6%9E%84%E5%BB%BA04-%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F","content":"\n### BLFS构建04-安全问题\n\n#### make-ca-1.2\n{% codeblock lang:shell %}\n#下载安装p11的依赖包libtasn1\nwget https://ftp.gnu.org/gnu/libtasn1/libtasn1-4.13.tar.gz\ntar -zxvf libtasn1-4.13.tar.gz\ncd libtasn1-4.13\n./configure --prefix=/usr --disable-static\nmake\nmake install\nmake -C doc/reference install-data-local\n\n#下载安装make-ca的p11-kit依赖包\nwget https://github.com/p11-glue/p11-kit/releases/download/0.23.15/p11-kit-0.23.15.tar.gz\ntar -zxvf p11-kit-0.23.15.tar.gz\ncd p11-kit-0.23.15\nsed '20,$ d' -i trust/trust-extract-compat.in\ncat >> trust/trust-extract-compat.in << \"EOF\"\n# Copy existing anchor modifications to /etc/ssl/local\n/usr/libexec/make-ca/copy-trust-modifications\n\n# Generate a new trust store\n/usr/sbin/make-ca -f -g\nEOF\n\n./configure --prefix=/usr  --sysconfdir=/etc --with-trust-paths=/etc/pki/anchors\nmake\nmake install\nln -s /usr/libexec/p11-kit/trust-extract-compat /usr/bin/update-ca-certificates\n\n#最后下载安装make-ca\nwget https://github.com/djlucas/make-ca/releases/download/v1.2/make-ca-1.2.tar.xz\ntar xvf make-ca-1.2.tar.xz\ncd make-ca-1.2\nmake install\n#下载 certdata.txt(证书文件)\nusr/sbin/make-ca -g\n#将新的证书放入系统中\nln -sfv /etc/pki/tls/certs/ca-bundle.crt /etc/ssl/ca-bundle.crt\ninstall -vdm755 /etc/cron.weekly \n\ncat > /etc/cron.weekly/update-pki.sh << \"EOF\"\n#!/bin/bash\n/usr/sbin/make-ca -g\nEOF\nchmod 754 /etc/cron.weekly/update-pki.sh\n\n#增加传统ca证书\ninstall -vdm755 /etc/ssl/local\n#下载ca证书（用宿主机下载）\nopenssl x509 -in root.crt -text -fingerprint -setalias \"CAcert Class 1 root\"  -addtrust serverAuth -addtrust emailProtection -addtrust codeSigning  > /etc/ssl/local/CAcert_Class_1_root.pem\nopenssl x509 -in class3.crt -text -fingerprint -setalias \"CAcert Class 3 root\"  -addtrust serverAuth -addtrust emailProtection -addtrust codeSigning  > /etc/ssl/local/CAcert_Class_3_root.pem\ninstall -vdm755 /etc/ssl/local\nopenssl x509 -in /etc/ssl/certs/Makebelieve_CA_Root.pem \\\n             -text \\\n             -fingerprint\n             -setalias \"Disabled Makebelieve CA Root\" \\\n             -addreject serverAuth \\\n             -addreject emailProtection \\\n             -addreject codeSigning \\\n       > /etc/ssl/local/Disabled_Makebelieve_CA_Root.pem\n/usr/sbin/make-ca -r -f\n{% endcodeblock %}\n\n#### consolekit2-1.2.1\n{% codeblock lang:shell %}\n#下载安装fontconfig的依赖包freetype2\nwget https://downloads.sourceforge.net/freetype/freetype-2.9.1.tar.bz2\nwget https://downloads.sourceforge.net/freetype/freetype-doc-2.9.1.tar.bz2\ntar -jxvf freetype-2.9.1.tar.bz2\ncd freetype-2.9.1\ntar -xvf ../freetype-doc-2.9.1.tar.bz2 --strip-components=2 -C docs\nsed -ri \"s:.*(AUX_MODULES.*valid):\\1:\" modules.cfg\nsed -r \"s:.*(#.*SUBPIXEL_RENDERING) .*:\\1:\" -i include/freetype/config/ftoption.h\n./configure --prefix=/usr --enable-freetype-config --disable-static\nmake\nmake install\ninstall -v -m755 -d /usr/share/doc/freetype-2.9.1\ncp -v -R docs/*     /usr/share/doc/freetype-2.9.1\nrm -v /usr/share/doc/freetype-2.9.1/freetype-config.1\n#下载安装xorg-lib的依赖包fontconfig\nwget https://www.freedesktop.org/software/fontconfig/release/fontconfig-2.13.1.tar.bz2\ntar -jxvf fontconfig-2.13.1.tar.bz2\ncd fontconfig-2.13.1\nrm -f src/fcobjshash.h\n./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var --disable-docs  --docdir=/usr/share/doc/fontconfig-2.13.1\nmake\nmake install\ninstall -v -dm755  /usr/share/{man/man{1,3,5},doc/fontconfig-2.13.1/fontconfig-devel}\ninstall -v -m644 fc-*/*.1         /usr/share/man/man1\ninstall -v -m644 doc/*.3          /usr/share/man/man3\ninstall -v -m644 doc/fonts-conf.5 /usr/share/man/man5\ninstall -v -m644 doc/fontconfig-devel/* /usr/share/doc/fontconfig-2.13.1/fontconfig-devel\ninstall -v -m644 doc/*.{pdf,sgml,txt,html} /usr/share/doc/fontconfig-2.13.1\n##配置文件路径\n/etc/fonts/*, /etc/fonts/conf.d/* and /usr/share/fontconfig/conf.avail/*\n#配置util-macros的依赖xorg环境\nmkdir xc\ncd xc\nexport XORG_PREFIX=\"/usr\"\nexport XORG_CONFIG=\"--prefix=$XORG_PREFIX --sysconfdir=/etc --localstatedir=/var --disable-static\"\ncat > /etc/profile.d/xorg.sh << EOF\nXORG_PREFIX=\"$XORG_PREFIX\"\nXORG_CONFIG=\"--prefix=\\$XORG_PREFIX --sysconfdir=/etc --localstatedir=/var --disable-static\"\nexport XORG_PREFIX XORG_CONFIG\nEOF\n\nchmod 644 /etc/profile.d/xorg.sh\n\ncat >> /etc/profile.d/xorg.sh << \"EOF\"\n\npathappend $XORG_PREFIX/bin             PATH\npathappend $XORG_PREFIX/lib/pkgconfig   PKG_CONFIG_PATH\npathappend $XORG_PREFIX/share/pkgconfig PKG_CONFIG_PATH\n\npathappend $XORG_PREFIX/lib             LIBRARY_PATH\npathappend $XORG_PREFIX/include         C_INCLUDE_PATH\npathappend $XORG_PREFIX/include         CPLUS_INCLUDE_PATH\n\nACLOCAL=\"aclocal -I $XORG_PREFIX/share/aclocal\"\n\nexport PATH PKG_CONFIG_PATH ACLOCAL LIBRARY_PATH C_INCLUDE_PATH CPLUS_INCLUDE_PATH\nEOF\n\necho \"$XORG_PREFIX/lib\" >> /etc/ld.so.conf\nsed \"s@/usr/X11R6@$XORG_PREFIX@g\" -i /etc/man_db.conf\nln -svf $XORG_PREFIX/share/X11 /usr/share/X11\nln -svf $XORG_PREFIX /usr/X11R6\n#下载xorgproto依赖包util-macros\nwget https://www.x.org/pub/individual/util/util-macros-1.19.2.tar.bz2\ntar -jxvf util-macros-1.19.2.tar.bz2\ncd util-macros-1.19.2\n./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var\nmake install\n#下载安装libxau的依赖xorgproto-2018.4\nhttps://xorg.freedesktop.org/archive/individual/proto/xorgproto-2018.4.tar.bz2\ntar -jxvf xorgproto-2018.4.tar.bz2\ncd xorgproto-2018.4\nmkdir build\ncd build\nmeson --prefix=/usr .. && ninja\nninja install\ninstall -vdm 755 $XORG_PREFIX/share/doc/xorgproto-2018.4\ninstall -vm 644 ../[^m]*.txt ../PM_spec $XORG_PREFIX/share/doc/xorgproto-2018.4\n#下载安装libxcb的依赖libxau\nwget https://www.x.org/pub/individual/lib/libXau-1.0.9.tar.bz2\ntar -jxvf libXau-1.0.9.tar.bz2\ncd libXau-1.0.9\n./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var\nmake install\n#下载安装libxcb的依赖xcb-proto\nwget https://xcb.freedesktop.org/dist/xcb-proto-1.13.tar.bz2\ntar -jxvf xcb-proto-1.13.tar.bz2\ncd xcb-proto-1.13\n./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var\nmake install\n#下载安装xorg-lib的依赖包libxcb\nwget https://xcb.freedesktop.org/dist/libxcb-1.13.1.tar.bz2\ntar -jxvf libxcb-1.13.1.tar.bz2\ncd libxcb-1.13.1\nsed -i \"s/pthread-stubs//\" configure\n./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var --disable-static --without-doxygen --docdir='${datadir}'/doc/libxcb-1.13.1\nmake\nmake install\n#下载安装consolekit的依赖xorg-lib\ncat > lib-7.md5 << \"EOF\"\nc5ba432dd1514d858053ffe9f4737dd8  xtrans-1.3.5.tar.bz2\n034fdd6cc5393974d88aec6f5bc96162  libX11-1.6.7.tar.bz2\n52df7c4c1f0badd9f82ab124fb32eb97  libXext-1.3.3.tar.bz2\nd79d9fe2aa55eb0f69b1a4351e1368f7  libFS-1.0.7.tar.bz2\naddfb1e897ca8079531669c7c7711726  libICE-1.0.9.tar.bz2\n87c7fad1c1813517979184c8ccd76628  libSM-1.2.3.tar.bz2\neeea9d5af3e6c143d0ea1721d27a5e49  libXScrnSaver-1.2.3.tar.bz2\n8f5b5576fbabba29a05f3ca2226f74d3  libXt-1.1.5.tar.bz2\n41d92ab627dfa06568076043f3e089e4  libXmu-1.1.2.tar.bz2\n20f4627672edb2bd06a749f11aa97302  libXpm-3.5.12.tar.bz2\ne5e06eb14a608b58746bdd1c0bd7b8e3  libXaw-1.0.13.tar.bz2\n07e01e046a0215574f36a3aacb148be0  libXfixes-5.0.3.tar.bz2\nf7a218dcbf6f0848599c6c36fc65c51a  libXcomposite-0.4.4.tar.bz2\n802179a76bded0b658f4e9ec5e1830a4  libXrender-0.9.10.tar.bz2\n58fe3514e1e7135cf364101e714d1a14  libXcursor-1.1.15.tar.bz2\n0cf292de2a9fa2e9a939aefde68fd34f  libXdamage-1.1.4.tar.bz2\n0920924c3a9ebc1265517bdd2f9fde50  libfontenc-1.1.3.tar.bz2\nb7ca87dfafeb5205b28a1e91ac3efe85  libXfont2-2.0.3.tar.bz2\n331b3a2a3a1a78b5b44cfbd43f86fcfe  libXft-2.3.2.tar.bz2\n1f0f2719c020655a60aee334ddd26d67  libXi-1.7.9.tar.bz2\n0d5f826a197dae74da67af4a9ef35885  libXinerama-1.1.4.tar.bz2\n28e486f1d491b757173dd85ba34ee884  libXrandr-1.5.1.tar.bz2\n5d6d443d1abc8e1f6fc1c57fb27729bb  libXres-1.2.0.tar.bz2\nef8c2c1d16a00bd95b9fdcef63b8a2ca  libXtst-1.2.3.tar.bz2\n210b6ef30dda2256d54763136faa37b9  libXv-1.0.11.tar.bz2\n4cbe1c1def7a5e1b0ed5fce8e512f4c6  libXvMC-1.0.10.tar.bz2\nd7dd9b9df336b7dd4028b6b56542ff2c  libXxf86dga-1.1.4.tar.bz2\n298b8fff82df17304dfdb5fe4066fe3a  libXxf86vm-1.1.4.tar.bz2\nd2f1f0ec68ac3932dd7f1d9aa0a7a11c  libdmx-1.1.4.tar.bz2\n8f436e151d5106a9cfaa71857a066d33  libpciaccess-0.14.tar.bz2\n4a4cfeaf24dab1b991903455d6d7d404  libxkbfile-1.0.9.tar.bz2\n42dda8016943dc12aff2c03a036e0937  libxshmfence-1.3.tar.bz2\nEOF\n\nmkdir lib &&\ncd lib &&\ngrep -v '^#' ../lib-7.md5 | awk '{print $2}' | wget -i- -c \\\n    -B https://www.x.org/pub/individual/lib/ &&\nmd5sum -c ../lib-7.md5\n##切换到bash\nbash -e\n##使用脚本批量安装(使用root)\nfor package in $(grep -v '^#' ../lib-7.md5 | awk '{print $2}')\ndo\n  packagedir=${package%.tar.bz2}\n  tar -xf $package\n  pushd $packagedir\n  case $packagedir in\n    libICE* )\n      ./configure $XORG_CONFIG ICE_LIBS=-lpthread\n    ;;\n\n    libXfont2-[0-9]* )\n      ./configure $XORG_CONFIG --disable-devel-docs\n    ;;\n\n    libXt-[0-9]* )\n      ./configure $XORG_CONFIG \\\n                  --with-appdefaultdir=/etc/X11/app-defaults\n    ;;\n\n    * )\n      ./configure $XORG_CONFIG\n    ;;\n  esac\n  make\n  #make check 2>&1 | tee ../$packagedir-make_check.log\n  make install\n  popd\n  rm -rf $packagedir\n  /sbin/ldconfig\ndone\n\n#下载安装consolekit的依赖dbus-glib-0.110\nwget https://dbus.freedesktop.org/releases/dbus-glib/dbus-glib-0.110.tar.gz\ntar -zxvf dbus-glib-0.110.tar.gz\ncd dbus-glib-0.110\ngroupadd -g 18 messagebus\nuseradd -c \"D-Bus Message Daemon User\" -d /var/run/dbus -u 18 -g messagebus -s /bin/false messagebus\n./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var  --disable-doxygen-docs --disable-xml-docs  --disable-static --docdir=/usr/share/doc/dbus-1.12.12 --with-console-auth-dir=/run/console --with-system-pid-file=/run/dbus/pid --with-system-socket=/run/dbus/system_bus_socket\n{% endcodeblock %}\n#### cracklib\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/c/cracklib-2.9.6.tar.gz \nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/c/cracklib-words-2.9.6.gz\ntar -zxvf cracklib-2.9.6.tar.gz\ncd cracklib-2.9.6\nsed -i '/skipping/d' util/packer.c &&\n\n./configure --prefix=/usr    \\\n            --disable-static \\\n            --with-default-dict=/lib/cracklib/pw_dict &&\nmake\n\nmake install                      &&\nmv -v /usr/lib/libcrack.so.* /lib &&\nln -sfv ../../lib/$(readlink /usr/lib/libcrack.so) /usr/lib/libcrack.so\ninstall -v -m644 -D    ../cracklib-words-2.9.6.gz \\\n                         /usr/share/dict/cracklib-words.gz     &&\n\ngunzip -v                /usr/share/dict/cracklib-words.gz     &&\nln -v -sf cracklib-words /usr/share/dict/words                 &&\necho $(hostname) >>      /usr/share/dict/cracklib-extra-words  &&\ninstall -v -m755 -d      /lib/cracklib                         &&\n\ncreate-cracklib-dict     /usr/share/dict/cracklib-words \\\n                         /usr/share/dict/cracklib-extra-words\n{% endcodeblock %}\n\n#### gnupg\n  + gnupg\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/g/gnupg-2.2.13.tar.bz2\ntar -jxvf gnupg-2.2.13.tar.bz2\ncd gnupg-2.2.13\nsed -e '/noinst_SCRIPTS = gpg-zip/c sbin_SCRIPTS += gpg-zip' \\\n    -i tools/Makefile.in\n\n./configure --prefix=/usr            \\\n            --enable-symcryptrun     \\\n            --docdir=/usr/share/doc/gnupg-2.2.13\nmake\n\nmakeinfo --html --no-split -o doc/gnupg_nochunks.html doc/gnupg.texi &&\nmakeinfo --plaintext       -o doc/gnupg.txt           doc/gnupg.texi\nmake install\n\ninstall -v -m755 -d /usr/share/doc/gnupg-2.2.13/html            &&\ninstall -v -m644    doc/gnupg_nochunks.html \\\n                    /usr/share/doc/gnupg-2.2.13/html/gnupg.html &&\ninstall -v -m644    doc/*.texi doc/gnupg.txt \\\n                    /usr/share/doc/gnupg-2.2.13\n{% endcodeblock %}\n  + gnupg依赖libassuan,libgcrypt,libgpg-error,libksba和npth\n{% codeblock lang:shell %}\n#lubassuan\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/g/gnupg-2.2.13.tar.bz2\ntar -jxvf libassuan-2.5.3.tar.bz2\ncd libassuan-2.5.3\n./configure --prefix=/usr\nmake\nmake install\n#libgpg-error\nwget  https://www.gnupg.org/ftp/gcrypt/libgpg-error/libgpg-error-1.35.tar.bz2\ntar -jxvf libgpg-error-1.35.tar.bz2\ncd libgpg-error-1.35\n./configure --prefix=/usr\nmake\nmake install\ninstall -v -m644 -D README /usr/share/doc/libgpg-error-1.35/README\n#libgcrypt\nwget  https://www.gnupg.org/ftp/gcrypt/libgcrypt/libgcrypt-1.8.4.tar.bz2\ntar -jxvf libgcrypt-1.8.4.tar.bz2\ncd libgcrypt-1.8.4\n./configure --prefix=/usr\nmake\nmakeinfo --html --no-split -o doc/gcrypt_nochunks.html doc/gcrypt.texi &&\nmakeinfo --plaintext       -o doc/gcrypt.txt           doc/gcrypt.texi\n\nmake install\n\ninstall -v -dm755   /usr/share/doc/libgcrypt-1.8.4 &&\ninstall -v -m644    README doc/{README.apichanges,fips*,libgcrypt*} \\\n                    /usr/share/doc/libgcrypt-1.8.4\n\n#libksba\nwget https://www.gnupg.org/ftp/gcrypt/libksba/libksba-1.3.5.tar.bz2\ntar -jxvf libksba-1.3.5.tar.bz2\ncd libksba-1.3.5\n./configure --prefix=/usr\nmake \nmake install\n\n#npth\nwget https://www.gnupg.org/ftp/gcrypt/npth/npth-1.6.tar.bz2\ntar -jxvf npth-1.6.tar.bz2\ncd npth-1.6\n./configure --prefix=/usr\nmake\nmake install\n{% endcodeblock %}\n#### gnutls\n  + gnutls\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/g/gnutls-3.6.6.tar.xz\ntar xvf gnutls-3.6.6.tar.xz\ncd gnutls-3.6.6\n\n./configure --prefix=/usr \\\n            --disable-guile \\\n            --with-default-trust-store-pkcs11=\"pkcs11:\" \\\n            --with-included-unistring\nmake\nmake install\nmake -C doc/reference install-data-local\n{% endcodeblock %}\n  + gnutls依赖nettle\n{% codeblock lang:shell %}\nwget wget http://ftp.lfs-matrix.net/pub/blfs/8.4/g/nettle-3.4.1.tar.gz\ntar -zxvf nettle-3.4.1.tar.gz\ncd nettle-3.4.1\n./configure --prefix=/usr --disable-static\nmake\nmake install &&\nchmod   -v   755 /usr/lib/lib{hogweed,nettle}.so &&\ninstall -v -m755 -d /usr/share/doc/nettle-3.4.1 &&\ninstall -v -m644 nettle.html /usr/share/doc/nettle-3.4.1\n{% endcodeblock %}\n#### gpgme\n{% codeblock lang:shell %}\nwget wget http://ftp.lfs-matrix.net/pub/blfs/8.4/g/gpgme-1.12.0.tar.bz2\ntar -jxvf gpgme-1.12.0.tar.bz2\ncd gpgme-1.12.0\n./configure --prefix=/usr --disable-gpg-test\nmake\nmake install\n{% endcodeblock %}\n#### haveged\n{% codeblock lang:shell %}\nwget wget http://ftp.lfs-matrix.net/pub/blfs/8.4/h/haveged-1.9.2.tar.gz\ntar -zxvf haveged-1.9.2.tar.gz \ncd haveged-1.9.2\n./configure --prefix=/usr\nmake\nmake install\nmkdir -pv    /usr/share/doc/haveged-1.9.2 &&\ncp -v README /usr/share/doc/haveged-1.9.2\n#开机启动\ncd /sources/blfs-bootscripts-20180105/\nmake install-haveged\n{% endcodeblock %}\n#### iptables\n{% codeblock lang:shell %}\nwget wget http://ftp.lfs-matrix.net/pub/blfs/8.4/i/iptables-1.8.2.tar.bz2\ntar -jxvf iptables-1.8.2.tar.bz2\ncd iptables-1.8.2\n\n./configure --prefix=/usr      \\\n            --sbindir=/sbin    \\\n            --disable-nftables \\\n            --enable-libipq    \\\n            --with-xtlibdir=/lib/xtables &&\nmake\n\nmake install &&\nln -sfv ../../sbin/xtables-legacy-multi /usr/bin/iptables-xml &&\n\nfor file in ip4tc ip6tc ipq iptc xtables\ndo\n  mv -v /usr/lib/lib${file}.so.* /lib &&\n  ln -sfv ../../lib/$(readlink /usr/lib/lib${file}.so) /usr/lib/lib${file}.so\ndone\n\n#开机启动\ncd /sources/blfs-bootscripts-20180105/\nmake install-iptables\n\n#配置网络防火墙\n/etc/rc.d/init.d/iptables start\n\ncat > /etc/rc.d/rc.iptables << \"EOF\"\n#!/bin/sh\n\n# Begin rc.iptables\n\n# Insert connection-tracking modules\n# (not needed if built into the kernel)\nmodprobe nf_conntrack\nmodprobe xt_LOG\n\n# Enable broadcast echo Protection\necho 1 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts\n\n# Disable Source Routed Packets\necho 0 > /proc/sys/net/ipv4/conf/all/accept_source_route\necho 0 > /proc/sys/net/ipv4/conf/default/accept_source_route\n\n# Enable TCP SYN Cookie Protection\necho 1 > /proc/sys/net/ipv4/tcp_syncookies\n\n# Disable ICMP Redirect Acceptance\necho 0 > /proc/sys/net/ipv4/conf/default/accept_redirects\n\n# Do not send Redirect Messages\necho 0 > /proc/sys/net/ipv4/conf/all/send_redirects\necho 0 > /proc/sys/net/ipv4/conf/default/send_redirects\n\n# Drop Spoofed Packets coming in on an interface, where responses\n# would result in the reply going out a different interface.\necho 1 > /proc/sys/net/ipv4/conf/all/rp_filter\necho 1 > /proc/sys/net/ipv4/conf/default/rp_filter\n\n# Log packets with impossible addresses.\necho 1 > /proc/sys/net/ipv4/conf/all/log_martians\necho 1 > /proc/sys/net/ipv4/conf/default/log_martians\n\n# be verbose on dynamic ip-addresses  (not needed in case of static IP)\necho 2 > /proc/sys/net/ipv4/ip_dynaddr\n\n# disable Explicit Congestion Notification\n# too many routers are still ignorant\necho 0 > /proc/sys/net/ipv4/tcp_ecn\n\n# Set a known state\niptables -P INPUT   DROP\niptables -P FORWARD DROP\niptables -P OUTPUT  DROP\n\n# These lines are here in case rules are already in place and the\n# script is ever rerun on the fly. We want to remove all rules and\n# pre-existing user defined chains before we implement new rules.\niptables -F\niptables -X\niptables -Z\n\niptables -t nat -F\n\n# Allow local-only connections\niptables -A INPUT  -i lo -j ACCEPT\n\n# Free output on any interface to any ip for any service\n# (equal to -P ACCEPT)\niptables -A OUTPUT -j ACCEPT\n\n# Permit answers on already established connections\n# and permit new connections related to established ones\n# (e.g. port mode ftp)\niptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\n\n# Log everything else. What's Windows' latest exploitable vulnerability?\niptables -A INPUT -j LOG --log-prefix \"FIREWALL:INPUT \"\n\n# End $rc_base/rc.iptables\nEOF\nchmod 700 /etc/rc.d/rc.iptables\n{% endcodeblock %}\n#### libcap\n  + libcap\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/l/libcap-2.26.tar.xz\ntar -xvf libcap-2.26.tar.xz\ncd libcap-2.26\nmake -C pam_cap\ninstall -v -m755 pam_cap/pam_cap.so /lib/security &&\ninstall -v -m644 pam_cap/capability.conf /etc/security\n{% endcodeblock %}\n  + libcap依赖linux-pam\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/l/Linux-PAM-1.3.0.tar.bz2\nwget wget http://ftp.lfs-matrix.net/pub/blfs/8.4/l/Linux-PAM-1.2.0-docs.tar.bz2\ntar -jxvf Linux-PAM-1.3.0.tar.bz2\ncd Linux-PAM-1.3.0\ntar -xf ../Linux-PAM-1.2.0-docs.tar.bz2 --strip-components=1\n./configure --prefix=/usr                    \\\n            --sysconfdir=/etc                \\\n            --libdir=/usr/lib                \\\n            --disable-regenerate-docu        \\\n            --enable-securedir=/lib/security \\\n            --docdir=/usr/share/doc/Linux-PAM-1.3.0 &&\nmake\n\ninstall -v -m755 -d /etc/pam.d &&\n\ncat > /etc/pam.d/other << \"EOF\"\nauth     required       pam_deny.so\naccount  required       pam_deny.so\npassword required       pam_deny.so\nsession  required       pam_deny.so\nEOF\n\nmake install &&\nchmod -v 4755 /sbin/unix_chkpwd &&\n\nfor file in pam pam_misc pamc\ndo\n  mv -v /usr/lib/lib${file}.so.* /lib &&\n  ln -sfv ../../lib/$(readlink /usr/lib/lib${file}.so) /usr/lib/lib${file}.so\ndone\n\n#配置linux-pam\n\ninstall -vdm755 /etc/pam.d\ncat > /etc/pam.d/system-account << \"EOF\" &&\n# Begin /etc/pam.d/system-account\n\naccount   required    pam_unix.so\n\n# End /etc/pam.d/system-account\nEOF\n\ncat > /etc/pam.d/system-auth << \"EOF\" &&\n# Begin /etc/pam.d/system-auth\n\nauth      required    pam_unix.so\n\n# End /etc/pam.d/system-auth\nEOF\n\ncat > /etc/pam.d/system-session << \"EOF\"\n# Begin /etc/pam.d/system-session\n\nsession   required    pam_unix.so\n\n# End /etc/pam.d/system-session\nEOF\n\ncat > /etc/pam.d/system-password << \"EOF\"\n# Begin /etc/pam.d/system-password\n\n# check new passwords for strength (man pam_cracklib)\npassword  required    pam_cracklib.so    authtok_type=UNIX retry=1 difok=5 \\\n                                         minlen=9 dcredit=1 ucredit=1 \\\n                                         lcredit=1 ocredit=1 minclass=0 \\\n                                         maxrepeat=0 maxsequence=0 \\\n                                         maxclassrepeat=0 \\\n                                         dictpath=/lib/cracklib/pw_dict\n# use sha512 hash for encryption, use shadow, and use the\n# authentication token (chosen password) set by pam_cracklib\n# above (or any previous modules)\npassword  required    pam_unix.so        sha512 shadow use_authtok\n\n# End /etc/pam.d/system-password\nEOF\n\n# Begin /etc/pam.d/other\n\nauth        required        pam_warn.so\nauth        required        pam_deny.so\naccount     required        pam_warn.so\naccount     required        pam_deny.so\npassword    required        pam_warn.so\npassword    required        pam_deny.so\nsession     required        pam_warn.so\nsession     required        pam_deny.so\n\n# End /etc/pam.d/other\n{% endcodeblock %}\n#### liboauth\n  + liboauth\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/l/liboauth-1.0.3.tar.gz\nwget http://www.linuxfromscratch.org/patches/blfs/8.4/liboauth-1.0.3-openssl-1.1.0-3.patch\ntar -zxvf liboauth-1.0.3.tar.gz\ncd liboauth-1.0.3\npatch -Np1 -i ../liboauth-1.0.3-openssl-1.1.0-3.patch\n./configure --prefix=/usr --disable-static &&\nmake\nmake install\ninstall -v -dm755 /usr/share/doc/liboauth-1.0.3 &&\ncp -rv doc/html/* /usr/share/doc/liboauth-1.0.3\n{% endcodeblock %}\n  + curl\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/c/curl-7.64.0.tar.xz\ntar xvf curl-7.64.0.tar.xz\ncd curl-7.64.0\n./configure --prefix=/usr                           \\\n            --disable-static                        \\\n            --enable-threaded-resolver              \\\n            --with-ca-path=/etc/ssl/certs &&\nmake\n\nmake install &&\n\nrm -rf docs/examples/.deps &&\n\nfind docs \\( -name Makefile\\* -o -name \\*.1 -o -name \\*.3 \\) -exec rm {} \\; &&\n\ninstall -v -d -m755 /usr/share/doc/curl-7.64.0 &&\ncp -v -R docs/*     /usr/share/doc/curl-7.64.0\n{% endcodeblock %}\n#### libpwquality\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/l/libpwquality-1.4.0.tar.bz2\ntar -jxvf libpwquality-1.4.0.tar.bz2\ncd libpwquality-1.4.0\n./configure --prefix=/usr --disable-static \\\n            --with-securedir=/lib/security \\\n            --with-python-binary=python3   &&\nmake\nmake install\n#配置libpwquality\nmv /etc/pam.d/system-password{,.orig} &&\ncat > /etc/pam.d/system-password << \"EOF\"\n# Begin /etc/pam.d/system-password\n\n# check new passwords for strength (man pam_pwquality)\npassword  required    pam_pwquality.so   authtok_type=UNIX retry=1 difok=1 \\\n                                         minlen=8 dcredit=0 ucredit=0 \\\n                                         lcredit=0 ocredit=0 minclass=1 \\\n                                         maxrepeat=0 maxsequence=0 \\\n                                         maxclassrepeat=0 geoscheck=0 \\\n                                         dictcheck=1 usercheck=1 \\\n                                         enforcing=1 badwords=\"\" \\\n                                         dictpath=/lib/cracklib/pw_dict\n# use sha512 hash for encryption, use shadow, and use the\n# authentication token (chosen password) set by pam_pwquality\n# above (or any previous modules)\npassword  required    pam_unix.so        sha512 shadow use_authtok\n\n# End /etc/pam.d/system-password\nEOF\n{% endcodeblock %}\n#### krb5\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/k/krb5-1.17.tar.gz\ntar -zxvf krb5-1.17.tar.gz\ncd krb5-1.17\n\ncd src &&\n\nsed -i -e 's@\\^u}@^u cols 300}@' tests/dejagnu/config/default.exp     &&\nsed -i -e '/eq 0/{N;s/12 //}'    plugins/kdb/db2/libdb2/test/run.test &&\n\n./configure --prefix=/usr            \\\n            --sysconfdir=/etc        \\\n            --localstatedir=/var/lib \\\n            --with-system-et         \\\n            --with-system-ss         \\\n            --with-system-verto=no   \\\n            --enable-dns-for-realm &&\nmake\nmake install &&\n\nfor f in gssapi_krb5 gssrpc k5crypto kadm5clnt kadm5srv \\\n         kdb5 kdb_ldap krad krb5 krb5support verto ; do\n\n    find /usr/lib -type f -name \"lib$f*.so*\" -exec chmod -v 755 {} \\;\ndone          &&\n\nmv -v /usr/lib/libkrb5.so.3*        /lib &&\nmv -v /usr/lib/libk5crypto.so.3*    /lib &&\nmv -v /usr/lib/libkrb5support.so.0* /lib &&\n\nln -v -sf ../../lib/libkrb5.so.3.3        /usr/lib/libkrb5.so        &&\nln -v -sf ../../lib/libk5crypto.so.3.1    /usr/lib/libk5crypto.so    &&\nln -v -sf ../../lib/libkrb5support.so.0.1 /usr/lib/libkrb5support.so &&\n\nmv -v /usr/bin/ksu /bin &&\nchmod -v 755 /bin/ksu   &&\n\ninstall -v -dm755 /usr/share/doc/krb5-1.17 &&\ncp -vfr ../doc/*  /usr/share/doc/krb5-1.17\n\n#配置\ncat > /etc/krb5.conf << \"EOF\"\n# Begin /etc/krb5.conf\n\n[libdefaults]\n    default_realm = <EXAMPLE.ORG>\n    encrypt = true\n\n[realms]\n    <EXAMPLE.ORG> = {\n        kdc = <belgarath.example.org>\n        admin_server = <belgarath.example.org>\n        dict_file = /usr/share/dict/words\n    }\n\n[domain_realm]\n    .<example.org> = <EXAMPLE.ORG>\n\n[logging]\n    kdc = SYSLOG:INFO:AUTH\n    admin_server = SYSLOG:INFO:AUTH\n    default = SYSLOG:DEBUG:DAEMON\n\n# End /etc/krb5.conf\nEOF\n#密码不能被忘记\nkdb5_util create -r <EXAMPLE.ORG> -s\nkadmin.local\nkadmin.local: add_policy dict-only\nkadmin.local: addprinc -policy dict-only <loginname>\nkadmin.local: addprinc -randkey host/<belgarath.example.org>\nkadmin.local: ktadd host/<belgarath.example.org>\n/usr/sbin/krb5kdc\nkinit <loginname>\nklist\nktutil\nktutil: rkt /etc/krb5.keytab\nktutil: l\n\n#配置启动脚本\ncd /sources/blfs-bootscripts-20180105/\nmake install-krb5\n{% endcodeblock %}\n#### nss\n  + nss\n{% codeblock lang:shell %}\nwget https://archive.mozilla.org/pub/security/nss/releases/NSS_3_42_1_RTM/src/nss-3.42.1.tar.gz\nwget http://www.linuxfromscratch.org/patches/blfs/8.4/nss-3.42.1-standalone-1.patch\ntar -zxvf nss-3.42.1.tar.gz\ncd nss-3.42.1\n\npatch -Np1 -i ../nss-3.42.1-standalone-1.patch &&\n\ncd nss &&\n\nmake -j1 BUILD_OPT=1                  \\\n  NSPR_INCLUDE_DIR=/usr/include/nspr  \\\n  USE_SYSTEM_ZLIB=1                   \\\n  ZLIB_LIBS=-lz                       \\\n  NSS_ENABLE_WERROR=0                 \\\n  $([ $(uname -m) = x86_64 ] && echo USE_64=1) \\\n  $([ -f /usr/include/sqlite3.h ] && echo NSS_USE_SYSTEM_SQLITE=1)\n\ncd ../dist                                                          &&\n\ninstall -v -m755 Linux*/lib/*.so              /usr/lib              &&\ninstall -v -m644 Linux*/lib/{*.chk,libcrmf.a} /usr/lib              &&\n\ninstall -v -m755 -d                           /usr/include/nss      &&\ncp -v -RL {public,private}/nss/*              /usr/include/nss      &&\nchmod -v 644                                  /usr/include/nss/*    &&\n\ninstall -v -m755 Linux*/bin/{certutil,nss-config,pk12util} /usr/bin &&\n\ninstall -v -m644 Linux*/lib/pkgconfig/nss.pc  /usr/lib/pkgconfig\n\n#配置nss\n{% endcodeblock %}\n  + nss依赖nspr\n{% codeblock lang:shell %}\nwget https://archive.mozilla.org/pub/nspr/releases/v4.20/src/nspr-4.20.tar.gz\ntar -zxvf nspr-4.20.tar.gz\ncd nspr-4.20\n\ncd nspr                                                     &&\nsed -ri 's#^(RELEASE_BINS =).*#\\1#' pr/src/misc/Makefile.in &&\nsed -i 's#$(LIBRARY) ##'            config/rules.mk         &&\n\n./configure --prefix=/usr \\\n            --with-mozilla \\\n            --with-pthreads \\\n            $([ $(uname -m) = x86_64 ] && echo --enable-64bit) &&\nmake\n\nmake install\n{% endcodeblock %}\n#### polkit\n  + polkit\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/p/polkit-0.115.tar.gz\nwget http://www.linuxfromscratch.org/patches/blfs/8.4/polkit-0.115-security_patch-3.patch\n\n{% endcodeblock %}\n  + polkit依赖js52\n{% codeblock lang:shell %}\n#zip\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/m/mozjs-60.1.0.tar.bz2\ntar -jxvf mozjs-60.1.0.tar.bz2\ncd mozjs-60.1.0\n{% endcodeblock %}\n  + js52依赖zip\n{% codeblock lang:shell %}\nwget https://downloads.sourceforge.net/infozip/zip30.tar.gz\ntar -zxvf zip30.tar.gz\ncd zip30\nmake -f unix/Makefile generic_gcc\nmake prefix=/usr MANDIR=/usr/share/man/man1 -f unix/Makefile install\n\n#icu\nwget http://download.icu-project.org/files/icu4c/63.1/icu4c-63_1-src.tgz\ntar -zxvf icu4c-63_1-src.tgz\ncd icu\n\ncd source                                    &&\n\n./configure --prefix=/usr                    &&\nmake\nmake install\n{% endcodeblock %}\n\n#### shadow\n  + 如果你安装了cracklib和linux-pam,需要重新安装\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/s/shadow-4.6.tar.xz\ntar -xvf shadow-4.6.tar.xz \ncd shadow-4.6\n\nsed -i 's/groups$(EXEEXT) //' src/Makefile.in &&\n\nfind man -name Makefile.in -exec sed -i 's/groups\\.1 / /'   {} \\; &&\nfind man -name Makefile.in -exec sed -i 's/getspnam\\.3 / /' {} \\; &&\nfind man -name Makefile.in -exec sed -i 's/passwd\\.5 / /'   {} \\; &&\n\nsed -i -e 's@#ENCRYPT_METHOD DES@ENCRYPT_METHOD SHA512@' \\\n       -e 's@/var/spool/mail@/var/mail@' etc/login.defs &&\n\nsed -i 's/1000/999/' etc/useradd                           &&\n\n./configure --sysconfdir=/etc --with-group-name-max-length=32 &&\nmake\n\nmake install &&\nmv -v /usr/bin/passwd /bin\n\n#配置\nsed -i 's/yes/no/' /etc/default/useradd\n\n#配置/etc/login.defs\ninstall -v -m644 /etc/login.defs /etc/login.defs.orig &&\nfor FUNCTION in FAIL_DELAY               \\\n                FAILLOG_ENAB             \\\n                LASTLOG_ENAB             \\\n                MAIL_CHECK_ENAB          \\\n                OBSCURE_CHECKS_ENAB      \\\n                PORTTIME_CHECKS_ENAB     \\\n                QUOTAS_ENAB              \\\n                CONSOLE MOTD_FILE        \\\n                FTMP_FILE NOLOGINS_FILE  \\\n                ENV_HZ PASS_MIN_LEN      \\\n                SU_WHEEL_ONLY            \\\n                CRACKLIB_DICTPATH        \\\n                PASS_CHANGE_TRIES        \\\n                PASS_ALWAYS_WARN         \\\n                CHFN_AUTH ENCRYPT_METHOD \\\n                ENVIRON_FILE\ndo\n    sed -i \"s/^${FUNCTION}/# &/\" /etc/login.defs\ndone\n\n#配置/etc/pam.d/ \ncat > /etc/pam.d/login << \"EOF\"\n# Begin /etc/pam.d/login\n\n# Set failure delay before next prompt to 3 seconds\nauth      optional    pam_faildelay.so  delay=3000000\n\n# Check to make sure that the user is allowed to login\nauth      requisite   pam_nologin.so\n\n# Check to make sure that root is allowed to login\n# Disabled by default. You will need to create /etc/securetty\n# file for this module to function. See man 5 securetty.\n#auth      required    pam_securetty.so\n\n# Additional group memberships - disabled by default\n#auth      optional    pam_group.so\n\n# include system auth settings\nauth      include     system-auth\n\n# check access for the user\naccount   required    pam_access.so\n\n# include system account settings\naccount   include     system-account\n\n# Set default environment variables for the user\nsession   required    pam_env.so\n\n# Set resource limits for the user\nsession   required    pam_limits.so\n\n# Display date of last login - Disabled by default\n#session   optional    pam_lastlog.so\n\n# Display the message of the day - Disabled by default\n#session   optional    pam_motd.so\n\n# Check user's mail - Disabled by default\n#session   optional    pam_mail.so      standard quiet\n\n# include system session and password settings\nsession   include     system-session\npassword  include     system-password\n\n# End /etc/pam.d/login\nEOF\n\n#配置passwd文件\ncat > /etc/pam.d/passwd << \"EOF\"\n# Begin /etc/pam.d/passwd\n\npassword  include     system-password\n\n# End /etc/pam.d/passwd\nEOF\n\n#配置su文件\ncat > /etc/pam.d/su << \"EOF\"\n# Begin /etc/pam.d/su\n\n# always allow root\nauth      sufficient  pam_rootok.so\n\n# Allow users in the wheel group to execute su without a password\n# disabled by default\n#auth      sufficient  pam_wheel.so trust use_uid\n\n# include system auth settings\nauth      include     system-auth\n\n# limit su to users in the wheel group\nauth      required    pam_wheel.so use_uid\n\n# include system account settings\naccount   include     system-account\n\n# Set default environment variables for the service user\nsession   required    pam_env.so\n\n# include system session settings\nsession   include     system-session\n\n# End /etc/pam.d/su\nEOF\n\n#配置change文件\ncat > /etc/pam.d/chage << \"EOF\"\n# Begin /etc/pam.d/chage\n\n# always allow root\nauth      sufficient  pam_rootok.so\n\n# include system auth, account, and session settings\nauth      include     system-auth\naccount   include     system-account\nsession   include     system-session\n\n# Always permit for authentication updates\npassword  required    pam_permit.so\n\n# End /etc/pam.d/chage\nEOF\n\n#其他程序\nfor PROGRAM in chfn chgpasswd chpasswd chsh groupadd groupdel \\\n               groupmems groupmod newusers useradd userdel usermod\ndo\n    install -v -m644 /etc/pam.d/chage /etc/pam.d/${PROGRAM}\n    sed -i \"s/chage/$PROGRAM/\" /etc/pam.d/${PROGRAM}\ndone\n\n#配置登录访问\n[ -f /etc/login.access ] && mv -v /etc/login.access{,.NOUSE}\n#配置资源限制\n[ -f /etc/limits ] && mv -v /etc/limits{,.NOUSE}\n{% endcodeblock %}\n#### stunnel\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/s/stunnel-5.50.tar.gz\ntar -zxvf stunnel-5.50.tar.gz \ncd stunnel-5.50\n\ngroupadd -g 51 stunnel &&\nuseradd -c \"stunnel Daemon\" -d /var/lib/stunnel \\\n        -g stunnel -s /bin/false -u 51 stunnel\n\n./configure --prefix=/usr        \\\n            --sysconfdir=/etc    \\\n            --localstatedir=/var \\\n            --disable-systemd    &&\nmake\nmake docdir=/usr/share/doc/stunnel-5.50 install\ninstall -v -m750 -o stunnel -g stunnel -d /var/lib/stunnel/run &&\nchown stunnel:stunnel /var/lib/stunnel\n\ncat >/etc/stunnel/stunnel.conf << \"EOF\"\n; File: /etc/stunnel/stunnel.conf\n\n; Note: The pid and output locations are relative to the chroot location.\n\npid    = /run/stunnel.pid\nchroot = /var/lib/stunnel\nclient = no\nsetuid = stunnel\nsetgid = stunnel\ncert   = /etc/stunnel/stunnel.pem\n\n;debug = 7\n;output = stunnel.log\n\n;[https]\n;accept  = 443\n;connect = 80\n;; \"TIMEOUTclose = 0\" is a workaround for a design flaw in Microsoft SSL\n;; Microsoft implementations do not use SSL close-notify alert and thus\n;; they are vulnerable to truncation attacks\n;TIMEOUTclose = 0\n\nEOF\n\n#配置开机启动\ncd /sources/blfs-bootscripts-20180105/\nmake install-stunnel\n{% endcodeblock %}\n\n#### sudo\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/s/sudo-1.8.27.tar.gz \ntar -zxvf sudo-1.8.27.tar.gz\ncd sudo-1.8.27\n./configure --prefix=/usr              \\\n            --libexecdir=/usr/lib      \\\n            --with-secure-path         \\\n            --with-all-insults         \\\n            --with-env-editor          \\\n            --docdir=/usr/share/doc/sudo-1.8.27 \\\n            --with-passprompt=\"[sudo] password for %p: \" &&\nmake\nmake install &&\nln -sfv libsudo_util.so.0.0.0 /usr/lib/sudo/libsudo_util.so.0\n\n#配置sudo\ncat > /etc/sudoers.d/sudo << \"EOF\"\nDefaults secure_path=\"/usr/bin:/bin:/usr/sbin:/sbin\"\n%wheel ALL=(ALL) ALL\nEOF\n\ncat > /etc/pam.d/sudo << \"EOF\"\n# Begin /etc/pam.d/sudo\n\n# include the default auth settings\nauth      include     system-auth\n\n# include the default account settings\naccount   include     system-account\n\n# Set default environment variables for the service user\nsession   required    pam_env.so\n\n# include system session defaults\nsession   include     system-session\n\n# End /etc/pam.d/sudo\nEOF\nchmod 644 /etc/pam.d/sudo\n{% endcodeblock %}\n#### tripwire\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/t/tripwire-open-source-2.4.3.7.tar.gz\ntar -zxvf tripwire-open-source-2.4.3.7.tar.gz\ncd tripwire-open-source-2.4.3.7\n\nsed -e '/^CLOBBER/s/false/true/'         \\\n    -e 's|TWDB=\"${prefix}|TWDB=\"/var|'   \\\n    -e '/TWMAN/ s|${prefix}|/usr/share|' \\\n    -e '/TWDOCS/s|${prefix}/doc/tripwire|/usr/share/doc/tripwire-2.4.3.7|' \\\n    -i installer/install.cfg                               &&\n\nfind . -name Makefile.am | xargs                           \\\n    sed -i 's/^[[:alpha:]_]*_HEADERS.*=/noinst_HEADERS =/' &&\n\nsed '/dist/d' -i man/man?/Makefile.am                      &&\nautoreconf -fi                                             &&\n\n./configure --prefix=/usr --sysconfdir=/etc/tripwire       &&\nmake\n\ntwadmin --create-polfile --site-keyfile /etc/tripwire/site.key \\\n    /etc/tripwire/twpol.txt &&\ntripwire --init\n{% endcodeblock %}\n\n#### volume_key\n  + volume_key\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/v/volume_key-0.3.12.tar.gz\ntar -zxvf volume_key-0.3.12.tar.gz\ncd volume_key-volume_key-0.3.12/\nautoreconf -fiv              &&\n./configure --prefix=/usr    \\\n            --without-python &&\nmake\n\n{% endcodeblock %}\n  + volume_key依赖cryptsetup\n{% codeblock lang:shell %}\nsudo wget http://ftp.lfs-matrix.net/pub/blfs/8.4/c/cryptsetup-2.0.6.tar.xz\ntar -xvf cryptsetup-2.0.6.tar.xz\ncd cryptsetup-2.0.6\n./configure --prefix=/usr \\\n            --with-crypto_backend=openssl &&\nmake\n\nmake install\n{% endcodeblock %}\n  + cryptsetup的依赖json-c\n{% codeblock lang:shell %}\nwget http://ftp.lfs-matrix.net/pub/blfs/8.4/j/json-c-0.13.1.tar.gz\n tar -zxvf json-c-0.13.1.tar.gz\ncd json-c-0.13.1\n\n./configure --prefix=/usr --disable-static &&\nmake\nmake install\n{% endcodeblock %}\n{% codeblock lang:shell %}\n{% endcodeblock %}\n{% codeblock lang:shell %}\n{% endcodeblock %}\n{% codeblock lang:shell %}\n{% endcodeblock %}\n"},{"title":"BLFS构建02-LFS配置之后的问题","url":"%2F2019%2F06%2F11%2FBLFS%2FBLFS%E6%9E%84%E5%BB%BA02-LFS%E9%85%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E7%9A%84%E9%97%AE%E9%A2%98%2F","content":"\n### BLFS构建02-LFS配置之后的问题\n\n#### 终端字体\n  + 如果你没有安装字体\n{% codeblock lang:shell %}\nsetfont /path/to/yourfont.ext\n{% endcodeblock %}\n  + 如果已经有了字体\n{% codeblock lang:shell %}\nsetfont /path/to/yourfont.ext\n{% endcodeblock %}\n  + 测试字体\n{% codeblock lang:shell %}\nshowconsolefont\n{% endcodeblock %}\n<!--more-->\n#### 关于固件\n#### 关于设备\n  + 多声卡设置\n{% codeblock lang:shell %}\n# /boot/grub/grub.cfg\nsnd-fm801.index=0 snd-ens1371.index=1\n\n# /etc/modprobe.conf\noptions snd-fm801 index=0\noptions snd-ens1371 index=1\n{% endcodeblock %}\n  + usb设备\n{% codeblock lang:shell %}\n# /etc/fstab\nusbfs  /proc/bus/usb  usbfs  devgid=14,devmode=0660  0  0\n{% endcodeblock %}\n#### 增加用户的配置\n##### skel文件(框架目录)\n    + 简介\n      skel是skeleton的缩写意为骨骼、框架。\n    + 作用\n      用于初始化新用户的根目录，系统将此目录下的文件都复制到新建用户的目录下，并且将用户属主与用户组调整为与新建用户根目录相同\n\n#### bash启动文件\n  + /etc/profile文件\n{% codeblock lang:shell %}\n# Begin /etc/profile\n# Written for Beyond Linux From Scratch\n# by James Robertson <jameswrobertson@earthlink.net>\n# modifications by Dagmar d'Surreal <rivyqntzne@pbzpnfg.arg>\n\n# System wide environment variables and startup programs.\n\n# System wide aliases and functions should go in /etc/bashrc.  Personal\n# environment variables and startup programs should go into\n# ~/.bash_profile.  Personal aliases and functions should go into\n# ~/.bashrc.\n\n# Functions to help us manage paths.  Second argument is the name of the\n# path variable to be modified (default: PATH)\npathremove () {\n        local IFS=':'\n        local NEWPATH\n        local DIR\n        local PATHVARIABLE=${2:-PATH}\n        for DIR in ${!PATHVARIABLE} ; do\n                if [ \"$DIR\" != \"$1\" ] ; then\n                  NEWPATH=${NEWPATH:+$NEWPATH:}$DIR\n                fi\n        done\n        export $PATHVARIABLE=\"$NEWPATH\"\n}\n\npathprepend () {\n        pathremove $1 $2\n        local PATHVARIABLE=${2:-PATH}\n        export $PATHVARIABLE=\"$1${!PATHVARIABLE:+:${!PATHVARIABLE}}\"\n}\n\npathappend () {\n        pathremove $1 $2\n        local PATHVARIABLE=${2:-PATH}\n        export $PATHVARIABLE=\"${!PATHVARIABLE:+${!PATHVARIABLE}:}$1\"\n}\n\nexport -f pathremove pathprepend pathappend\n\n# Set the initial path\nexport PATH=/bin:/usr/bin\n\nif [ $EUID -eq 0 ] ; then\n        pathappend /sbin:/usr/sbin\n        unset HISTFILE\nfi\n\n# Setup some environment variables.\nexport HISTSIZE=1000\nexport HISTIGNORE=\"&:[bf]g:exit\"\n\n# Set some defaults for graphical systems\nexport XDG_DATA_DIRS=${XDG_DATA_DIRS:-/usr/share/}a\nexport XDG_CONFIG_DIRS=${XDG_CONFIG_DIRS:-/etc/xdg/}\nexport XDG_RUNTIME_DIR=${XDG_RUNTIME_DIR:-/tmp/xdg-$USER}\n\n# Setup a red prompt for root and a green one for users.\nNORMAL=\"\\[\\e[0m\\]\"\nRED=\"\\[\\e[1;31m\\]\"\nGREEN=\"\\[\\e[1;32m\\]\"\nif [[ $EUID == 0 ]] ; then\n  PS1=\"$RED\\u [ $NORMAL\\w$RED ]# $NORMAL\"\nelse\n  PS1=\"$GREEN\\u [ $NORMAL\\w$GREEN ]\\$ $NORMAL\"\nfi\n\nfor script in /etc/profile.d/*.sh ; do\n        if [ -r $script ] ; then\n                . $script\n        fi\ndone\n\nunset script RED GREEN NORMAL\n\n# End /etc/profile\n{% endcodeblock %}\n\n  + 创建profile.d目录(存放bash配置文件)\n{% codeblock lang:shell %}\ninstall --directory --mode=0755 --owner=root --group=root /etc/profile.d\n{% endcodeblock %}\n  + 创建/etc/profile.d/bash_completion.sh脚本(用于bash补全)\n{% codeblock lang:shell %}\ncat > /etc/profile.d/bash_completion.sh << \"EOF\"\n# Begin /etc/profile.d/bash_completion.sh\n# Import bash completion scripts\n\n# If the bash-completion package is installed, use its configuration instead\nif [ -f /usr/share/bash-completion/bash_completion ]; then\n\n  # Check for interactive bash and that we haven't already been sourced.\n  if [ -n \"${BASH_VERSION-}\" -a -n \"${PS1-}\" -a -z \"${BASH_COMPLETION_VERSINFO-}\" ]; then\n\n    # Check for recent enough version of bash.\n    if [ ${BASH_VERSINFO[0]} -gt 4 ] || \\\n       [ ${BASH_VERSINFO[0]} -eq 4 -a ${BASH_VERSINFO[1]} -ge 1 ]; then\n       [ -r \"${XDG_CONFIG_HOME:-$HOME/.config}/bash_completion\" ] && \\\n            . \"${XDG_CONFIG_HOME:-$HOME/.config}/bash_completion\"\n       if shopt -q progcomp && [ -r /usr/share/bash-completion/bash_completion ]; then\n          # Source completion code.\n          . /usr/share/bash-completion/bash_completion\n       fi\n    fi\n  fi\n\nelse\n\n  # bash-completions are not installed, use only bash completion directory\n  if shopt -q progcomp; then\n    for script in /etc/bash_completion.d/* ; do\n      if [ -r $script ] ; then\n        . $script\n      fi\n    done\n  fi\nfi\n\n# End /etc/profile.d/bash_completion.sh\nEOF\n{% endcodeblock %}\n  +_创建/etc/bash_completion.d目录(bash补全的详细配置)\n{% codeblock lang:shell %}\ninstall --directory --mode=0755 --owner=root --group=root /etc/bash_completion.d\n{% endcodeblock %}\n  + /etc/profile.d/dircolors.sh(目录颜色配置)\n{% codeblock lang:shell %}\ncat > /etc/profile.d/dircolors.sh << \"EOF\"\n# Setup for /bin/ls and /bin/grep to support color, the alias is in /etc/bashrc.\nif [ -f \"/etc/dircolors\" ] ; then\n        eval $(dircolors -b /etc/dircolors)\nfi\n\nif [ -f \"$HOME/.dircolors\" ] ; then\n        eval $(dircolors -b $HOME/.dircolors)\nfi\n\nalias ls='ls --color=auto'\nalias grep='grep --color=auto'\nEOF\n{% endcodeblock %}\n  + /etc/profile.d/extrapaths.sh(增加有用的路径到PATH中)\n{% codeblock lang:shell %}\ncat > /etc/profile.d/extrapaths.sh << \"EOF\"\nif [ -d /usr/local/lib/pkgconfig ] ; then\n        pathappend /usr/local/lib/pkgconfig PKG_CONFIG_PATH\nfi\nif [ -d /usr/local/bin ]; then\n        pathprepend /usr/local/bin\nfi\nif [ -d /usr/local/sbin -a $EUID -eq 0 ]; then\n        pathprepend /usr/local/sbin\nfi\n\n# Set some defaults before other applications add to these paths.\npathappend /usr/share/man  MANPATH\npathappend /usr/share/info INFOPATH\nEOF\n{% endcodeblock %}\n  + /etc/profile.d/readline.sh(设置默认的.inputrc配置文件)\n{% codeblock lang:shell %}\ncat > /etc/profile.d/readline.sh << \"EOF\"\n# Setup the INPUTRC environment variable.\nif [ -z \"$INPUTRC\" -a ! -f \"$HOME/.inputrc\" ] ; then\n        INPUTRC=/etc/inputrc\nfi\nexport INPUTRC\nEOF\n{% endcodeblock %}\n  + /etc/profile.d/umask.sh(设置umask)\n{% codeblock lang:shell %}\ncat > /etc/profile.d/umask.sh << \"EOF\"\n# By default, the umask should be set.\nif [ \"$(id -gn)\" = \"$(id -un)\" -a $EUID -gt 99 ] ; then\n  umask 002\nelse\n  umask 022\nfi\nEOF\n{% endcodeblock %}\n  + /etc/profile.d/i18n.sh(设置语言支持)\n{% codeblock lang:shell %}\ncat > /etc/profile.d/i18n.sh << \"EOF\"\n# Set up i18n variables\nexport LANG=zh_CN.UTF-8\nEOF\n{% endcodeblock %}\n\n  + /etc/bashrc(bash的配置文件)\n{% codeblock lang:shell %}\ncat > /etc/bashrc << \"EOF\"\n# Begin /etc/bashrc\n# Written for Beyond Linux From Scratch\n# by James Robertson <jameswrobertson@earthlink.net>\n# updated by Bruce Dubbs <bdubbs@linuxfromscratch.org>\n\n# System wide aliases and functions.\n\n# System wide environment variables and startup programs should go into\n# /etc/profile.  Personal environment variables and startup programs\n# should go into ~/.bash_profile.  Personal aliases and functions should\n# go into ~/.bashrc\n\n# Provides colored /bin/ls and /bin/grep commands.  Used in conjunction\n# with code in /etc/profile.\n\nalias ls='ls --color=auto'\nalias grep='grep --color=auto'\n\n# Provides prompt for non-login shells, specifically shells started\n# in the X environment. [Review the LFS archive thread titled\n# PS1 Environment Variable for a great case study behind this script\n# addendum.]\n\nNORMAL=\"\\[\\e[0m\\]\"\nRED=\"\\[\\e[1;31m\\]\"\nGREEN=\"\\[\\e[1;32m\\]\"\nif [[ $EUID == 0 ]] ; then\n  PS1=\"$RED\\u [ $NORMAL\\w$RED ]# $NORMAL\"\nelse\n  PS1=\"$GREEN\\u [ $NORMAL\\w$GREEN ]\\$ $NORMAL\"\nfi\n\nunset RED GREEN NORMAL\n\n# End /etc/bashrc\nEOF\n{% endcodeblock %}\n  + ~/.bash_profile()\n{% codeblock lang:shell %}\ncat > ~/.bash_profile << \"EOF\"\n# Begin ~/.bash_profile\n# Written for Beyond Linux From Scratch\n# by James Robertson <jameswrobertson@earthlink.net>\n# updated by Bruce Dubbs <bdubbs@linuxfromscratch.org>\n\n# Personal environment variables and startup programs.\n\n# Personal aliases and functions should go in ~/.bashrc.  System wide\n# environment variables and startup programs are in /etc/profile.\n# System wide aliases and functions are in /etc/bashrc.\n\nif [ -f \"$HOME/.bashrc\" ] ; then\n  source $HOME/.bashrc\nfi\n\nif [ -d \"$HOME/bin\" ] ; then\n  pathprepend $HOME/bin\nfi\n\n# Having . in the PATH is dangerous\n#if [ $EUID -gt 99 ]; then\n#  pathappend .\n#fi\n\n# End ~/.bash_profile\nEOF\n\n\n#将配置复制到skel目录中，使其能在创建新用户时默认生成到新用户主目录中\ncp ~/.bash_profile /etc/skel\n{% endcodeblock %}\n\n  + ~/.profile(私有环境变量配置文件，只在登入的时候执行一次)\n{% codeblock lang:shell %}\ncat > ~/.profile << \"EOF\"\n# Begin ~/.profile\n# Personal environment variables and startup programs.\n\nif [ -d \"$HOME/bin\" ] ; then\n  pathprepend $HOME/bin\nfi\n\n# Set up user specific i18n variables\n#export LANG=<ll>_<CC>.<charmap><@modifiers>\n\n# End ~/.profile\nEOF\n{% endcodeblock %}\n  + ~/.bashrc（用户专用bash配置文件）\n{% codeblock lang:shell %}\ncat > ~/.bashrc << \"EOF\"\n# Begin ~/.bashrc\n# Written for Beyond Linux From Scratch\n# by James Robertson <jameswrobertson@earthlink.net>\n\n# Personal aliases and functions.\n\n# Personal environment variables and startup programs should go in\n# ~/.bash_profile.  System wide environment variables and startup\n# programs are in /etc/profile.  System wide aliases and functions are\n# in /etc/bashrc.\n\nif [ -f \"/etc/bashrc\" ] ; then\n  source /etc/bashrc\nfi\n\n# Set up user specific i18n variables\n#export LANG=<ll>_<CC>.<charmap><@modifiers>\n\n# End ~/.bashrc\nEOF\n{% endcodeblock %}\n  + ~/.bash_logout(bash注销)\n{% codeblock lang:shell %}\ncat > ~/.bash_logout << \"EOF\"\n# Begin ~/.bash_logout\n# Written for Beyond Linux From Scratch\n# by James Robertson <jameswrobertson@earthlink.net>\n\n# Personal items to perform on logout.\n\n# End ~/.bash_logout\nEOF\n{% endcodeblock %}\n  + /etc/dircolors(设置ls指令显示目录或文件时用的色彩)\n{% codeblock lang:shell %}\ndircolors -p > /etc/dircolors\n{% endcodeblock %}\n\n#### vim的配置文件\n  + .vimrc\n{% codeblock lang:shell %}\ncat > /etc/skel/.vimrc << \"EOF\"\n\" Begin .vimrc\n\nset columns=80\nset wrapmargin=8\nset ruler\n\n\" End .vimrc\n{% endcodeblock %}\n#### 自定义登录提示语\n{% codeblock lang:shell %}\ncat > /etc/issue << \"EOF\"\nb   Insert the baudrate of the current line.\nd   Insert the current date.\ns   Insert the system name, the name of the operating system.\nl   Insert the name of the current tty line.\nm   Insert the architecture identifier of the machine, e.g., i686.\nn   Insert the nodename of the machine, also known as the hostname.\no   Insert the domainname of the machine.\nr   Insert the release number of the kernel, e.g., 2.6.11.12.\nt   Insert the current time.\nu   Insert the number of current users logged in.\nU   Insert the string \"1 user\" or \"<n> users\" where <n> is the\n    number of current users logged in.\nv   Insert the version of the OS, e.g., the build-date etc.\nEOF\n{% endcodeblock %}\n#### 随机数生成器\n{% codeblock lang:shell %}\n#将脚本复制到系统启动脚本中\ncp -r  blfs-bootscripts-20180105/blfs/init.d/random /etc/rc.d/init.d/\nmake install-random #进行安装\n{% endcodeblock %}\n\n#### lsb_release-1.4\n  + 介绍\n    这个脚本显示的是linux发行版的标准基础状态信息\n  + 下载安装\n{% codeblock lang:shell %}\nwget https://downloads.sourceforge.net/lsb/lsb-release-1.4.tar.gz\ntar -zxvf lsb-release-1.4.tar.gz\ncd lsb-release-1.4\nsed -i \"s|n/a|unavailable|\" lsb_release\n./help2man -N --include ./lsb_release.examples --alt_version_key=program_version ./lsb_release > lsb_release.1\ninstall -v -m 644 lsb_release.1 /usr/share/man/man1 \ninstall -v -m 755 lsb_release   /usr/bin\n{% endcodeblock %}\n","tags":["BLFS构建"],"categories":["BLFS构建"]},{"title":"BLFS构建01-配置前的准备","url":"%2F2019%2F06%2F10%2FBLFS%2FBLFS%E6%9E%84%E5%BB%BA01-%E9%85%8D%E7%BD%AE%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%2F","content":"\n### BLFS构建01-配置前的准备\n\n#### 移除la文件\n> .la文件是使用libtool库管理工具生成的文件\n{% codeblock lang:shell %}\ncat > /usr/sbin/remove-la-files.sh << \"EOF\"\n#!/bin/bash\n\n# /usr/sbin/remove-la-files.sh\n# Written for Beyond Linux From Scratch\n# by Bruce Dubbs <bdubbs@linuxfromscratch.org>\n\n# Make sure we are running with root privs\nif test \"${EUID}\" -ne 0; then\n    echo \"Error: $(basename ${0}) must be run as the root user! Exiting...\"\n    exit 1\nfi\n\n# Make sure PKG_CONFIG_PATH is set if discarded by sudo\nsource /etc/profile\n\nOLD_LA_DIR=/var/local/la-files\n\nmkdir -p $OLD_LA_DIR\n\n# Only search directories in /opt, but not symlinks to directories\nOPTDIRS=$(find /opt -mindepth 1 -maxdepth 1 -type d)\n\n# Move any found .la files to a directory out of the way\nfind /usr/lib $OPTDIRS -name \"*.la\" ! -path \"/usr/lib/ImageMagick*\" \\\n  -exec mv -fv {} $OLD_LA_DIR \\;\n###############\n\n# Fix any .pc files that may have .la references\n\nSTD_PC_PATH='/usr/lib/pkgconfig\n             /usr/share/pkgconfig\n             /usr/local/lib/pkgconfig\n             /usr/local/share/pkgconfig'\n\n# For each directory that can have .pc files\nfor d in $(echo $PKG_CONFIG_PATH | tr : ' ') $STD_PC_PATH; do\n\n  # For each pc file\n  for pc in $d/*.pc ; do\n    if [ $pc == \"$d/*.pc\" ]; then continue; fi\n\n    # Check each word in a line with a .la reference\n    for word in $(grep '\\.la' $pc); do\n      if $(echo $word | grep -q '.la$' ); then\n        mkdir -p $d/la-backup\n        cp -fv  $pc $d/la-backup\n\n        basename=$(basename $word )\n        libref=$(echo $basename|sed -e 's/^lib/-l/' -e 's/\\.la$//')\n\n        # Fix the .pc file\n        sed -i \"s:$word:$libref:\" $pc\n      fi\n    done\n  done\ndone\n\nEOF\n\nchmod +x /usr/sbin/remove-la-files.sh\n{% endcodeblock %}\n","tags":["BLFS构建"],"categories":["BLFS构建"]},{"title":"BLFS资料搜集","url":"%2F2019%2F06%2F08%2FBLFS%2FBLFS%E8%B5%84%E6%96%99%E6%90%9C%E9%9B%86%2F","content":"\n### BLFS资料搜集\n\n[什么是blfs(官方版)](http://www.linuxfromscratch.org/blfs/blfs)\n[blfs安装wget](https://www.cnblogs.com/renren-study-notes/p/10205232.html)\n[blfs制作kde](https://blog.csdn.net/easygooo/article/details/20291319)\n[blfs安装openssh](https://blog.csdn.net/whoami021/article/details/18773421)\n[blfs安装备忘录](http://blog.chinaunix.net/uid-11187579-id-2896959.html)\n[blfs安装](https://wallcopper.wordpress.com/2009/07/24/blfs-%E5%AE%89%E8%A3%85/)\n[blfs8.4官方源软件包](http://ftp.osuosl.org/pub/blfs/8.4/)\n[blfs8.4官方手册](http://www.linuxfromscratch.org/blfs/view/stable/index.html)\n","tags":["BLFS定制发行版"],"categories":["BLFS定制发行版"]},{"title":"LFS系统构建06-定制LFS镜像","url":"%2F2019%2F06%2F07%2FLFS%2FLFS%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA06-%E5%AE%9A%E5%88%B6LFS%E9%95%9C%E5%83%8F%2F","content":"\n### LFS系统构建06-定制LFS镜像\n\n#### 打包lfs目录\n\n{% codeblock lang:shell %}\nexport LFS=/mnt/lfs \n#将根目录打包，用来制作系统分区\ncd $LFS\ntar jcvpf ~/lfs-6.3.tar.bz2 ./* --exclude boot # 如果命令不识别，就分开来，一个个的打包\n#将boot目录打包，用来制作boot分区\ncd $LFS/boot\ntar jcvpf ~/boot.tar.bz2 ./*\n{% endcodeblock %}\n<!-- more -->\n#### 制作livecd\n  + 配置基本环境\n{% codeblock lang:shell %}\nexport ISO=~/iso\nmkdir $ISO\nmkdir -pv $ISO/boot/grub\n{% endcodeblock %}\n  + 配置stage2_eltorito，下载[stage2_elltorito](/download/LFS/stage2_eltorito)\n{% codeblock lang:shell %}\nmv stage2_eltorito $LFS/boot/grub/\n{% endcodeblock %}\n  + 配置initrd， 下载[initramfs](/download/LFS/initramfs.gz)\n{% codeblock lang:shell %}\n#下载initramfs.gz(我这里是用的gentoo的initrd启动辅助系统)\ncp -rv initramfs.gz $ISO/boot/\n{% endcodeblock %}\n  + 将你的基本系统中的boot目录中的内核复制过来\n{% codeblock lang:shell %}\ncp $LFS/boot/vmlinuz-4.20.12-lfs-8.4 $ISO/boot/\n{% endcodeblock %}\n  + 创建grub的引导配置文件\n{% codeblock lang:shell %}\ndefault 0\ntimeout 30\ncolor white/black black/light-gray\ntitle Install rack-leen liveCD\nroot (cd)\nkernel /boot/vmlinuz-4.20.12-lfs-8.4  # 你的引导内核的位置\ninitrd /boot/initramfs.gz  # 你的辅助系统的位置\n{% endcodeblock %}\n  + 创建安装脚本\n{% codeblock lang:shell %}\n#===============================================================================\n#\n#          FILE: install.sh\n#\n#         USAGE: ./install.sh\n#\n#   DESCRIPTION: \n#\n#       OPTIONS: ---\n#  REQUIREMENTS: ---\n#          BUGS: ---\n#         NOTES: ---\n#        AUTHOR: rack-leen\n#  ORGANIZATION: \n#       CREATED: 2019年06月07日 18时19分09秒\n#      REVISION:  ---\n#===============================================================================\necho \"start install ...\"\n#find the disk 找到存在的磁盘\nDISK=`find /dev -type b | grep '.*[shv]d[a-d][0-9]' | sed -e 's/.$//' | head -1`\necho \"Your DISK is $DISK\"\nDISK_PRE=`echo $DISK | sed -e 's/.$//'`\n#set the partition  设置分区\necho \"Input Your SWAP Partition for a number:\"\nread SWAP_NUM   # swap分区号\nDISK_SWAP=${DISK}${SWAP_NUM}\necho \"Input Your BOOT Partition for a number:\"\nread BOOT_NUM  # boot分区号\nDISK_BOOT=${DISK}${BOOT_NUM}\necho \"Input Your ROOT Partition for a number:\"\nread ROOT_NUM  # /分区号\nDISK_ROOT=${DISK}${ROOT_NUM}\n#init swap partition 初始化swap分区\nmkswap $DISK_SWAP\n\n#swapon \n$DISK_SWAP \n#init root partition 初始化根分区\nmkfs.ext4 $DISK_ROOT \nmount $DISK_ROOT /mnt/lfs # 挂载根分区\ncd /mnt/lfs\ntar jxvpf /install/lfs-8.4.tar.bz2 #将根分区文件解压到根分区\ncp ${DISK_PRE}* /mnt/lfs/dev/ -R #将dev目录下的设备全部复制到dev目录\necho \"install ROOT finished\"\n\n#init boot partition 初始化boot分区\nmkfs -t ext2 $DISK_BOOT \nmount $DISK_BOOT /mnt/boot \ncd /mnt/boot\ntar jxvpf /install/boot.tar.bz2\necho \"install BOOT finished\"\n\n#init fstab \necho \"${DISK_ROOT} / ext3 defaults 1 1\">/mnt/lfs/etc/fstab \necho \"${DISK_SWAP} swap swap pri=1 0 0\">>/mnt/lfs/etc/fstab \necho \"${DISK_BOOT} /boot ext3 defaults 0 0\">>/mnt/lfs/etc/fstab \necho \"proc /proc proc defaults 0 0\">>/mnt/lfs/etc/fstab \necho \"sysfs /sys sysfs defaults 0 0\">>/mnt/lfs/etc/fstab \necho \"devpts /dev/pts devpts gid=4,mode=620 0 0\">>/mnt/lfs/etc/fstab\necho \"shm /dev/shm tmpfs defaults 0 0\">>/mnt/lfs/etc/fstab \n\n#init grub grub.cfg\nif [ $BOOT_NUM =1 ] ; then \n  GRUB_BOOT=0 \nelse \n  GRUB_BOOT=`expr $BOOT_NUM - 1` \nfi\n\n# 将grub配置写入配置文件中\necho \"\n  default 0\n  timeout 30\n  color white/black black/light-gray\n  title rack-leen OS 1.0\n  root (hd0,$GRUB_BOOT)\n        kernel  /boot/vmlinuz-4.20.12-lfs-8.4 root=${DISK_ROOT} vga=788\n\" >> /mnt/boot/grub/grub.cfg\n\n# check ip address\ncheck_ip() {\n  echo $1 | grep \"^\\(\\(25[0-5]\\|2[0-4][0-9]\\|1[0-9]\\{2\\}\\|[1-9][0-9]\\|[0-9]\\)\\.\\)\\{3\\}\\(25[0-5]\\|2[0-4][0-9]\\|1[0-9]\\{2\\}\\|[1-9][0-9]\\|[0-9]\\)$\" > /dev/null\n  if [ $? -ne 0 ]; then\n    return 1\n  fi\n\n  ipaddr=$1\n  a=$(echo $ipaddr | awk -F'.' '{print $1}')\n  b=$(echo $ipaddr | awk -F'.' '{print $2}')\n  c=$(echo $ipaddr | awk -F'.' '{print $3}')\n  d=$(echo $ipaddr | awk -F'.' '{print $4}')\n\n  for n in $a $b $c $d; do\n    if [ $n -gt 255 ] || [ $n -lt 0 ]; then\n      return 2\n    fi\n  done\n\n  return 0\n}\n\n# init ip address\nNETCARD=$(cat /proc/net/dev | grep \"eth\" | sed -e \"s/^\\s*\\(eth.*\\)\\:.*$/\\1/\")\n\nfor NET in $NETCARD; do\n  IP=; read -p \"Input IP address for $NET: \" IP\n  check_ip $IP\n  while [ $? -ne 0 ]; do\n    read -p \"Invalid input. ReInput IP address for $NET: \" IP\n    check_ip $IP\n  done\n\n  GATEWAY=; read -p \"Input GATEWAY address for $NET: \" GATEWAY\n  check_ip $GATEWAY\n  while [ $? -ne 0 ]; do\n    read -p \"Invalid input. ReInput GATEWAY address for $NET: \" GATEWAY\n    check_ip $GATEWAY\n  done\n\n  BROADCAST=$(echo \"$GATEWAY\" | sed -e \"s/^\\([0-9]\\{1,3\\}\\.[0-9]*\\.[0-9]*\\)\\.[0-9]*$/\\1.255/\")\n\n  echo \\\n\"ONBOOT=yes\nIFACE=$NET\nSERVICE=ipv4-static\nIP=$IP\nGATEWAY=$GATEWAY\nPREFIX=24\nBROADCAST=$BROADCAST\n\" > /mnt/lfs/etc/sysconfig/ifconfig.$NET\n\n  mkdir -p /mnt/lfs/etc/sysconfig/network-scripts\n  ln -s ../ifconfig.$NET /mnt/lfs/etc/sysconfig/network-scripts/ifcfg-$NET\n\n  echo \"Init $NET ip finished\"\ndone\n\n\n#reset MAC address \nrm -f /mnt/lfs/etc/udev/rules.d/70-persistent-net.rules\n\n#chroot and MBR \ncd /\numount /mnt/boot \nmount $DISK_BOOT /mnt/lfs/boot \nchroot /mnt/lfs /bin/bash -c \"echo -e 'root (hd0,$GRUB_BOOT)\\nsetup (hd0)\\nquit' | /usr/sbin/grub\"\n\necho \"******************************************************************\"\necho \"******************** install finish now reboot *******************\"\necho \"******************************************************************\"\nchroot /mnt/lfs/ /bin/bash -c \"reboot\"\n{% endcodeblock %}\n  + 创建install目录，用来存放打包的系统包(根分区包和boot分区包)和安装脚本\n{% codeblock lang:shell %}\ncd $ISO\nmkdir -pv $ISO/install\ncp boot.tar.bz2 ./install\ncp lfs-8.4.tar.bz2 ./install\ncp install.sh ./install\n{% endcodeblock %}\n  + 创建镜像文件\n{% codeblock lang:shell %}\ncd $ISO\nmkisofs -R -b boot/grub/stage2_eltorito -no-emul-boot -boot-load-size 4 -boot-info-table  -o liveCD-lfs-8.4.iso /home/rackleen/iso\n{% endcodeblock %}\n  + 最终的目录结构\n{% codeblock lang:shell %}\n├── boot\n│   ├── grub\n│   │   ├── menu.lst\n│   │   └── stage2_eltorito\n│   ├── initramfs.gz\n│   └── vmlinuz-4.20.12-lfs-8.4\n├── install\n│   ├── boot.tar.bz2\n│   ├── install.sh\n│   └── lfs-8.4.tar.bz2\n└── liveCD-lfs-8.4.iso\n{% endcodeblock %}\n  + 效果图\n![grub](grub.png)\n","tags":["LFS系统构建"],"categories":["LFS系统构建"]},{"title":"LFS系统构建05-制作LFS系统引导","url":"%2F2019%2F06%2F07%2FLFS%2FLFS%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA05-%E5%88%B6%E4%BD%9CLFS%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%2F","content":"\n### LFS系统构建05-制作LFS系统引导\n\n#### 创建fstab文件\n{% codeblock lang:shell %}\n# Begin /etc/fstab\n# file  system  mount-point     type            options         dump    fsck\n#                                                                       order\n/dev/sdb        /               ext4            defaults                1 1\n/dev/sda4       swap            swap            pri=                    1 0\nproc            /proc           proc            nosuid,noexec,nodev     0 0\nsysfs           /sys            sysfs           nosuid,noexec,nodev     0 0\ndevpts          /dev/pts        devpts          gid=5,mode=620          0 0\ntmpfs           /run            tmpfs           defaults                0 0\ndevtmpfs        /dev            devtmpfs        mode=0755,nosuid        0 0\n# End /etc/fstab\n{% endcodeblock %}\n<!-- more -->\n#### linux内核\n{% codeblock lang:shell %}\n#安装内核\ncd $LFS/sources/\ntar xvf linux-4.20.12.tar.xz\nmake mrproper\n#启用x86默认内核配置\nmake x86_64_defconfig\n#在以上基础上自定义配置\nmake menuconfig\nmake\nmake modules_install\ncp -iv arch/x86_64/boot/bzImage /boot/vmlinuz-4.20.12-lfs-8.4\ncp -iv System.map /boot/System.map-4.20.12\ncp -iv .config /boot/config-4.20.12\ninstall -d /usr/share/doc/linux-4.20.12\ncp -r Documentation/* /usr/share/doc/linux-4.20.12\n\n#配置模块加载顺序\ninstall -v -m755 -d /etc/modprobe.d\n\ncat > /etc/modprobe.d/usb.conf << \"EOF\"\n# Begin /etc/modprobe.d/usb.conf\n\n\ninstall ohci_hcd /sbin/modprobe ehci_hcd ; /sbin/modprobe -i ohci_hcd ; true\ninstall uhci_hcd /sbin/modprobe ehci_hcd ; /sbin/modprobe -i uhci_hcd ; true\n\n# End /etc/modprobe.d/usb.conf\n\nEOF\n{% endcodeblock %}\n\n#### 用grub设置引导进程\n{% codeblock lang:shell %}\ncd /tmp\ngrub-mkrescue --output=grub-img.iso\n#需要安装xorriso\nwget https://mirrors.ustc.edu.cn/gnu/xorriso/xorriso-1.3.0.tar.gz \ntar -zxvf xorriso-1.3.0.tar.gz\ncd xorriso-1.3.0\n./configure --prefix=/usr\nmake\nmake install \nxorriso -as cdrecord -v dev=/dev/cdrw blank=as_needed grub-img.iso\n\n#将配置文件写入(如果没有目录则自己创建)\ncat > /boot/grub/grub.cfg << \"EOF\"\n# Begin /boot/grub/grub.cfg\n\nset default=0\nset timeout=5\ninsmod ext2\nset root=(hd0,2)\nmenuentry \"GNU/Linux, Linux 4.20.12-lfs-8.4\" {\nlinux\n/boot/vmlinuz-4.20.12-lfs-8.4 root=/dev/sda2 ro\n}\nEOF\n{% endcodeblock %}\n\n#### 结束\n{% codeblock lang:shell %}\n\necho \"rack-leen-1.0-version\" > /etc/rack-leen-release\ncat > /etc/lsb-release << \"EOF\"\nDISTRIB_ID=\"rack-leen\"\nDISTRIB_RELEASE=\"1.0\"\nDISTRIB_CODENAME=\"rack\"\nDISTRIB_DESCRIPTION=\"Rack's Linux\"\nEOF\n{% endcodeblock %}\n","tags":["LFS系统构建"],"categories":["LFS系统构建"]},{"title":"LFS系统构建04-系统配置","url":"%2F2019%2F06%2F07%2FLFS%2FLFS%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA04-%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%2F","content":"\n### LFS系统构建04-系统配置\n\n#### 引导linux的步骤\n  1. 挂载虚拟文件系统和真实文件系统\n  2. 初始化设备\n  3. 激活交换分区\n  4. 检查文件系统\n  5. 挂载交换分区或文件\n  6. 设置系统时钟\n  7. 启动网络\n  8. 开启系统需要的守护进程\n  9. 一些用户需要的自定义工作\n\n<!-- more -->\n#### lfs-bootscripts\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -jxvf lfs-bootscripts-20180820.tar.bz2\ncd lfs-bootscripts-20180820\nmake install\n{% endcodeblock %}\n\n#### 创建自定义udev规则\n{% codeblock lang:shell %}\nbash /lib/udev/init-net-rules.sh\ncat /etc/udev/rules.d/70-persistent-net.rules\nudevadm test /sys/block/hdd\nsed -i -e 's/\"write_cd_rules\"/\"write_cd_rules mode\"/' /etc/udev/rules.d/83-cdrom-symlinks.rules\n\n#处理多个设备\nudevadm info -a -p /sys/class/video4linux/video0\n\ncat > /etc/udev/rules.d/83-duplicate_devs.rules << \"EOF\"\n# Persistent symlinks for webcam and tuner\nKERNEL==\"video*\", ATTRS{idProduct}==\"1910\", ATTRS{idVendor}==\"0d81\", \\\nSYMLINK+=\"webcam\"\nKERNEL==\"video*\", ATTRS{device}==\"0x036f\", ATTRS{vendor}==\"0x109e\", \\\nSYMLINK+=\"tvtuner\"\nEOF\ncd $LFS/sources\n{% endcodeblock %}\n\n#### 网络配置\n{% codeblock lang:shell %}\ncd /etc/sysconfig/\n\ncat > ifconfig.eth0 << \"EOF\"\nONBOOT=yes\nIFACE=eth0\nSERVICE=ipv4-static\nIP=192.168.1.2\nGATEWAY=192.168.1.1\nPREFIX=24\nBROADCAST=192.168.1.255\nEOF\n\n\ncat > /etc/resolv.conf << \"EOF\"\n# Begin /etc/resolv.conf\ndomain <Your Domain Name>\nnameserver <IP address of your primary nameserver>\nnameserver <IP address of your secondary nameserver>\n# End /etc/resolv.conf\nEOF\n\n#设置主机名\necho \"rack-leen\" > /etc/hostname\n\n#\ncat > /etc/hosts << \"EOF\"\n# Begin /etc/hosts\n127.0.0.1 localhost\n# End /etc/hosts\nEOF\n{% endcodeblock %}\n\n#### 引导脚本的配置和使用\n{% codeblock lang:shell %}\ncat > /etc/inittab << \"EOF\"\n# Begin /etc/inittab\n\n\nid:3:initdefault:\n\nsi::sysinit:/etc/rc.d/init.d/rc S\n\nl0:0:wait:/etc/rc.d/init.d/rc 0\nl1:S1:wait:/etc/rc.d/init.d/rc 1\nl2:2:wait:/etc/rc.d/init.d/rc 2\nl3:3:wait:/etc/rc.d/init.d/rc 3\nl4:4:wait:/etc/rc.d/init.d/rc 4\nl5:5:wait:/etc/rc.d/init.d/rc 5\nl6:6:wait:/etc/rc.d/init.d/rc 6\n\nca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now\n\nsu:S016:once:/sbin/sulogin\n\n1:2345:respawn:/sbin/agetty --noclear tty1 9600\n2:2345:respawn:/sbin/agetty tty2 9600\n3:2345:respawn:/sbin/agetty tty3 9600\n4:2345:respawn:/sbin/agetty tty4 9600\n5:2345:respawn:/sbin/agetty tty5 9600\n6:2345:respawn:/sbin/agetty tty6 9600\n# End /etc/inittab\n\nEOF\n\n#设置系统时间\ncat > /etc/sysconfig/clock << \"EOF\"\n# Begin /etc/sysconfig/clock\n\n\nUTC=1\n\n# Set this to any options you might need to give to hwclock,\n\n# such as machine hardware clock type for Alphas.\n\nCLOCKPARAMS=\n\n# End /etc/sysconfig/clock\n\nEOF\n\n#配置终端\ncat > /etc/sysconfig/console << \"EOF\"\n# Begin /etc/sysconfig/console\nUNICODE=\"1\"\nKEYMAP=\"bg_bds-utf8\"\nFONT=\"LatArCyrHeb-16\"\n# End /etc/sysconfig/console\nEOF\n{% endcodeblock %}\n\n#### bash的启动文件\n{% codeblock lang:shell %}\n#设置字符集\nLC_ALL=en_US.utf-8 locale charmap\n\n\n#### bash的配置文件\ncat > /etc/profile << \"EOF\"\n# Begin /etc/profile\nexport LANG=<ll>_<CC>.<charmap><@modifiers>\n# End /etc/profile\nEOF\n{% endcodeblock %}\n\n#### 创建inputrc文件\n{% codeblock lang:shell %}\ncat > /etc/inputrc << \"EOF\"\n# Begin /etc/inputrc\n# Modified by Chris Lynn <roryo@roryo.dynup.net>\n# Allow the command prompt to wrap to the next line\nset horizontal-scroll-mode Off\n# Enable 8bit input\nset meta-flag On\nset input-meta On\n# Turns off 8th bit stripping\nset convert-meta Off\n# Keep the 8th bit for display\nset output-meta On\n# none, visible or audible\nset bell-style none\n# All of the following map the escape sequence of the value\n# contained in the 1st argument to the readline specific functions\n\"\\eOd\": backward-word\n\"\\eOc\": forward-word\n# for linux console\n\"\\e[1~\": beginning-of-line\n\"\\e[4~\": end-of-line\n\"\\e[5~\": beginning-of-history\n\"\\e[6~\": end-of-history\n\"\\e[3~\": delete-char\n\"\\e[2~\": quoted-insert\n# for xterm\n\"\\eOH\": beginning-of-line\n\"\\eOF\": end-of-line\n# for Konsole\n\"\\e[H\": beginning-of-line\n\"\\e[F\": end-of-line\n# End /etc/inputrc\nEOF\n{% endcodeblock %}\n\n#### 创建shells文件\n{% codeblock lang:shell %}\ncat > /etc/shells << \"EOF\"\n# Begin /etc/shells\n/bin/sh\n/bin/bash\n# End /etc/shells\nEOF\n{% endcodeblock %}\n","tags":["LFS系统构建"],"categories":["LFS系统构建"]},{"title":"LFS系统构建03-安装基础系统软件","url":"%2F2019%2F06%2F04%2FLFS%2FLFS%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA03-%E5%AE%89%E8%A3%85%E5%9F%BA%E7%A1%80%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%2F","content":"\n### LFS系统构建03-安装基础系统软件\n\n#### 准备虚拟内核文件系统\n{% codeblock lang:shell %}\nmkdir -pv $LFS/{dev,proc,sys,run}\n#创建初始化设备节点\nmknod -m 600 $LFS/dev/console c 5 1\nmknod -m 666 $LFS/dev/null c 1 3\n\n#挂载/dev\nmount -v --bind /dev $LFS/dev\n#挂载虚拟文件系统\nmount -vt devpts devpts $LFS/dev/pts -o gid=5,mode=620\nmount -vt proc proc $LFS/proc\nmount -vt sysfs sysfs $LFS/sys\nmount -vt tmpfs tmpfs $LFS/run\n\nif [ -h $LFS/dev/shm ]; then\nmkdir -pv $LFS/$(readlink $LFS/dev/shm)\nfi\n{% endcodeblock %}\n\n<!-- more -->\n#### 开始进入构建的lfs环境\n{% codeblock lang:shell %}\nchroot \"$LFS\" /tools/bin/env -i \\\nHOME=/root\n\\\nTERM=\"$TERM\"\n\\\nPS1='(lfs chroot) \\u:\\w\\$ ' \\\nPATH=/bin:/usr/bin:/sbin:/usr/sbin:/tools/bin \\\n/tools/bin/bash --login +h\n{% endcodeblock %}\n\n#### 创建主要目录\n{% codeblock lang:shell %}\nmkdir -pv /{bin,boot,etc/{opt,sysconfig},home,lib/firmware,mnt,opt}\nmkdir -pv /{media/{floppy,cdrom},sbin,srv,var}\ninstall -dv -m 0750 /root\ninstall -dv -m 1777 /tmp /var/tmp\nmkdir -pv /usr/{,local/}{bin,include,lib,sbin,src}\nmkdir -pv /usr/{,local/}share/{color,dict,doc,info,locale,man}\nmkdir -v /usr/{,local/}share/{misc,terminfo,zoneinfo}\nmkdir -v /usr/libexec\nmkdir -pv /usr/{,local/}share/man/man{1..8}\ncase $(uname -m) in\nx86_64) mkdir -v /lib64 ;;\nesac\nmkdir -v /var/{log,mail,spool}\nln -sv /run /var/run\nln -sv /run/lock /var/lock\nmkdir -pv /var/{opt,cache,lib/{color,misc,locate},local}\n{% endcodeblock %}\n\n#### 创建重要文件和符号连接\n{% codeblock lang:shell %}\nln -sv /tools/bin/{bash,cat,chmod,dd,echo,ln,mkdir,pwd,rm,stty,touch} /bin\nln -sv /tools/bin/{env,install,perl,printf} /usr/bin\nln -sv /tools/lib/libgcc_s.so{,.1} /usr/lib\nln -sv /tools/lib/libstdc++.{a,so{,.6}} /usr/lib\ninstall -vdm755 /usr/lib/pkgconfig\nln -sv bash /bin/sh\nln -sv /proc/self/mounts /etc/mtab\n\n\ncat > /etc/passwd << \"EOF\"\nroot:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/dev/null:/bin/false\ndaemon:x:6:6:Daemon User:/dev/null:/bin/false\nmessagebus:x:18:18:D-Bus Message Daemon User:/var/run/dbus:/bin/false\nnobody:x:99:99:Unprivileged User:/dev/null:/bin/false\nEOF\n\n\ncat > /etc/group << \"EOF\"\nroot:x:0:\nbin:x:1:daemon\nsys:x:2:\nkmem:x:3:\ntape:x:4:\ntty:x:5:\ndaemon:x:6:\nfloppy:x:7:\ndisk:x:8:\nlp:x:9:\ndialout:x:10:\naudio:x:11:\nvideo:x:12:\nutmp:x:13:\nusb:x:14:\ncdrom:x:15:\nadm:x:16:\nmessagebus:x:18:\ninput:x:24:\nmail:x:34:\nkvm:x:61:\nwheel:x:97:\nnogroup:x:99:\nusers:x:999:\nEOF\n\nexec /tools/bin/bash --login +h\n\ntouch /var/log/{btmp,lastlog,faillog,wtmp}\nchgrp -v utmp /var/log/lastlog\nchmod -v 664 /var/log/lastlog\nchmod -v 600 /var/log/btmp\n{% endcodeblock %}\n\n#### linux api 头文件\n{% codeblock lang:shell %}\ncd $LFS/sources/\ntar xvf linux-4.20.12.tar.xz\ncd linux-4.20.12\nmake mrproper\n\nmake INSTALL_HDR_PATH=dest headers_install\nfind dest/include \\( -name .install -o -name ..install.cmd \\) -delete\ncp -rv dest/include/* /usr/include\n{% endcodeblock %}\n#### man-pages\n{% codeblock lang:shell %}\ntar xvf man-pages-4.16.tar.xz\ncd man-pages-4.16\nmake install\n{% endcodeblock %}\n#### glibc\n{% codeblock lang:shell %}\ncd $LFS/sources/\ncd glibc-2.29\npatch -Np1 -i ../glibc-2.29-fhs-1.patch\nln -sfv /tools/lib/gcc /usr/lib\n\ncase $(uname -m) in\ni?86)\nGCC_INCDIR=/usr/lib/gcc/$(uname -m)-pc-linux-gnu/8.2.0/include\nln -sfv ld-linux.so.2 /lib/ld-lsb.so.3\n;;\nx86_64) GCC_INCDIR=/usr/lib/gcc/x86_64-pc-linux-gnu/8.2.0/include\nln -sfv ../lib/ld-linux-x86-64.so.2 /lib64\nln -sfv ../lib/ld-linux-x86-64.so.2 /lib64/ld-lsb-x86-64.so.3\n;;\nesac\n\nrm -f /usr/include/limits.h\nmkdir -v build\ncd build\n\n{% endcodeblock %}\n#### gawk\n{% codeblock lang:shell %}\ntar xvf gawk-4.2.1.tar.xz\ncd gawk-4.2.1\nsed -i 's/extras//' Makefile.in\nunset GCC_INCDIR\n\ncase $(uname -m) in\ni?86)\nln -sfnv $PWD/elf/ld-linux.so.2\n/lib ;;\nx86_64) ln -sfnv $PWD/elf/ld-linux-x86-64.so.2 /lib ;;\nesac\n\ntouch /etc/ld.so.conf\nsed '/test-installation/s@$(PERL)@echo not running@' -i ../Makefile\n\ncp -v ../nscd/nscd.conf /etc/nscd.conf\nmkdir -pv /var/cache/nscd\n\n#配置语言环境\nmkdir -pv /usr/lib/locale\nlocaledef -i POSIX -f UTF-8 C.UTF-8 2> /dev/null || true\nlocaledef -i en_US -f ISO-8859-1 en_US\nlocaledef -i en_US -f UTF-8 en_US.UTF-8\nlocaledef -i zh_CN -f GB18030 zh_CN.GB18030\nlocaledef -i zh_CN -f UTF-8 zh_CN.UTF-8\nmake localedata/install-locales\n\n#增加 nsswitch.conf\ncat > /etc/nsswitch.conf << \"EOF\"\n# Begin /etc/nsswitch.conf\npasswd: files\ngroup: files\nshadow: files\nhosts: files dns\nnetworks: files\nprotocols: files\nservices: files\nethers: files\nrpc: files\n# End /etc/nsswitch.conf\nEOF\n\n#增加时区数据\ntar -zxvf ../../tzdata2018i.tar.gz\nZONEINFO=/usr/share/zoneinfo\nmkdir -pv $ZONEINFO/{posix,right}\n\nfor tz in etcetera southamerica northamerica europe africa antarctica asia australasia backward pacificnew systemv; do zic -L /dev/null -d $ZONEINFO ${tz} ; zic -L /dev/null -d $ZONEINFO/posix ${tz} ; zic -L leapseconds -d $ZONEINFO/right ${tz} ; done\ncp -v zone.tab zone1970.tab iso3166.tab $ZONEINFO\nzic -d $ZONEINFO -p Asia/ShangHai\n#用命令更改时区\ntzselect\ncp -v /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\nunset ZONEINFO\n\n#配置动态加载\n\ncat > /etc/ld.so.conf << \"EOF\"\n# Begin /etc/ld.so.conf\n/usr/local/lib\n/opt/lib\nEOF\n\ncat >> /etc/ld.so.conf << \"EOF\"\n# Add an include directory\ninclude /etc/ld.so.conf.d/*.conf\nEOF\nmkdir -pv /etc/ld.so.conf.d\n{% endcodeblock %}\n\n#### 适应工具链\n{% codeblock lang:shell %}\nmv -v /tools/bin/{ld,ld-old}\nrenamed '/tools/bin/ld' -> '/tools/bin/ld-old'\n\nmv -v /tools/$(uname -m)-pc-linux-gnu/bin/{ld,ld-old}\nrenamed '/tools/x86_64-pc-linux-gnu/bin/ld' -> '/tools/x86_64-pc-linux-gnu/bin/ld-old'\n\nmv -v /tools/bin/{ld-new,ld}\nrenamed '/tools/bin/ld-new' -> '/tools/bin/ld'\n\nln -sv /tools/bin/ld /tools/$(uname -m)-pc-linux-gnu/bin/ld\n'/tools/x86_64-pc-linux-gnu/bin/ld' -> '/tools/bin/ld'\n\ngcc -dumpspecs | sed -e 's@/tools@@g' -e '/\\*startfile_prefix_spec:/{n;s@.*@/usr/lib/ @}' -e '/\\*cpp:/{n;s@$@ -isystem /usr/include@}' > `dirname $(gcc --print-libgcc-file-name)`/specs\n\n#测试工具链\necho 'int main(){}' > dummy.c\ncc dummy.c -v -Wl,--verbose &> dummy.log\nreadelf -l a.out | grep ': /lib'\n#测试成功\n[Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]\n\n#确保我们设置用正确的开启文件\ngrep -o '/usr/lib.*/crt[1in].*succeeded' dummy.log\n#出现以下三行表示测试成功\n/usr/lib/../lib/crt1.o succeeded\n/usr/lib/../lib/crti.o succeeded\n/usr/lib/../lib/crtn.o succeeded\n\n#验证编译搜索的头文件是否正确\ngrep -B1 '^ /usr/include' dummy.log\n#测试成功\n#include <...> search starts here:\n /usr/include\n\n#验证库的搜索路径\n grep 'SEARCH.*/usr/lib' dummy.log |sed 's|; |\\n|g'\n SEARCH_DIR(\"=/tools/x86_64-pc-linux-gnu/lib64\")\nSEARCH_DIR(\"/usr/lib\")\nSEARCH_DIR(\"/lib\")\nSEARCH_DIR(\"=/tools/x86_64-pc-linux-gnu/lib\");\n\n#确保我们用的是正确的libc\ngrep \"/lib.*/libc.so.6 \" dummy.log\nattempt to open /lib/libc.so.6 succeeded\n\n#确保gcc用的是正确的动态链接库\ngrep found dummy.log\nfound ld-linux-x86-64.so.2 at /lib/ld-linux-x86-64.so.2\n\n#测试成功后删除\nrm -v dummy.c a.out dummy.log\n{% endcodeblock %}\n\n#### zlib\n{% codeblock lang:shell %}\ntar xvf zlib-1.2.11.tar.xz\ncd zlib-1.2.11\n./configure --prefix=/usr\nmake\nmake check\nmake install\n\nmv -v /usr/lib/libz.so.* /lib\nln -sfv ../../lib/$(readlink /usr/lib/libz.so) /usr/lib/libz.so\n{% endcodeblock %}\n\n#### file\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf file-5.36.tar.gz\ncd file-5.36\n./configure --prefix=/usr\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### readline\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf readline-8.0.tar.gz\ncd readline-8.0\n\nsed -i '/MV.*old/d' Makefile.in\nsed -i '/{OLDSUFF}/c:' support/shlib-install\n\n./configure --prefix=/usr --disable-static --docdir=/usr/share/doc/readline-8.0\nmake SHLIB_LIBS=\"-L/tools/lib -lncursesw\"\nmake SHLIB_LIBS=\"-L/tools/lib -lncursesw\" install\n\nmv -v /usr/lib/lib{readline,history}.so.* /lib\nchmod -v u+w /lib/lib{readline,history}.so.*\nln -sfv ../../lib/$(readlink /usr/lib/libreadline.so) /usr/lib/libreadline.so\nln -sfv ../../lib/$(readlink /usr/lib/libhistory.so ) /usr/lib/libhistory.so\ninstall -v -m644 doc/*.{ps,pdf,html,dvi} /usr/share/doc/readline-8.0\n{% endcodeblock %}\n\n#### m4\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf m4-1.4.18.tar.xz\ncd m4-1.4.18\n\nsed -i 's/IO_ftrylockfile/IO_EOF_SEEN/' lib/*.c\necho \"#define _IO_IN_BACKUP 0x100\" >> lib/stdio-impl.h\n\n./configure --prefix=/usr\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### bc\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf bc-1.07.1.tar.gz \ncd bc-1.07.1\n\ncat > bc/fix-libmath_h << \"EOF\"\n#! /bin/bash\nsed -e '1\ns/^/{\"/' \\\n-e\n's/$/\",/' \\\n-e '2,$ s/^/\"/' \\\n-e\n'$ d'\n\\\n-i libmath.h\nsed -e '$ s/$/0}/' \\\n-i libmath.h\nEOF\n\nln -sv /tools/lib/libncursesw.so.6 /usr/lib/libncursesw.so.6\nln -sfv libncursesw.so.6 /usr/lib/libncurses.so\nsed -i -e '/flex/s/as_fn_error/: ;; # &/' configure\n\n./configure --prefix=/usr --with-readline --mandir=/usr/share/man --infodir=/usr/share/info\nmake\n#如果出现makeinfo: command not found\n提前编译安装texinfo,使其提供makeinfo就能解决\n\necho \"quit\" | ./bc/bc -l Test/checklib.b\nmake install\n{% endcodeblock %}\n\n#### texinfo\n{% codeblock lang:shell %}\nsed -i '5481,5485 s/({/(\\\\{/' tp/Texinfo/Parser.pm\n./configure --prefix=/usr --disable-static\nmake\nmake check\nmake TEXMF=/usr/share/texmf install-tex\n{% endcodeblock %}\n\n#### binutils\n{% codeblock lang:shell %}\ntar xvf binutils-2.32.tar.xz \ncd binutils-2.32\nexpect -c \"spawn ls\"\nmkdir -v build\ncd build/\n\n../configure --prefix=/usr --enable-gold --enable-ld=default --enable-plugins --enable-shared --disable-werror --enable-64-bit-bfd --with-system-zlib\nmake tooldir=/usr\nmake -k check\nmake tooldir=/usr install\n{% endcodeblock %}\n\n#### gmp\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf gmp-6.1.2.tar.xz\ncd gmp-6.1.2\n\n#如果你是32位的机子，但是运行64位的cpu,就需要使用这句\nABI=32 ./configure ...\n\ncp -v configfsf.guess config.guess\ncp -v configfsf.sub　config.sub\n./configure --prefix=/usr --enable-cxx --disable-static --docdir=/usr/share/doc/gmp-6.1.2\nmake\nmake html\nmake check 2>&1 | tee gmp-check-log\nawk '/# PASS:/{total+=$3} ; END{print total}' gmp-check-log\nmake install\nmake install-html\n{% endcodeblock %}\n#### mpfr\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf mpfr-4.0.2.tar.xz \n./configure --prefix=/usr --disable-static --enable-thread-safe --docdir=/usr/share/doc/mpfr-4.0.2\nmake\nmake html\nmake check\nmake install\nmake install-html\n{% endcodeblock %}\n\n#### mpc\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf mpc-1.1.0.tar.gz\ncd mpc-1.1.0\n./configure --prefix=/usr --disable-static --docdir=/usr/share/doc/mpc-1.1.0\nmake\nmake html\nmake check\nmake install\nmake install-html\n{% endcodeblock %}\n\n#### shadow\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf shadow-4.6.tar.xz\ncd shadow-4.6\nsed -i 's/groups$(EXEEXT) //' src/Makefile.in\nfind man -name Makefile.in -exec sed -i 's/groups\\.1 / /' {} \\;\nfind man -name Makefile.in -exec sed -i 's/getspnam\\.3 / /' {} \\;\nfind man -name Makefile.in -exec sed -i 's/passwd\\.5 / /' {} \\;\n\n#用更安全的sha-512来加密\nsed -i -e 's@#ENCRYPT_METHOD DES@ENCRYPT_METHOD SHA512@' \\\n-e 's@/var/spool/mail@/var/mail@' etc/login.defs\nsed -i 's/1000/999/' etc/useradd\n#加上Cracklib支持\nsed -i 's@DICTPATH.*@DICTPATH\\t/lib/cracklib/pw_dict@' etc/login.defs\n./configure --sysconfdir=/etc --with-group-name-max-length=32\nmake\nmake install\nmv -v /usr/bin/passwd /bin\n\n#配置shadow\npwconv #将密码shadow\ngrpconv #将组密码shadow\n\npasswd root\n{% endcodeblock %}\n\n#### gcc(第三次安装)\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf gcc-8.2.0.tar.xz\ncd gcc-8.2.0\n\ncase $(uname -m) in\nx86_64)\nsed -e '/m64=/s/lib64/lib/' \\\n-i.orig gcc/config/i386/t-linux64\n;;\nesac\n\n#移除之前安装的gcc\nrm -f /usr/lib/gcc\nmkdir -v build\ncd build/\n\n../configure --prefix=/usr --enable-languages=c,c++ --disable-multilib --disable-bootstrap --disable-libmpx --with-system-zlib\nmake\nulimit -s 32768\nrm ../gcc/testsuite/g++.dg/pr83239.C\nchown -Rv nobody .\nsu nobody -s /bin/bash -c \"PATH=$PATH make -k check\"\n../contrib/test_summary\nmake install\nln -sv ../usr/bin/cpp /lib\nln -sv gcc /usr/bin/cc\n\ninstall -v -dm755 /usr/lib/bfd-plugins\nln -sfv ../../libexec/gcc/$(gcc -dumpmachine)/8.2.0/liblto_plugin.so /usr/lib/bfd-plugins/\n\n#测试gcc\necho 'int main(){}' > dummy.c\ncc dummy.c -v -Wl,--verbose &> dummy.log\nreadelf -l a.out | grep ': /lib'\n#测试结果 ok\n[Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]\n\n#确保开启文件正确 ok\ngrep -o '/usr/lib.*/crt[1in].*succeeded' dummy.log\n/usr/lib/gcc/x86_64-pc-linux-gnu/8.2.0/../../../../lib/crt1.o succeeded\n/usr/lib/gcc/x86_64-pc-linux-gnu/8.2.0/../../../../lib/crti.o succeeded\n/usr/lib/gcc/x86_64-pc-linux-gnu/8.2.0/../../../../lib/crtn.o succeeded\n\n\n#验证编译时搜索的头文件 ok\ngrep -B4 '^ /usr/include' dummy.log\n#include <...> search starts here:\n /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.0/include\n /usr/local/include\n /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.0/include-fixed\n /usr/include\n\n#验证新链接器的搜索路径 ok\ngrep 'SEARCH.*/usr/lib'dummy.log |sed 's|; |\\n|g'\nSEARCH_DIR(\"/usr/x86_64-pc-linux-gnu/lib64\")\nSEARCH_DIR(\"/usr/local/lib64\")\nSEARCH_DIR(\"/lib64\")\nSEARCH_DIR(\"/usr/lib64\")\nSEARCH_DIR(\"/usr/x86_64-pc-linux-gnu/lib\")\nSEARCH_DIR(\"/usr/local/lib\")\nSEARCH_DIR(\"/lib\")\nSEARCH_DIR(\"/usr/lib\");\n\n#确保用的是正确的libc ok\ngrep \"/lib.*/libc.so.6 \" dummy.log\nattempt to open /lib/libc.so.6 succeeded\n\n#确保用的是正确的动态链接库\ngrep found dummy.log\nfound ld-linux-x86-64.so.2 at /lib/ld-linux-x86-64.so.2\n\n#删除测试文件\nrm -v dummy.c a.out dummy.log\n\n\nmkdir -pv /usr/share/gdb/auto-load/usr/lib\nmv -v /usr/lib/*gdb.py /usr/share/gdb/auto-load/usr/lib\n{% endcodeblock %}\n\n#### bzip\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf bzip2-1.0.6.tar.gz\ncd bzip2-1.0.6\npatch -Np1 -i ../bzip2-1.0.6-install_docs-1.patch\nsed -i 's@\\(ln -s -f \\)$(PREFIX)/bin/@\\1@' Makefile\nsed -i \"s@(PREFIX)/man@(PREFIX)/share/man@g\" Makefile\nmake -f Makefile-libbz2_so\nmake clean\nmake\nmake PREFIX=/usr install\n\n\ncp -v bzip2-shared /bin/bzip2\ncp -av libbz2.so* /lib\nln -sv ../../lib/libbz2.so.1.0 /usr/lib/libbz2.so\nrm -v /usr/bin/{bunzip2,bzcat,bzip2}\nln -sv bzip2 /bin/bunzip2\nln -sv bzip2 /bin/bzcat\n{% endcodeblock %}\n\n#### pkg-config\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf pkg-config-0.29.2.tar.gz \ncd pkg-config-0.29.2\n./configure --prefix=/usr --with-internal-glib --disable-host-tool --docdir=/usr/share/doc/pkg-config-0.29.2\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### ncurses\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf ncurses-6.1.tar.gz\ncd ncurses-6.1\nsed -i '/LIBTOOL_INSTALL/d' c++/Makefile.in\n\n./configure --prefix=/usr --mandir=/usr/share/man --with-shared --without-debug --without-normal --enable-pc-files --enable-widec\nmake\nmake install\nmv -v /usr/lib/libncursesw.so.6* /lib\nln -sfv ../../lib/$(readlink /usr/lib/libncursesw.so) /usr/lib/libncursesw.so\n\nfor lib in ncurses form panel menu ; do rm -vf /usr/lib/lib${lib}.so; echo \"INPUT(-l${lib}w)\" > /usr/lib/lib${lib}.so; ln -sfv ${lib}w.pc /usr/lib/pkgconfig/${lib}.pc; done\n\nrm -vf /usr/lib/libcursesw.so\necho \"INPUT(-lncursesw)\" > /usr/lib/libcursesw.so\nln -sfv libncurses.so /usr/lib/libcurses.so\n\nmkdir -v /usr/share/doc/ncurses-6.1\ncp -v -R doc/* /usr/share/doc/ncurses-6.1\n{% endcodeblock %}\n\n#### attr\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf attr-2.4.48.tar.gz \ncd attr-2.4.48\n./configure --prefix=/usr --bindir=/bin --disable-static --sysconfdir=/etc --docdir=/usr/share/doc/attr-2.4.48\nmake\nmake check\nmake install\nmv -v /usr/lib/libattr.so.* /lib\nln -sfv ../../lib/$(readlink /usr/lib/libattr.so) /usr/lib/libattr.so\n{% endcodeblock %}\n\n#### acl\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf acl-2.2.53.tar.gz\ncd acl-2.2.53\n./configure --prefix=/usr --bindir=/bin --disable-static --libexecdir=/usr/lib --docdir=/usr/share/doc/acl-2.2.53\nmake\nmake install\nmv -v /usr/lib/libacl.so.* /lib\nln -sfv ../../lib/$(readlink /usr/lib/libacl.so) /usr/lib/libacl.so\n{% endcodeblock %}\n\n### libcap\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf libcap-2.26.tar.xz\ncd libcap-2.26\nsed -i '/install.*STALIBNAME/d' libcap/Makefile\nmake\nmake RAISE_SETFCAP=no lib=lib prefix=/usr install\nchmod -v 755 /usr/lib/libcap.so.2.26\n\nmv -v /usr/lib/libcap.so.* /lib\nln -sfv ../../lib/$(readlink /usr/lib/libcap.so) /usr/lib/libcap.so\n{% endcodeblock %}\n\n#### sed\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf sed-4.7.tar.xz\ncd sed-4.7\nsed -i 's/usr/tools/' build-aux/help2man\nsed -i 's/testsuite.panic-tests.sh//' Makefile.in\n\n./configure --prefix=/usr --bindir=/bin\nmake\nmake html\nmake check\nmake install\n\ninstall -d -m755 /usr/share/doc/sed-4.7\ninstall -m644 doc/sed.html /usr/share/doc/sed-4.7\n{% endcodeblock %}\n\n#### psmisc\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf psmisc-23.2.tar.xz\ncd psmisc-23.2\n./configure --prefix=/usr\nmake\nmake install\nmv -v /usr/bin/fuser /bin\nmv -v /usr/bin/killall /bin\n{% endcodeblock %}\n\n#### lana-etc\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -jxvf iana-etc-2.30.tar.bz2\ncd iana-etc-2.30\nmake\nmake install\n{% endcodeblock %}\n\n#### bison\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf bison-3.3.2.tar.xz\ncd bison-3.3.2\n./configure --prefix=/usr --docdir=/usr/share/doc/bison-3.3.2\nmake\nmake install\n{% endcodeblock %}\n\n#### flex\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf flex-2.6.4.tar.gz\ncd flex-2.6.4\nsed -i \"/math.h/a #include <malloc.h>\" src/flexdef.h\nHELP2MAN=/tools/bin/true ./configure --prefix=/usr --docdir=/usr/share/doc/flex-2.6.4\nmake\nmake check\nmake install\nln -sv flex /usr/bin/lex\n{% endcodeblock %}\n\n#### grep\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf grep-3.3.tar.xz\ncd grep-3.3\n./configure --prefix=/usr --bindir=/bin\nmake\nmake -k check\nmake install\n{% endcodeblock %}\n\n#### bash\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf bash-5.0.tar.gz\ncd bash-5.0\n./configure --prefix=/usr --docdir=/usr/share/doc/bash-5.0 --without-bash-malloc --with-installed-readline\nmake\nchown -Rv nobody .\nsu nobody -s /bin/bash -c \"PATH=$PATH HOME=/home make tests\"\nmake install\nmv -vf /usr/bin/bash /bin\nexec /bin/bash --login +h\n{% endcodeblock %}\n\n#### libtool\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf libtool-2.4.6.tar.xz\ncd libtool-2.4.6\n./configure --prefix=/usr\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### gdbm\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf gdbm-1.18.1.tar.gz\ncd gdbm-1.18.1\n./configure --prefix=/usr --disable-static --enable-libgdbm-compat\nmake\nmake check\nmake install\n{% endcodeblock %}\n#### gperf\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf gperf-3.1.tar.gz\ncd gperf-3.1\n./configure --prefix=/usr --docdir=/usr/share/doc/gperf-3.1\nmake\nmake -j1 check\nmake install\n{% endcodeblock %}\n\n#### expat\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -jxvf expat-2.2.6.tar.bz2\ncd expat-2.2.6\nsed -i 's|usr/bin/env |bin/|' run.sh.in\n./configure --prefix=/usr --disable-static --docdir=/usr/share/doc/expat-2.2.6\nmake\nmake check\nmake install\ninstall -v -m644 doc/*.{html,png,css} /usr/share/doc/expat-2.2.6\n{% endcodeblock %}\n\n#### inetutils\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf inetutils-1.9.4.tar.xz\ncd inetutils-1.9.4\n./configure --prefix=/usr --localstatedir=/var --disable-logger --disable-whois --disable-rcp --disable-rexec --disable-rlogin --disable-rsh --disable-servers\nmake\nmake check\nmake install\n\nmv -v /usr/bin/{hostname,ping,ping6,traceroute} /bin\nmv -v /usr/bin/ifconfig /sbin\n{% endcodeblock %}\n\n#### perl\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf perl-5.28.1.tar.xz\ncd perl-5.28.1\necho \"127.0.0.1 localhost $(hostname)\" > /etc/hosts\nexport BUILD_ZLIB=False\nexport BUILD_BZIP2=0\n\nsh Configure -des -Dprefix=/usr -Dvendorprefix=/usr -Dman1dir=/usr/share/man/man1 -Dman3dir=/usr/share/man/man3 -Dpager=\"/usr/bin/less -isR\" -Duseshrplib -Dusethreads\nmake\nmake -k check\nmake install\nunset BUILD_ZLIB BUILD_BZIP2\n{% endcodeblock %}\n#### XML-Parser\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf XML-Parser-2.44.tar.gz\ncd XML-Parser-2.44\nperl Makefile.PL\nmake\nmake test\nmake install\n{% endcodeblock %}\n\n#### intltool\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf intltool-0.51.0.tar.gz \ncd intltool-0.51.0\nsed -i 's:\\\\\\${:\\\\\\$\\\\{:' intltool-update.in\n./configure --prefix=/usr\nmake\nmake check\nmake install\ninstall -v -Dm644 doc/I18N-HOWTO /usr/share/doc/intltool-0.51.0/I18N-HOWTO\n{% endcodeblock %}\n\n#### autoconf\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf autoconf-2.69.tar.xz\ncd autoconf-2.69\n./configure --prefix=/usr\nmake\nmake check\nmake install\n{% endcodeblock %}\n#### automake\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf automake-1.16.1.tar.xz \ncd automake-1.16.1\n./configure --prefix=/usr --docdir=/usr/share/doc/automake-1.16.1\nmake\nmake -j4 check\nmake install\n{% endcodeblock %}\n\n#### xz\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf xz-5.2.4.tar.xz\ncd xz-5.2.4\n./configure --prefix=/usr --disable-static --docdir=/usr/share/doc/xz-5.2.4\nmake\nmake check\nmake install\nmv -v /usr/bin/{lzma,unlzma,lzcat,xz,unxz,xzcat} /bin\nmv -v /usr/lib/liblzma.so.* /lib\nln -svf ../../lib/$(readlink /usr/lib/liblzma.so) /usr/lib/liblzma.so\n{% endcodeblock %}\n\n#### kmod\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf kmod-26.tar.xz \ncd kmod-26\n./configure --prefix=/usr --bindir=/bin --sysconfdir=/etc --with-rootlibdir=/lib --with-xz --with-zlib\nmake\nmake install\n\nfor target in depmod insmod lsmod modinfo modprobe rmmod; do\nln -sfv ../bin/kmod /sbin/$target\ndone\nln -sfv kmod /bin/lsmod\n{% endcodeblock %}\n\n#### gettext\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf gettext-0.19.8.1.tar.xz\ncd gettext-0.19.8.1\nsed -i '/^TESTS =/d' gettext-runtime/tests/Makefile.in && sed -i 's/test-lock..EXEEXT.//' gettext-tools/gnulib-tests/Makefile.in\nsed -e '/AppData/{N;N;p;s/\\.appdata\\./.metainfo./}' -i gettext-tools/its/appdata.loc\n./configure --prefix=/usr --disable-static --docdir=/usr/share/doc/gettext-0.19.8.1\nmake\nmake check\nmake install\nchmod -v 0755 /usr/lib/preloadable_libintl.so\n{% endcodeblock %}\n\n#### elfutils\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -jxvf elfutils-0.176.tar.bz2\ncd elfutils-0.176\n./configure --prefix=/usr\nmake\nmake check\nmake -C libelf install\ninstall -vm644 config/libelf.pc /usr/lib/pkgconfig\n{% endcodeblock %}\n\n#### libffi\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf libffi-3.2.1.tar.gz\ncd libffi-3.2.1\nsed -e '/^includesdir/ s/$(libdir).*$/$(includedir)/' -i include/Makefile.in\nsed -e '/^includedir/ s/=.*$/=@includedir@/' -e 's/^Cflags: -I${includedir}/Cflags:/' -i libffi.pc.in\n\n./configure --prefix=/usr --disable-static --with-gcc-arch=native\nmake\nmake check\nmake install\n{% endcodeblock %}\n#### openssl\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf openssl-1.1.1a.tar.gz\ncd openssl-1.1.1a\n./config --prefix=/usr --openssldir=/etc/ssl --libdir=lib shared zlib-dynamic\nmake\nmake test\nsed -i '/INSTALL_LIBS/s/libcrypto.a libssl.a//' Makefile\nmake MANSUFFIX=ssl install\nmv -v /usr/share/doc/openssl /usr/share/doc/openssl-1.1.1a\ncp -vfr doc/* /usr/share/doc/openssl-1.1.1a\n{% endcodeblock %}\n\n#### Python\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf Python-3.7.2.tar.xz\ncd Python-3.7.2\n./configure --prefix=/usr --enable-shared --with-system-expat --with-system-ffi --with-ensurepip=yes\nmake\nmake install\nchmod -v 755 /usr/lib/libpython3.7m.so\nchmod -v 755 /usr/lib/libpython3.so\ninstall -v -dm755 /usr/share/doc/python-3.7.2/html\ntar --strip-components=1 --no-same-owner --no-same-permissions -C /usr/share/doc/python-3.7.2/html -jxvf ../python-3.7.2-docs-html.tar.bz2\n{% endcodeblock %}\n\n#### ninja\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf ninja-1.9.0.tar.gz\ncd ninja-1.9.0\nexport NINJAJOBS=4\n\nsed -i '/int Guess/a \\\nint    j = 0;\\\nchar* jobs = getenv( \"NINJAJOBS\" );\\\nif ( jobs != NULL ) j = atoi( jobs );\\\nif ( j > 0 ) return j;\\\n' src/ninja.cc\n\npython3 configure.py --bootstrap\npython3 configure.py\n./ninja ninja_test\n./ninja_test --gtest_filter=-SubprocessTest.SetWithLots\n\ninstall -vm755 ninja /usr/bin/\ninstall -vDm644 misc/bash-completion /usr/share/bash-completion/completions/ninja\ninstall -vDm644 misc/zsh-completion /usr/share/zsh/site-functions/_ninja\n{% endcodeblock %}\n\n#### meson\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf meson-0.49.2.tar.gz \ncd meson-0.49.2\npython3 setup.py build\npython3 setup.py install --root=dest\ncp -rv dest/* /\n{% endcodeblock %}\n\n#### coreutils\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf coreutils-8.30.tar.xz \ncd coreutils-8.30\npatch -Np1 -i ../coreutils-8.30-i18n-1.patch\nsed -i '/test.lock/s/^/#/' gnulib-tests/gnulib.mk\nautoreconf -fiv \nFORCE_UNSAFE_CONFIGURE=1 ./configure --prefix=/usr --enable-no-install-program=kill,uptime\nFORCE_UNSAFE_CONFIGURE=1 make\nmake NON_ROOT_USERNAME=nobody check-root\necho \"dummy:x:1000:nobody\" >> /etc/group\nchown -Rv nobody .\nsu nobody -s /bin/bash -c \"PATH=$PATH make RUN_EXPENSIVE_TESTS=yes check\"\nsed -i '/dummy/d' /etc/group\nmake install\nmv -v /usr/bin/{cat,chgrp,chmod,chown,cp,date,dd,df,echo} /bin\nmv -v /usr/bin/{false,ln,ls,mkdir,mknod,mv,pwd,rm} /bin\nmv -v /usr/bin/{rmdir,stty,sync,true,uname} /bin\nmv -v /usr/bin/chroot /usr/sbin\nmv -v /usr/share/man/man1/chroot.1 /usr/share/man/man8/chroot.8\nsed -i s/\\\"1\\\"/\\\"8\\\"/1 /usr/share/man/man8/chroot.8\nmv -v /usr/bin/{head,nice,sleep,touch} /bin\n{% endcodeblock %}\n\n#### check\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf check-0.12.0.tar.gz\ncd check-0.12.0\n./configure --prefix=/usr\nmake\nmake check\nmake install\nsed -i '1 s/tools/usr/' /usr/bin/checkmk\n{% endcodeblock %}\n\n#### diffutils\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf diffutils-3.7.tar.xz \ncd diffutils-3.7\n./configure --prefix=/usr\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### gawk\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -xvf gawk-4.2.1.tar.xz\ncd gawk-4.2.1\nsed -i 's/extras//' Makefile.in\n./configure --prefix=/usr\nmake\nmake check\nmake install\nmkdir -v /usr/share/doc/gawk-4.2.1\ncp -v doc/{awkforai.txt,*.{eps,pdf,jpg}} /usr/share/doc/gawk-4.2.1\n{% endcodeblock %}\n\n#### findutils\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf findutils-4.6.0.tar.gz \ncd findutils-4.6.0\nsed -i 's/test-lock..EXEEXT.//' tests/Makefile.in\nsed -i 's/IO_ftrylockfile/IO_EOF_SEEN/' gl/lib/*.c\nsed -i '/unistd/a #include <sys/sysmacros.h>' gl/lib/mountlist.c\necho \"#define _IO_IN_BACKUP 0x100\" >> gl/lib/stdio-impl.h\n./configure --prefix=/usr --localstatedir=/var/lib/locate\nmake\nmake check\nmake install\nmv -v /usr/bin/find /bin\nsed -i 's|find:=${BINDIR}|find:=/bin|' /usr/bin/updatedb\n{% endcodeblock %}\n\n#### groff\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf groff-1.22.4.tar.gz\ncd groff-1.22.4\nPAGE=A4 ./configure --prefix=/usr\nmake -j1\nmake install\n{% endcodeblock %}\n\n#### grub\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf grub-2.02.tar.xz\ncd grub-2.02\n./configure --prefix=/usr --sbindir=/sbin --sysconfdir=/etc --disable-efiemu --disable-werror\nmake\nmake install\nmv -v /etc/bash_completion.d/grub /usr/share/bash-completion/completions\n{% endcodeblock %}\n\n#### less\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf less-530.tar.gz\ncd less-530\n./configure --prefix=/usr --sysconfdir=/etc\nmake\nmake install\n{% endcodeblock %}\n\n#### gzip\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf gzip-1.10.tar.xz\ncd gzip-1.10\n./configure --prefix=/usr\nmake\nmake check\nmake install\nmv -v /usr/bin/gzip /bin\n{% endcodeblock %}\n\n#### iproute\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf iproute2-4.20.0.tar.xz \ncd iproute2-4.20.0\nsed -i /ARPD/d Makefile\nrm -fv man/man8/arpd.8\nsed -i 's/.m_ipt.o//' tc/Makefile\nmake\nmake DOCDIR=/usr/share/doc/iproute2-4.20.0 install\n{% endcodeblock %}\n\n#### kbd\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf kbd-2.0.4.tar.xz \ncd kbd-2.0.4\npatch -Np1 -i ../kbd-2.0.4-backspace-1.patch\nsed -i 's/\\(RESIZECONS_PROGS=\\)yes/\\1no/g' configure\nsed -i 's/resizecons.8 //' docs/man/man8/Makefile.in\nPKG_CONFIG_PATH=/tools/lib/pkgconfig ./configure --prefix=/usr --disable-vlock\nmake\nmake check\nmake install\nmkdir -v /usr/share/doc/kbd-2.0.4\ncp -R -v docs/doc/* /usr/share/doc/kbd-2.0.4\n{% endcodeblock %}\n\n#### libpipeline\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf libpipeline-1.5.1.tar.gz\ncd libpipeline-1.5.1\n./configure --prefix=/usr\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### make\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf make-4.2.1.tar.gz \ncd make-4.2.1\nsed -i '211,217 d; 219,229 d; 232 d' glob/glob.c\n./configure --prefix=/usr\nmake\nmake PERL5LIB=$PWD/tests/ check\nmake install\n{% endcodeblock %}\n\n#### man-db\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf man-db-2.8.5.tar.xz\ncd man-db-2.8.5\n./configure --prefix=/usr --docdir=/usr/share/doc/man-db-2.8.5 --sysconfdir=/etc --disable-setuid --enable-cache-owner=bin --with-browser=/usr/bin/lynx --with-vgrind=/usr/bin/vgrind --with-grap=/usr/bin/grap --with-systemdtmpfilesdir= --with-systemdsystemunitdir=\nmake\nmake check\nmake install\n{% endcodeblock %}\n#### patch\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf patch-2.7.6.tar.xz\ncd patch-2.7.6\n./configure --prefix=/usr\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### tar\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf tar-1.31.tar.xz\ncd tar-1.31\nsed -i 's/abort.*/FALLTHROUGH;/' src/extract.c\nFORCE_UNSAFE_CONFIGURE=1 ./configure --prefix=/usr --bindir=/bin\nmake\nmake check\nmake install\nmake -C doc install-html docdir=/usr/share/doc/tar-1.31\n{% endcodeblock %}\n\n#### vim\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -jxvf vim-8.1.tar.bz2\ncd vim81/\necho '#define SYS_VIMRC_FILE \"/etc/vimrc\"' >> src/feature.h\n./configure --prefix=/usr\nmake\n\n# 测试结果\nLANG=en_US.UTF-8 make -j1 test &> vim-test.log\nmake install\n\nln -sv vim /usr/bin/vi\n\nfor L in /usr/share/man/{,*/}man1/vim.1; do\nln -sv vim.1 $(dirname $L)/vi.1\ndone\n\nln -sv ../vim/vim81/doc /usr/share/doc/vim-8.1\n\ncat > /etc/vimrc << \"EOF\"\n\" Begin /etc/vimrc\n\" Ensure defaults are set before customizing settings, not after\nsource $VIMRUNTIME/defaults.vim\nlet skip_defaults_vim=1\nset nocompatible\nset backspace=2\nset mouse=\nsyntax on\nif (&term == \"xterm\") || (&term == \"putty\")\nset background=dark\nendif\n\" End /etc/vimrc\nEOF\n\nvim -c ':options'\n{% endcodeblock %}\n\n#### procps\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf procps-ng-3.3.15.tar.xz\ncd procps-ng-3.3.15\n./configure --prefix=/usr --exec-prefix= --libdir=/usr/lib --docdir=/usr/share/doc/procps-ng-3.3.15 --disable-static --disable-kill\nmake\nsed -i -r 's|(pmap_initname)\\\\\\$|\\1|' testsuite/pmap.test/pmap.exp\nsed -i '/set tty/d' testsuite/pkill.test/pkill.exp\nrm testsuite/pgrep.test/pgrep.exp\nmake check\nmake install\nmv -v /usr/lib/libprocps.so.* /lib\nln -sfv ../../lib/$(readlink /usr/lib/libprocps.so) /usr/lib/libprocps.so\n{% endcodeblock %}\n\n#### utils-linux\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf util-linux-2.33.1.tar.xz\ncd util-linux-2.33.1\nmkdir -pv /var/lib/hwclock\nrm -vf /usr/include/{blkid,libmount,uuid}\n./configure ADJTIME_PATH=/var/lib/hwclock/adjtime --docdir=/usr/share/doc/util-linux-2.33.1 --disable-chfn-chsh --disable-login --disable-nologin --disable-su --disable-setpriv --disable-runuser --disable-pylibmount --disable-static --without-python --without-systemd --without-systemdsystemunitdir\nmake\nchown -Rv nobody .\nsu nobody -s /bin/bash -c \"PATH=$PATH make -k check\"\nmake install\n{% endcodeblock %}\n\n#### e2fsprogs\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf e2fsprogs-1.44.5.tar.gz \ncd e2fsprogs-1.44.5\nmkdir -v build\ncd build\n\n../configure --prefix=/usr --bindir=/bin --with-root-prefix=\"\" --enable-elf-shlibs --disable-libblkid --disable-libuuid --disable-uuidd --disable-fsck\nmake\nmake check\nmake install\n\nmake install-libs\n\nchmod -v u+w /usr/lib/{libcom_err,libe2p,libext2fs,libss}.a\ngunzip -v /usr/share/info/libext2fs.info.gz\n\ninstall-info --dir-file=/usr/share/info/dir /usr/share/info/libext2fs.info\n\nmakeinfo -o doc/com_err.info ../lib/et/com_err.texinfo\ninstall -v -m644 doc/com_err.info /usr/share/info\n\ninstall-info --dir-file=/usr/share/info/dir /usr/share/info/com_err.info\n{% endcodeblock %}\n\n#### sysklogd\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf sysklogd-1.5.1.tar.gz\ncd sysklogd-1.5.1\nsed -i '/Error loading kernel symbols/{n;n;d}' ksym_mod.c\nsed -i 's/union wait/int/' syslogd.c\nmake\nmake BINDIR=/sbin install\n\ncat > /etc/syslog.conf << \"EOF\"\n# Begin /etc/syslog.conf\nauth,authpriv.* -/var/log/auth.log\n*.*;auth,authpriv.none -/var/log/sys.log\ndaemon.* -/var/log/daemon.log\nkern.* -/var/log/kern.log\nmail.* -/var/log/mail.log\nuser.* -/var/log/user.log\n*.emerg *\n# End /etc/syslog.conf\nEOF\n{% endcodeblock %}\n\n#### sysvinit\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf sysvinit-2.93.tar.xz\ncd sysvinit-2.93\npatch -Np1 -i ../sysvinit-2.93-consolidated-1.patch\nmake\nmake install\n{% endcodeblock %}\n\n#### eudev\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf eudev-3.2.7.tar.gz\ncd eudev-3.2.7\n\ncat > config.cache << \"EOF\"\nHAVE_BLKID=1\nBLKID_LIBS=\"-lblkid\"\nBLKID_CFLAGS=\"-I/tools/include\"\nEOF\n\n./configure --prefix=/usr --bindir=/sbin --sbindir=/sbin --libdir=/usr/lib --sysconfdir=/etc --libexecdir=/lib --with-rootprefix= --with-rootlibdir=/lib --enable-manpages --disable-static --config-cache\n\nLIBRARY_PATH=/tools/lib make\n\nmkdir -pv /lib/udev/rules.d\nmkdir -pv /etc/udev/rules.d\n\nmake LD_LIBRARY_PATH=/tools/lib check\nmake LD_LIBRARY_PATH=/tools/lib install\ntar -jxvf ../udev-lfs-20171102.tar.bz2\nmake -f udev-lfs-20171102/Makefile.lfs install\n\n#配置\nLD_LIBRARY_PATH=/tools/lib udevadm hwdb --update\n{% endcodeblock %}\n\n#### 再次剥离(可选)\n{% codeblock lang:shell %}\n#在blfs中ｕ用valgrind 或 gdb运行测试时需要这些调试信息\nsave_lib=\"ld-2.29.so libc-2.29.so libpthread-2.29.so libthread_db-1.0.so\"\ncd /lib\nfor LIB in $save_lib; do\nobjcopy --only-keep-debug $LIB $LIB.dbg\nstrip --strip-unneeded $LIB\nobjcopy --add-gnu-debuglink=$LIB.dbg $LIB\ndone\nsave_usrlib=\"libquadmath.so.0.0.0 libstdc++.so.6.0.25\nlibitm.so.1.0.0 libatomic.so.1.2.0\"\ncd /usr/lib\nfor LIB in $save_usrlib; do\nobjcopy --only-keep-debug $LIB $LIB.dbg\nstrip --strip-unneeded $LIB\nobjcopy --add-gnu-debuglink=$LIB.dbg $LIB\ndone\nunset LIB save_lib save_usrlib\n\n#确保二进制能运行\nexec /tools/bin/bash\n\n#安全剥离二进制和库\n/tools/bin/find /usr/lib -type f -name \\*.a \\\n-exec /tools/bin/strip --strip-debug {} ';'\n/tools/bin/find /lib /usr/lib -type f \\( -name \\*.so* -a ! -name \\*dbg \\) \\\n-exec /tools/bin/strip --strip-unneeded {} ';'\n/tools/bin/find /{bin,sbin} /usr/{bin,sbin,libexec} -type f \\\n-exec /tools/bin/strip --strip-all {} ';'\n{% endcodeblock %}\n\n#### 清理\n{% codeblock lang:shell %}\nrm -rf /tmp/*\n\nexit\n\nsudo chroot \"$LFS\" /usr/bin/env -i HOME=/root TERM=\"$TERM\" PS1='(lfs chroot) \\u:\\w\\$ ' PATH=/bin:/usr/bin:/sbin:/usr/sbin /bin/bash --login\n\n\nrm -f /usr/lib/lib{bfd,opcodes}.a\nrm -f /usr/lib/libbz2.a\nrm -f /usr/lib/lib{com_err,e2p,ext2fs,ss}.a\nrm -f /usr/lib/libltdl.a\nrm -f /usr/lib/libfl.a\nrm -f /usr/lib/libz.a\nfind /usr/lib /usr/libexec -name \\*.la -delete\n{% endcodeblock %}\n\n","tags":["LFS系统构建"],"categories":["LFS系统构建"]},{"title":"LFS系统构建02-编译基本工具","url":"%2F2019%2F06%2F03%2FLFS%2FLFS%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA02-%E7%BC%96%E8%AF%91%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%2F","content":"\n### LFS系统构建02-编译基本工具\n\n#### Gnu Binutils\n{% codeblock lang:shell %}\ncd $LFS/sources\nxz -d binutils-2.32.tar.xz\ntar -xvf binutils-2.32.tar\ncd binutils-2.32\nmkdir -v build\ncd build\n\n#--prefix=/tools : 表示将编译后的文件存放到tools里\n#--with-sysroot  : 表示讲$LFS设为编译的根目录\n#--with-lib-path : 将静态库和动态库放入/tools/lib中\n#--target        : 将编译中的对象文件放入$LFS_TGT中\n../configure --prefix=/tools --with-sysroot=$LFS --with-lib-path=/tools/lib --target=$LFS_TGT --disable-nls --disable-werror\n#编译\nmake \n#如果是x86_64,需要创建链接到/tools/lib64\ncase $(uname -m) in\nx86_64) mkdir -v /tools/lib && ln -sv lib /tools/lib64 ;;\nesac\n#安装\nmake install\n{% endcodeblock  %}\n<!-- more -->\n#### GCC\n{% codeblock lang:shell %}\ncd $LFS/sources\nxz -d gcc-8.2.0.tar.xz\ntar -xvf gcc-8.2.0.tar\ncd gcc-8.2.0\n#安装gcc需要gmp mpfr mpc\ntar xvf ../gmp-6.1.2.tar.xz\nmv -v gmp-6.1.2/ gmp\ntar xvf ../mpfr-4.0.2.tar.xz\nmv -v mpfr-4.0.2/ mpfr\ntar -zxvf ../mpc-1.1.0.tar.gz\nmv -v mpc-1.1.0/ mpc\n\n#脚本\ncd $LFS/sources/gcc-8.2.0/\nfor file in gcc/config/{linux,i386/linux{,64}}.h\ndo\ncp -uv $file{,.orig}\nsed -e 's@/lib(64)\\?(32)\\?/ld@/tools&@g' \\\n-e 's@/usr@/tools@g' $file.orig > $file\necho '\n#undef STANDARD_STARTFILE_PREFIX_1\n#undef STANDARD_STARTFILE_PREFIX_2\n#define STANDARD_STARTFILE_PREFIX_1 \"/tools/lib/\"\n#define STANDARD_STARTFILE_PREFIX_2 \"\"' >> $file\ntouch $file.orig\ndone\n#执行结果\n'gcc/config/linux.h' -> 'gcc/config/linux.h.orig'\n'gcc/config/i386/linux.h' -> 'gcc/config/i386/linux.h.orig'\n'gcc/config/i386/linux64.h' -> 'gcc/config/i386/linux64.h.orig'\n\n\n#设置64为库默认目录名称为lib\n#脚本\ncase $(uname -m) in\nx86_64)\nsed -e '/m64=/s/lib64/lib/' \\\n-i.orig gcc/config/i386/t-linux64\n;;\nesac\n\nmkdir -v build\ncd build\n../configure --target=$LFS_TGT --prefix=/tools --with-glibc-version=2.17 --with-sysroot=$LFS --with-newlib --without-headers --with-local-prefix=/tools --with-native-system-header-dir=/tools/include --disable-nls --disable-shared --disable-multilib --disable-decimal-float --disable-threads --disable-libatomic --disable-libgomp --disable-libmpx --disable-libquadmath --disable-libssp --disable-libvtv --disable-libstdcxx --enable-languages=c,c++\nmake\n#错误\ng++: internal compiler error: Killed (program cc1plus)\n#原因\n内存不足造成的\n#解决\n在虚拟机上可以重新给虚拟机分配更大的内存，我的虚拟机只分配了512M内存，直接就造成内存不足\n如果还出现内存不足，那可以临时使用交换分区临来解决\nsudo dd if=/dev/zero of=/swapfile bs=64M count=16\nsudo mkswap /swapfile\nsudo swapon /swapfile\n使用完之后，就删除\nsudo swapoff /swapfile\nsudo rm /swapfile\n\nmake install\n{% endcodeblock  %}\n\n#### Linux-4.20.12\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf linux-4.20.12.tar.xz\ncd linux-4.20.12\nmake mrproper\nmake INSTALL_HDR_PATH=dest headers_install\ncp -rv dest/include/* /tools/include/\n{% endcodeblock %}\n\n#### glibc\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf glibc-2.29.tar.xz\ncd glibc-2.29\nmkdir -v build\ncd build/\n../configure --prefix=/tools --host=$LFS_TGT --build=$(../scripts/config.guess) --enable-kernel=3.10.0 --with-headers=/tools/include libc_cv_forced_unwind=yes libc_cv_c_cleanup=yes\n#编译错误(虚拟机centos编译错误,如果是实体机archlinux编译通过)\npython版本需要3.7\nmake版本需要4.2\ngmake是make命令的符号链接\n\n#实体机编译安装完全通过\nmake \nmake install\n\n#测试\necho 'int main(){}' > dummy.c\n$LFS_TGT-gcc dummy.c\nreadelf -l a.out | grep ': /tools'\n#如果编译通过不会出现错误，并且会打印\n[Requesting program interpreter: /tools/lib64/ld-linux-x86-64.so.2]\n#然后删除测试文件\nrm -v dummy.c a.out\n{% endcodeblock %}\n\n#### Libstdc++\n> gcc包里面的一个子包\n{% codeblock lang:shell %}\ncd $LFS/sources/\ntar xvf gcc-8.2.0.tar.xz\ncd gcc-8.2.0\nmkdir -v build\ncd build/\n../libstdc++-v3/configure --host=$LFS_TGT --prefix=/tools --disable-multilib --disable-nls --disable-libstdcxx-threads --disable-libstdcxx-pch --with-gxx-include-dir=/tools/$LFS_TGT/include/c++/8.2.0\nmake\nmake install\n{% endcodeblock %}\n\n\n#### Binutils(第二次编译)\n> 这一次编译使用第一次编译后的gcc来对其进行编译，以后的编译都会用属于lfs的gcc编译器来对包进行编译。这一次编译binutils，重新生成的binutils包依赖于新的gcc编译器，这使得整个工具链开始脱离宿主机，自形成体系\n{% codeblock lang:shell %}\ncd $LFS/sources/\ncd binutils-2.32\nmkdir -v build\ncd build/\nCC=$LFS_TGT-gcc AR=$LFS_TGT-ar RANLIB=$LFS_TGT-ranlib ../configure --prefix=/tools --disable-nls --disable-werror --with-lib-path=/tools/lib --with-sysroot\nmake\nmake install\n\n#这个准备用在下一章\nmake -C ld clean\nmake -C ld LIB_PATH=/usr/lib:/lib\ncp -v ld/ld-new /tools/bin\n{% endcodeblock %}\n\n#### gcc(第二次编译)\n> 第一次编译使用了宿主机的binutils工具集，因为binutils之前已经编译了，现在可以使用lfs的gcc和binutls来对gcc进行编译，使得编译后的gcc彻底成为lfs的编译器\n{% codeblock lang:shell %}\ncd $LFS/sources/\ntar xvf gcc-8.2.0.tar.xz\ncd gcc-8.2.0\ncat gcc/limitx.h gcc/glimits.h gcc/limity.h > `dirname $($LFS_TGT-gcc -print-libgcc-file-name)`/include-fixed/limits.h\n\n#脚本\nfor file in gcc/config/{linux,i386/linux{,64}}.h\ndo\ncp -uv $file{,.orig}\nsed -e 's@/lib\\(64\\)\\?\\(32\\)\\?/ld@/tools&@g' \\\n-e 's@/usr@/tools@g' $file.orig > $file\necho '\n#undef STANDARD_STARTFILE_PREFIX_1\n#undef STANDARD_STARTFILE_PREFIX_2\n#define STANDARD_STARTFILE_PREFIX_1 \"/tools/lib/\"\n#define STANDARD_STARTFILE_PREFIX_2 \"\"' >> $file\ntouch $file.orig\ndone\n\ncase $(uname -m) in\nx86_64)\nsed -e '/m64=/s/lib64/lib/' \\\n-i.orig gcc/config/i386/t-linux64\n;;\nesac\n\ntar -xvf ../mpfr-4.0.2.tar.xz\nmv -v mpfr-4.0.2 mpfr\ntar -xvf ../gmp-6.1.2.tar.xz\nmv -v gmp-6.1.2 gmp\ntar -xvf ../mpc-1.1.0.tar.gz\nmv -v mpc-1.1.0 mpc\n\nmkdir -v build\ncd build/\n\nCC=$LFS_TGT-gcc CXX=$LFS_TGT-g++ AR=$LFS_TGT-ar RANLIB=$LFS_TGT-ranlib ../configure --prefix=/tools --with-local-prefix=/tools --with-native-system-header-dir=/tools/include --enable-languages=c,c++ --disable-libstdcxx-pch --disable-multilib --disable-bootstrap --disable-libgomp\nmake\nmake install\nln -sv gcc /tools/bin/cc\n\necho 'int main(){}' > dummy.c\ncc dummy.c\nreadelf -l a.out | grep ': /tools'\n\n#编译通过会打印,这表示gcc成功编译安装\n[Requesting program interpreter: /tools/lib64/ld-linux-x86-64.so.2]\n\n#删除\nrm -v dummy.c a.out\n{% endcodeblock %}\n\n#### tcl\n{% codeblock lang:shell %}\ntar xvf tcl8.6.9-src.tar.gz\ncd tcl8.6.9\ncd unix/\n./configure --prefix=/tools\nmake\n\nTZ=UTC make test\nmake install\n\nchmod -v u+w /tools/lib/libtcl8.6.so\nmake install-private-headers\nln -sv tclsh8.6 /tools/bin/tclsh\n{% endcodeblock %}\n\n#### expect\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf expect5.45.4.tar.gz\ncd expect5.45.4\n\ncp -v configure{,.orig}\nsed 's:/usr/local/bin:/bin:' configure.orig > configure\n\n./configure --prefix=/tools --with-tcl=/tools/lib --with-tclinclude=/tools/include\nmake\nmake test\nmake SCRIPTS=\"\" install\n{% endcodeblock %}\n\n#### dejagnu\n{% codeblock lang:shell %}\ncd $LFS/sources/\ntar -zxvf dejagnu-1.6.2.tar.gz\ncd dejagnu-1.6.2\n./configure --prefix=/tools\nmake install\nmake check\n{% endcodeblock %}\n\n#### m4\n{% codeblock lang:shell %}\ncd $LFS/sources/\ntar xvf m4-1.4.18.tar.xz\ncd m4-1.4.18\n\nsed -i 's/IO_ftrylockfile/IO_EOF_SEEN/' lib/*.c\necho \"#define _IO_IN_BACKUP 0x100\" >> lib/stdio-impl.h\n\n./configure --prefix=/tools\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### ncurses\n{% codeblock lang:shell %}\ncd $LFS/sources/\ntar -zxvf ncurses-6.1.tar.gz\ncd ncurses-6.1\nsed -i s/mawk// configure\n\n./configure --prefix=/tools --with-shared --without-debug --without-ada --enable-widec --enable-overwrite\nmake\nmake install\nln -s libncursesw.so /tools/lib/libncurses.so\n{% endcodeblock %}\n\n#### bash\n{% codeblock lang:shell %}\ncd $LFS/sources/\ntar -zxvf bash-5.0.tar.gz\ncd bash-5.0\n./configure --prefix=/tools --without-bash-malloc\nmake\nmake tests\nmake install\nln -sv bash /tools/bin/sh\n{% endcodeblock %}\n\n#### bison\n{% codeblock lang:shell %}\ncd $LFS/sources/\ntar xvf bison-3.3.2.tar.xz\ncd bison-3.3.2\n./configure --prefix=/tools\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### bzip\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf bzip2-1.0.6.tar.gz \ncd bzip2-1.0.6\nmake\nmake PREFIX=/tools install\n{% endcodeblock %}\n\n#### coreutils\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf coreutils-8.30.tar.xz\ncd coreutils-8.30\n./configure --prefix=/tools --enable-install-program=hostname\nmake\nmake RUN_EXPENSIVE_TESTS=yes check\nmake install\n{% endcodeblock %}\n\n#### diffutils\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf diffutils-3.7.tar.xz \ncd diffutils-3.7\n./configure --prefix=/tools\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### file\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf file-5.36.tar.gz\n./configure --prefix=/tools\ncd file-5.36\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### findutils\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar -zxvf findutils-4.6.0.tar.gz\ncd findutils-4.6.0\n\n\nsed -i 's/IO_ftrylockfile/IO_EOF_SEEN/' gl/lib/*.c\nsed -i '/unistd/a #include <sys/sysmacros.h>' gl/lib/mountlist.c\necho \"#define _IO_IN_BACKUP 0x100\" >> gl/lib/stdio-impl.h\n\n./configure --prefix=/tools\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### gettext\n{% codeblock lang:shell %}\ncd $LFS/sources\ntar xvf gettext-0.19.8.1.tar.xz \ncd gettext-0.19.8.1\ncd gettext-tools/\nEMACS=\"no\" ./configure --prefix=/tools --disable-shared\n\nmake -C gnulib-lib\nmake -C intl pluralx.c\nmake -C src msgfmt\nmake -C src msgmerge\nmake -C src xgettext\n\ncp -v src/{msgfmt,msgmerge,xgettext} /tools/bin\n{% endcodeblock %}\n\n#### grep\n{% codeblock lang:shell %}\ntar xvf grep-3.3.tar.xz\ncd grep-3.3\n./configure --prefix=/tools\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### gzip\n{% codeblock lang:shell %}\ntar xvf gzip-1.10.tar.xz\ncd gzip-1.10\n./configure --prefix=/tools\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### make\n{% codeblock lang:shell %}\ntar -jxvf make-4.2.1.tar.bz2 \ncd make-4.2.1\nsed -i '211,217 d; 219,229 d; 232 d' glob/glob.c\n./configure --prefix=/tools --without-guile\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### patch\n{% codeblock lang:shell %}\ntar xvf patch-2.7.6.tar.xz\ncd patch-2.7.6\n./configure --prefix=/tools\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### perl\n{% codeblock lang:shell %}\ntar xvf perl-5.28.1.tar.xz\ncd perl-5.28.1\nsh Configure -des -Dprefix=/tools -Dlibs=-lm -Uloclibpth -Ulocincpth\nmake\ncp -v perl cpan/podlators/scripts/pod2man /tools/bin\nmkdir -pv /tools/lib/perl5/5.28.1\ncp -Rv lib/* /tools/lib/perl5/5.28.1\n{% endcodeblock %}\n#### python\n{% codeblock lang:shell %}\ntar xvf Python-3.7.2.tar.xz\ncd Python-3.7.2\nsed -i '/def add_multiarch_paths/a \\    return' setup.py\n\n./configure --prefix=/tools --without-ensurepip\nmake #如果编译错误，可能是你用sed加入语句到setup中的格式问题，只需要进入setup.py找到增加的那一行，改一下python语句格式\nmake install\n{% endcodeblock %}\n#### sed\n{% codeblock lang:shell %}\ntar xvf sed-4.7.tar.xz\ncd sed-4.7\n./configure --prefix=/tools\nmake\nmake check\nmake install\n{% endcodeblock %}\n#### tar\n{% codeblock lang:shell %}\ntar xvf tar-1.31.tar.xz\ncd tar-1.31\n./configure --prefix=/tools\nmake\nmake check\nmake install\n{% endcodeblock %}\n#### texinfo\n{% codeblock lang:shell %}\ntar xvf texinfo-6.5.tar.xz\ncd tar-1.31\nmake \nmake check\nmake install\n{% endcodeblock %}\n#### xz\n{% codeblock lang:shell %}\ntar xvf xz-5.2.4.tar.xz\ncd xz-5.2.4\n./configure --prefix=/tools\nmake\nmake check\nmake install\n{% endcodeblock %}\n\n#### 移除不必要的文件\n{% codeblock lang:shell %}\nstrip --strip-debug /tools/lib/*\n/usr/bin/strip --strip-unneeded /tools/{,s}bin/*\nrm -rf /tools/{,share}/{info,man,doc}\nfind /tools/{lib,libexec} -name \\*.la -delete\n{% endcodeblock %}\n\n#### 改变所有者\n{% codeblock lang:shell %}\nchown -R root:root $LFS/tools\n{% endcodeblock %}\n","tags":["LFS系统构建"],"categories":["LFS系统构建"]},{"title":"LFS系统构建01-宿主机环境搭建","url":"%2F2019%2F06%2F03%2FLFS%2FLFS%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA01-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F","content":"\n### LFS系统构建01-宿主机环境搭建\n\n#### 环境检查\n  + 运行shell脚本version_check.sh，具体代码由官方手册提供\n<!-- more -->\n{% codeblock lang:shell %}\n#!/bin/bash\n# Simple script to list version numbers of critical development tools\nexport LC_ALL=C\nbash --version | head -n1 | cut -d\" \" -f2-4\nMYSH=$(readlink -f /bin/sh)\necho \"/bin/sh -> $MYSH\"\necho $MYSH | grep -q bash || echo \"ERROR: /bin/sh does not point to bash\"\nunset MYSH\necho -n \"Binutils: \"; ld --version | head -n1 | cut -d\" \" -f3-\nbison --version | head -n1\nif [ -h /usr/bin/yacc ]; then\necho \"/usr/bin/yacc -> `readlink -f /usr/bin/yacc`\";\nelif [ -x /usr/bin/yacc ]; then\necho yacc is `/usr/bin/yacc --version | head -n1`\nelse\necho \"yacc not found\"\nfi\nbzip2 --version 2>&1 < /dev/null | head -n1 | cut -d\" \" -f1,6-\necho -n \"Coreutils: \"; chown --version | head -n1 | cut -d\")\" -f2\ndiff --version | head -n1\nfind --version | head -n1\ngawk --version | head -n1\nif [ -h /usr/bin/awk ]; then\necho \"/usr/bin/awk -> `readlink -f /usr/bin/awk`\";\nelif [ -x /usr/bin/awk ]; then\necho awk is `/usr/bin/awk --version | head -n1`\nelse\necho \"awk not found\"\nfi\n\ngcc --version | head -n1\ng++ --version | head -n1\nldd --version | head -n1 | cut -d\" \" -f2-\ngrep --version | head -n1\ngzip --version | head -n1\ncat /proc/version\nm4 --version | head -n1\nmake --version | head -n1\npatch --version | head -n1\necho Perl `perl -V:version`\nsed --version | head -n1\ntar --version | head -n1\nmakeinfo --version | head -n1\nxz --version | head -n1\n\necho 'int main(){}' > dummy.c && g++ -o dummy dummy.c\nif [ -x dummy ]\nthen echo \"g++ compilation OK\";\nelse echo \"g++ compilation failed\"; fi\nrm -f dummy.c dummy\n{% endcodeblock %}\n\n  + 检查结果\n{% codeblock lang:shell %}\nbash, version 4.2.46(2)-release\n/bin/sh -> /usr/bin/bash\nBinutils: version 2.27-34.base.el7\n./version_check.sh: line 10: bison: command not found\nyacc not found\nbzip2,  Version 1.0.6, 6-Sept-2010.\nCoreutils:  8.22\ndiff (GNU diffutils) 3.3\nfind (GNU findutils) 4.5.11\nGNU Awk 4.0.2\n/usr/bin/awk -> /usr/bin/gawk\ngcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-36)\n./version_check.sh: line 32: g++: command not found\n(GNU libc) 2.17\ngrep (GNU grep) 2.20\ngzip 1.5\nLinux version 3.10.0-957.12.2.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 SMP Tue May 14 21:24:32 UTC 2019\nm4 (GNU M4) 1.4.16\nGNU Make 3.82\n./version_check.sh: line 39: patch: command not found\nPerl version='5.16.3';\nsed (GNU sed) 4.2.2\ntar (GNU tar) 1.26\n./version_check.sh: line 43: makeinfo: command not found\nxz (XZ Utils) 5.2.2\n./version_check.sh: line 46: g++: command not found\ng++ compilation failed\n{% endcodeblock %}\n  + 按照检查结果安装缺失软件\n{% codeblock lang:shell %}\nyum install bison byacc.x86_64 gcc-c++ patch texinfo.x86_64 epel-release.noarch\n{% endcodeblock %}\n\n#### 运行环境配置\n\n  1. 设置变量LFS\n{% codeblock lang:shell %}\nexport LFS=/mnt/lfs\n{% endcodeblock %}\n  2. 挂载文件系统\n{% codeblock lang:shell %}\nmkfs.ext4 /dev/sdb\nmkdir -pv $LFS\nmount -v -t ext4 /dev/sdb $LFS\n{% endcodeblock %}\n  3. 创建sources目录放置源码 \n{% codeblock lang:shell %}\nmkdir -v $LFS/sources\nchmod -v a+wt $LFS/sources\n{% endcodeblock %}\n  4. 下载软件包\n{% codeblock lang:shell %}\nwget mirrors.ustc.edu.cn/lfs/lfs-packages/lfs-packages-8.4.tar\ntar -xvf lfs-packages-8.4.tar -C $LFS/sources/\n{% endcodeblock %}\n  5. 检查软件包完整性\n{% codeblock lang:shell %}\npushd $LFS/sources\nmd5sum -c sources/md5sums\npopd\n{% endcodeblock %}\n  6. 创建tools目录，用于存储工具\n{% codeblock lang:shell %}\nmkdir -v $LFS/tools \nln -sv $LFS/tools /\n{% endcodeblock %}\n\n  7. 创建lfs用户和组\n{% codeblock lang:shell %}\ngroupadd lfs\nuseradd -s /bin/bash -g lfs -m -k /dev/null lfs\necho \"\" | passwd --stdin lfs\n{% endcodeblock %}\n  8. 设置目录权限\n{% codeblock lang:shell %}\nchown -v lfs $LFS/sources\nchown -v lfs $LFS/tools\n{% endcodeblock %}\n  9. 配置lfs用户\n{% codeblock lang:shell %}\ncat > ~/.bash_profile << \"EOF\"\nexec env -i HOME=$HOME TERM=$TERM PS1='\\u:\\w\\$ ' /bin/bash\nEOF\nsource ~/.bash_profile\ncat > ~/.bashrc << \"EOF\"\nset +h\numask 022\nLFS=/mnt/lfs\nLC_ALL=POSIX\nLFS_TGT=$(uname -m)-lfs-linux-gnu\nPATH=/tools/bin:/bin:/usr/bin\nexport LFS LC_ALL LFS_TGT PATH\nEOF\nsource ~/.bashrc\n{% endcodeblock %}\n\n","tags":["LFS系统构建"],"categories":["LFS系统构建"]},{"title":"LFS资料收集","url":"%2F2019%2F06%2F03%2FLFS%2FLFS%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86%2F","content":"\n[LFS经验](https://www.cnblogs.com/spaceship9/p/6526887.html)\n[LFS 中文版手册发布：如何打造自己的 Linux 发行版](https://www.linuxidc.com/Linux/2015-07/119840.htm)\n[GNU Binutils二进制工具集](https://blog.csdn.net/lu_embedded/article/details/78205161)\n[定制lfs镜像(所有系统都适用)](https://blog.csdn.net/decload/article/details/7407698)\n[定制lfs镜像(使用ubuntu提供的方法)](https://blog.csdn.net/houjian914/article/details/69817524)\n[lfs系统构建所需的源码包(打包为一个大包)](http://mirrors.ustc.edu.cn/lfs/lfs-packages/lfs=packages-8.4.tar)\n[lfs系统构建所需的源码包(分散打包)](http://mirrors.ustc.edu.cn/lfs/lfs-packages/8.4)\n","tags":["LFS系统构建"],"categories":["LFS系统构建"]},{"title":"SpringBoot初识","url":"%2F2019%2F06%2F03%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FSpringBoot%2FSpringBoot%E5%88%9D%E8%AF%86%2F"},{"title":"jenkins项目自动构建","url":"%2F2019%2F06%2F01%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FJenkins%2Fjenkins%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%2F","content":"\n### jenkins项目自动构建\n> 这篇博客是jenkins系列的第三篇，上面两篇为[jenkins持续集成](https://rack-leen.github.io/2019/05/31/Java/Jenkins/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/)和[jenkins安装与部署](https://rack-leen.github.io/2019/05/31/Java/Jenkins/jenkins%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/)，jenkins持续集成是本系列的总纲，jenkins安装与部署是本系列的第一篇。这一篇衔接jenkins安装与部署。\n\n<!--more-->\n#### 设置自动触发\n  + 首先，进入jenkins主界面，如下图。\n  ![1](1.png)\n  + 然后，点击deployee这个项目名，进入如下界面\n  ![2](2.png)\n  + 点击配置，进入如下界面，选中构建触发器选项，再选中触发远程构建复选框，输入自己的身份令牌，这个身份令牌你就随便输入一个自己熟悉的字符串。\n  ![3](3.png)\n  + 之后，你就能获取到触发的路径JENKINS_URL/job/deployee/build?token=TOKEN_NAME。代为真正的路径就是http://你的jenkins服务器地址:8080/job/deployee/build?token=RACK_LEEN\n    解释：\n      JENKINS_URL:就是你安装jenkins时在插件安装后出现的让你填入的路径\n      deployee:你自己需要触发的项目的名字\n      token=TOKEN_NAME:你填入的身份令牌\n#### 配置码云\n  + 进入你的项目在码云上的位置\n  ![4](4.png)\n  + 然后点击管理，进入如下界面\n  ![5](5.png)\n  + 点击WebHooks,进入如下界面\n  ![6](6.png)\n  +点击添加，进入如下界面，输入你从jenkins中复制过来的http://120.78.168.80:8080/jenkins/job/deployee/build\"token=RACK_LEEN，然后点击激活\n  ![7](7.png)\n#### 最后\n  + 进入jenkins中的主界面上的系统管理里的全局安全配置，进入如下界面，将跨站请求伪造保护关闭，然后保存\n  ![8](8.png)\n  + 最后，重启jenkins服务器，完成整个自动部署\n","tags":["Jenkins"],"categories":["Jenkins"]},{"title":"jenkins安装与部署","url":"%2F2019%2F05%2F31%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FJenkins%2Fjenkins%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%2F","content":"\n### jenkins安装与部署\n\n#### 安装准备\n##### tomcat服务器\n{% codeblock lang:shell %}\nwget https://archive.apache.org/dist/tomcat/tomcat-8/v8.0.1/bin/apache-tomcat-8.0.1.tar.gz \ntar -zxvf apache-tomcat-8.0.1.tar.gz -C /usr/local/\ncd /usr/local/apache-tomcat-8.0.1/bin/\n./startup.sh\n{% endcodeblock %}\n<!--more-->\n##### git\n> 从github官网下载最新git源码\n  + 全局安装\n{% codeblock lang:shell %}\nyum install git\ngit clone https://github.com/git/git\n#第一种安装方法(分散安装)\ncd git #进入git源码目录\nvim INSTALL #阅读git的安装文档\nmake prefix=/usr/local/git all doc #为当前用户安装\nmake prefix=/usr/local/git install install-doc install-html install-info #为root用户安装\n\n#第二种安装方法(集中安装)\nmake prefix=/usr/local/git all \nmake prefix=/usr/local/git install\necho \"#git envirnment\\nexport GIT_HOME=/usr/local/git\\nexport PATH=\\$PATH:\\${GIT_HOME}/bin\" >> /etc/profile\nsource /etc/profile\n{% endcodeblock %}\n\n  + 编译问题\n{% codeblock lang:shell %}\n1. http.h:6:23: fatal error: curl/curl.h: No such file or directory\nyum install libcurl-devel.x86_64\n2. http-push.c:22:19: fatal error: expat.h: No such file or directory\nyum install expat-devel.x86_64\n3. /bin/sh: line 1: asciidoc: command not found\nyum install asciidoc.noarch\n4. /bin/sh: line 1: xmlto: command not found\nyum install xmlto.x86_64\n5. /bin/sh: line 1: docbook2x-texi: command not found\nyum install docbook2X.x86_64\nln -s /usr/bin/db2x_docbook2texi /usr/bin/docbook2x-texi\n{% endcodeblock %}\n##### maven\n{% codeblock lang:shell %}\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.1/binaries/apache-maven-3.6.1-bin.tar.gz\ntar -zxvf apache-maven-3.6.1-bin.tar.gz -C /usr/local/\ncd /usr/local/\nmv apache-maven-3.6.1 maven3\n#为maven设置环境变量\neacho \"#maven envirnment\\nexport MAVEN_HOME=/usr/local/apache-maven-3.6.1\\nexport PATH=\\$PATH:\\${MAVEN_HOME}/bin\" >> /etc/profile\nsource /etc/profile\n{% endcodeblock %}\n##### jenkins \n  + 准备jenkins.war包\n{% codeblock lang:shell %}\nyum install wget\nwget https://mirrors.tuna.tsinghua.edu.cn/jenkins/war-stable/2.164.3/jenkins.war\nmv jenkins.war /usr/local/apache-tomcat-8.0.1/webapps/\n#重启tomcat\n./shutdhow.sh\n./startup.sh\n{% endcodeblock %}\n\n#### jenkins安装与部署\n##### jenkins安装\n  + 在浏览器中输入http://120.78.168.80:8080/jenkins/进入jenkins，有时会出现下面这个界面，需要等待一下，让jenkins初始化一下。\n  ![jenkins1](jenkins1.png)\n  + 然后，进入登录界面，按下图提示获取密码，接着继续\n  ![jenkins2](jenkins2.png)\n  + 接着，进入插件安装界面，可以选择推荐安装\n  ![jenkins3](jenkins3.png)\n  + 之后，进入插件安装界面，安装插件\n  ![jenkins4](jenkins4.png)\n  + 插件安装成功后，开始配置账户，设置自己的账户，也可以使用默认的admin账户\n  ![jenkins5](jenkins5.png)\n  + 之后，开始实例配置，可以直接使用默认设置\n  ![jenkins6](jenkins6.png)\n  + 最后，jenkins安装完毕，可以开始使用jenkins了\n  ![jenkins7](jenkins7.png)\n##### jenkins构建项目配置\n  + 下图就是初始化后的jenkins主界面\n  ![jenkins8](jenkins8.png)\n  + 首先，进入系统管理，点击左边的系统管理按钮，进入如下界面。如果出现反向代理设置有误，不用理\n  ![jenkins9](jenkins9.png)\n  + 然后，进入全局安全设置，设置为下图样式，然后保存\n  ![jenkins10](jenkins10.png)\n  + 之后，进入全局工具配置，配置maven settings设置\n  ![jenkins11](jenkins11.png)\n  + 配置maven根路径\n  ![jenkins12](jenkins12.png)\n  + 配置git\n  ![jenkins13](jenkins13.png)\n  + 配置jdk，最后保存\n  ![jenkins14](jenkins14.png)\n  + 重新进入主界面，点击创建新任务\n  ![jenkins15](jenkins15.png)\n  + 进入如下界面，输入自己想要构建的项目，选中第一项\n  ![jenkins16](jenkins16.png)\n  + 进入如下界面，然后选中第五个选项\n  ![jenkins18](jenkins18.png)\n  + 然后选择之前配置的maven，并选择maven的构建指令\n  ![jenkins17](jenkins17.png)\n  + 之后，选择源码管理，选中git,得到以下界面\n  ![jenkins19](jenkins19.png)\n  + 然后添加凭据(也就是你的码云账户密码)，最后保存配置\n  ![jenkins20](jenkins20.png)\n  + 回到主界面，会看到下面的界面样式\n  ![jenkins21](jenkins21.png)\n##### jenkins实现项目构建\n  + 选中系统管理->插件管理，进入如下图。选中可选插件，选中勾选的deploy to container选项，然后点击直接安装\n  ![jenkins22](jenkins22.png)\n  + 然后会进入下面这个界面，等待安装完成\n  ![jenkins23](jenkins23.png)\n##### jenkins项目构建\n  + 进入主界面，点击需要构建的项目选项的最后一个选项，进行项目构建,然后点击第二个选项，进入如下界面\n  ![jenkins27](jenkins27.png)\n  + 然后点击控制台输出，进入如下界面，等待maven工具构建完成(第一次需要等待一些时间,因为maven需要下载依赖包，下载下来后，以后再构建速度就快了)\n  ![jenkins26](jenkins26.png)\n##### jenkins构建后部署到项目服务器\n  + 进入主界面，点击deployee这个项目工程名称，进入以下界面\n  ![jenkins24](jenkins24.png)\n  + 点击配置重新进入构建配置界面，设置为如下形式，并保存\n  ![jenkins25](jenkins25.png)\n  + 然后，进入去第三方服务器访问。好的现在部署完成\n  ![jenkins30](jenkins30.png)\n\n\n##### 项目构建中的问题\n  + 问题1:这个问题是因为tomcat配置问题，一般出现这种问题，都是tomcat的manager角色没有配置好\n  ![jenkins28](jenkins28.png)\n  因此，你需要配置一下角色\n{% codeblock lang:xml %}\nvim tomcat-users.xml\n#在</tomcat-user>前面添加以下内容\n  <role rolename=\"admin-gui\"/>\n    <role rolename=\"admin-script\"/>\n      <role rolename=\"manager-gui\"/>\n        <role rolename=\"manager-script\"/>\n          <user username=\"tomcat\" password=\"tomcat\" roles=\"admin-gui,admin-script,manager-gui,manager-script\"/>\n#然后保存\n{% endcodeblock %}\n  + 问题2: 看下图，这个问题一般是你自己项目的问题，因为出现这种问题表示构建成功了，且部署到三方服务器上了，但是你的项目不能运行。这就是你开发的项目有问题，你需要自己修改一下项目代码。\n  ![jenkins29](jenkins29.png)\n + 然后返回到主界面，点击最后一个选项构建项目就行了，如果构建成功，项目会被直接部署到你选定的服务器上\n","tags":["Jenkins"],"categories":["Jenkins"]},{"title":"jenkins持续集成","url":"%2F2019%2F05%2F31%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FJenkins%2Fjenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F","content":"\n### jenkins持续集成\n\n####　持续集成介绍\n#### 开发环境\n##### 两个公网服务器和一个本地开发机器\n###### 本机开发机器\n> 用于开发项目\n  + idea集成开发环境\n    用来开发项目\n  + maven项目包管理工具\n    用来解决项目包依赖问题，自动导入包\n  + git\n    用来将开发的项目托管到git远程仓库(这里用的是gitee)\n<!--more-->\n###### 公网服务器1\n> 是jenkins服务器，作为持续集成的构建服务器\n  + apache-tomcat服务器\n    用于运行jenkins\n  + maven项目管理工具\n    被jenkins工具调用来部署项目\n  + git\n    被jenkins工具调用来将项目发布到服务器\n  + jenkins持续部署工具\n    用于自动化构建项目并发布到项目的运行服务器上\n###### 公网服务器2\n> 是部署项目服务器，作为最终项目发布的服务器\n  + apache-tomcat服务器\n    用于发布最终的项目\n\n#### 持续集成过程\n##### 本地开发机器\n  + 具体过程查看[SSM项目部署与发布](https://rack-leen.github.io/2019/05/30/Java/SSM/SSM%E9%A1%B9%E7%9B%AE%E6%9B%B4%E6%96%B0%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/)\n##### jenkins项目安装与部署\n  + 具体过程查看[jenkins安装与部署](https://rack-leen.github.io/2019/05/31/Java/Jenkins/jenkins%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/)\n##### jenkins设置自动触发进行构建\n  + 具体过程看[jenkins项目自动构建](https://rack-leen.github.io/2019/06/01/Java/Jenkins/jenkins%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/)\n","tags":["Jenkins"],"categories":["Jenkins"]},{"title":"SSM项目更新到远程仓库","url":"%2F2019%2F05%2F30%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FSSM%2FSSM%E9%A1%B9%E7%9B%AE%E6%9B%B4%E6%96%B0%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F","content":"\n### SSM项目更新到远程仓库\n#### 开发环境\n  + 开发工具 \n    idea集成开发环境\n  + 版本控制工具\n    git分布式版本控制工具\n  + 开发平台\n    linux操作系统\n  + SSM项目\n    [deployee项目](https://rack-leen.github.io/2019/05/29/Java/SSM/SSM%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88%E4%B8%8E%E5%8F%91%E5%B8%83/)\n<!--more-->\n#### 创建git本地仓库\n  + 如果是创建一个初始项目，没有任何更新。则打开idea,选择顶栏的VCS(版本控制系统)->Import Into Version Control->Create Git Repository,进入下图界面，选中你需要git的SSM项目\n    ![git1](git1.png)\n  + 如果是与别人协同开发，则需要克隆远端仓库来开发,在打开idea后，选择ckeck out from version control,选择git,进入如下界面,之后，进入新项目中。\n    ![git](git.png)\n#### 提交到本地仓库\n  + 然后，会出现如下图的样子，所有的文件都变为红色，这表示这些文件还未加入本地仓库\n    ![git2](git2.png)\n  + 右键点击项目名，选择Git->Add,将所有文件加入暂存区，此时所有文件变为绿色\n    ![git3](git3.png)\n  + 然后选择Git->Commit Directory,进入下面界面,点击右下角Commit将文件提交到本地仓库\n    ![git4](git4.png)\n#### 设置远程仓库\n  + 进入git->repository->remote，添加远程仓库\n    ![git5](git5.png)\n#### 更新到远程仓库\n  + 选中项目点击右键，进入git->repository->pull,之后进入下面界面，点击remote的右边按钮，获得下方选中的合并分支，然后将远端仓库拉取到本地\n    ![git7](git7.png)\n  + 如果pull失败,出现以下情况\n{% codeblock lang:shell  %}\nPOST git-upload-pack (215 bytes)\n  warning: no common commits\n  remote: Enumerating objects: 92, done.        \n  remote: Total 92 (delta 3), reused 0 (delta 0)\n  From http://gitee.com/rackleen/test1\n   * branch            master     -> FETCH_HEAD\n    * [new branch]      master     -> origin/master\n    fatal: refusing to merge unrelated histories\n{% endcodeblock %}\n    冲突解决方案\n      git pull origin master\n      git pull origin master --allow-unrelated-histories #强行合并\n      git add .   #重新将文件增加到暂存区\n      git commit -m \"update\" #重新提交\n      git push origin master #之后应该能够提交了\n    如果上述步骤不能解决冲突，那就多用几次\n  \n  + idea提供了push选项,git->repository->push，进入下图界面,选择push，最终push成功\n    ![git6](git6.png)\n\n","tags":["Idea"],"categories":["SSM"]},{"title":"SSM项目整合与发布","url":"%2F2019%2F05%2F29%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FSSM%2FSSM%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88%E4%B8%8E%E5%8F%91%E5%B8%83%2F","content":"\n### SSM项目整合与发布\n#### 创建SSM项目\n  1. 选择Maven项目类型，选择webapp(选中的那一项)\n![deployee1](deployee1.png)\n  2. 填入自己项目组id,一般为com.xxx.xxx;填入项目id，也就是项目名\n![deployee2](deployee2.png)\n  3. 项目创建成功之后，创建java源代码目录,在src中的main目录下创建\n![deployee3](deployee3.png)\n  4. 创建resources目录(存放配置文件)，也是在src中的目录下创建\n  5. 配置tomcat,点击+,选择tomcat server->local,创建一个本地tomcat，也可以创建一个远程tomcat(选择remote)\n    open browser选择浏览器\n![deployee4](deployee4.png)\n  6. 进入deployment中，点击右边的+,选择第一个选项，得到途中选中的一项\n![deployee5](deployee5.png)\n<!--more-->\n#### 创建配置文件\n  + 创建web配置文件(web.xml)\n{% codeblock lang:xml %}\n<!DOCTYPE web-app PUBLIC\n \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"\n \"http://java.sun.com/dtd/web-app_2_3.dtd\" >\n\n<web-app>\n  <display-name>Archetype Created Web Application</display-name>\n\n  <!--配置Spring-->\n  <context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>classpath:bean-*.xml</param-value>\n  </context-param>\n\n  <!--监听器-->\n  <listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n  </listener>\n\n  <!--配置Spring mvc-->\n  <servlet>\n    <servlet-name>DispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value>classpath:spring-mvc.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n\n  <servlet-mapping>\n    <servlet-name>DispatcherServlet</servlet-name>\n    <url-pattern>*.action</url-pattern> <!--Spring mvc默认后缀为action-->\n  </servlet-mapping>\n</web-app>\n{% endcodeblock %}\n  + 创建数据库信息配置文件(db.properties)\n{% codeblock lang:xml %}\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://127.0.0.1:3306/ssmdb?characterEncoding=utf-8\njdbc.username=root\njdbc.password=root\n{% endcodeblock %}\n  + 创建springmvc配置文件(spring-mvc.xml)\n{% codeblock lang:xml %}\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context-4.0.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop-4.0.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx-4.0.xsd\n        http://www.springframework.org/schema/mvc\n        http://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    <!--扫描控制器-->\n    <context:component-scan base-package=\"com.deployee.controller\"></context:component-scan>\n\n\n    <!--配置一个bean-->\n    <bean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\">\n        <property name=\"messageConverters\">\n            <ref bean=\"httpMessageConverter\"/><!--为其他注解配置id为httpMessageConverter的消息转换器-->\n        </property>\n    </bean>\n\n    <!--配置一个请求的适配器-->\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\">\n        <property name=\"messageConverters\">\n            <ref bean=\"httpMessageConverter\"/> <!--为requestMapper注解配置id为httpMessageConverter的消息转换器-->\n        </property>\n    </bean>\n\n    <!--配置消息转换器-->\n    <!--将消息转换为json格式-->\n    <bean id=\"httpMessageConverter\" class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\">\n        <property name=\"supportedMediaTypes\">\n            <list>\n                <bean class=\"org.springframework.http.MediaType\">\n                    <constructor-arg index=\"0\" value=\"application\"/><!--作用于application(整个项目)-->\n                    <constructor-arg index=\"1\" value=\"json\"/><!--消息格式为json-->\n                    <constructor-arg index=\"2\" value=\"UTF-8\"/><!--消息编码为utf-8-->\n                </bean>\n            </list>\n        </property>\n    </bean>\n\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\" />\n        <property name=\"suffix\" value=\".jsp\" />\n    </bean>\n\n    <!--注册注解驱动-->\n    <mvc:annotation-driven>\n\n    </mvc:annotation-driven>\n    <mvc:default-servlet-handler></mvc:default-servlet-handler>\n</beans>\n{% endcodeblock %}\n  + 创建mybatis配置文件(bean-mybatis.xml)\n{% codeblock lang:xml %}\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n\n\n    <!---加载数据属性文件-->\n    <!--通过实体PropertyPlaceholderConfigurer将属性文件中的值提取出来-->\n    <bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\n        <!--如果资源没有被找到，不报错-->\n        <property name=\"ignoreResourceNotFound\" value=\"true\"/>\n        <!--从路径中加载配置文件集合，配置文件就是集合的值-->\n        <property name=\"locations\">\n            <list>\n                <value>classpath:db.properties</value>\n            </list>\n        </property>\n    </bean>\n\n    <!--配置数据源-->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://ip address:3306/ssmdb?characterEncoding=utf-8\"/>\n        <property name=\"username\" value=\"rack\"/>\n        <property name=\"password\" value=\"123456\"/>\n    </bean>\n\n    <!--配置mybatis与spring整合-->\n    <bean id=\"sessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/>\n        <property name=\"typeAliasesPackage\" value=\"com.deployee.pojo\"/>\n    </bean>\n\n    <!--代理对象-->\n    <bean id=\"scannerConfigurer\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <!--将session对象工厂引入-->\n        <property name=\"sqlSessionFactory\" ref=\"sessionFactory\"/>\n        <!--接口位置-->\n        <property name=\"basePackage\" value=\"com.deployee.mapper\"/>\n    </bean>\n\n    <!--扫描所有包-->\n    <context:component-scan base-package=\"com.deployee.*\"></context:component-scan>\n    <!--自动代理-->\n    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n</beans>\n{% endcodeblock %}\n\n#### 创建各个java文件\n##### 创建com.deployee.pojo包\n  + 创建User文件\n{% codeblock lang:java %}\npackage com.deployee.pojo;\n\nimport java.io.Serializable;\n\npublic class User implements Serializable {\n    private Integer id ;\n    private String username ;\n    private String password ;\n\n    public User() {\n    }\n\n    public User(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public User(Integer id, String username, String password) {\n        this.id = id;\n        this.username = username;\n        this.password = password;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                \", password='\" + password + '\\'' +\n                '}';\n    }\n}\n\n{% endcodeblock %}\n##### 创建com.deployee.mapper包\n  + 创建UserMapper文件\n{% codeblock lang:java %}\npackage com.deployee.mapper;\n\nimport com.deployee.pojo.User;\n\nimport java.util.List;\n\npublic interface UserMapper {\n    List<User> list();\n}\n{% endcodeblock %}\n\n##### 创建com.deployee.service包\n  + 创建UserService文件\n{% codeblock lang:java %}\npackage com.deployee.service;\n\nimport com.deployee.pojo.User;\n\nimport java.util.List;\n\npublic interface UserService {\n    List<User> list();\n}\n\n{% endcodeblock %}\n##### 创建com.deployee.service.impl包\n  + 创建UserServiceImpl文件\n{% codeblock lang:java %}\npackage com.deployee.service.impl;\n\nimport com.deployee.mapper.UserMapper;\nimport com.deployee.pojo.User;\nimport com.deployee.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\nimport java.util.List;\n\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private UserMapper userMapper = null ;\n\n    /**\n     * 这个注解是用来实现在对象加入IOC容器的时候实现数据的初始化\n     */\n    @PostConstruct\n    public void init(){\n        System.out.println(\"初始化数据\");\n    }\n\n    @Override\n    public List<User> list() {\n        return userMapper.list();\n    }\n\n    /**\n     * 这个注解是对象在IOC容器销毁时执行\n     */\n    @PreDestroy\n    public void destroy(){\n        System.out.println(\"销毁数据\");\n    }\n}\n{% endcodeblock %}\n\n##### 创建com.deployee.controller包\n  + 创建UserController文件\n{% codeblock lang:java %}\npackage com.deployee.controller;\n\n\nimport com.deployee.pojo.User;\nimport com.deployee.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.List;\n\n/**\n *  @RestController : 等同于@Controller和@ResponseBody这两个的功能\n */\n//@RestController\n@Controller\n@RequestMapping(value = \"user\")\npublic class UserController {\n    @Autowired\n    private UserService us = null ;\n\n    /**\n     * 请求数据\n     * @return\n     */\n    @GetMapping(\"list\")\n//    @RequestMapping(value = \"/list\")\n    @ResponseBody\n    public List<User> list(){\n        List<User> list = us.list();\n        System.out.println(\"返回的数据:\"+list);\n        return list ; //返回的是json格式的数据，因为有@ResponseBody这个注解\n    }\n}\n\n{% endcodeblock %}\n\n#### 本地测试\n##### 创建jsp文件\n  + 创建index.jsp文件\n{% codeblock lang:java %}\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %>\n<html>\n<body>\n<h2>Hello World!</h2>\n<jsp:forward page=\"${pageContext.request.contextPath}/user/list.action\"></jsp:forward>\n</body>\n</html>\n{% endcodeblock %}\n  + 进入浏览器测试(输入localhost:8080)\n{% codeblock lang:java %}\n[{\"id\":1,\"password\":\"123456\",\"username\":\"张三\"},{\"id\":2,\"password\":\"12345678\",\"username\":\"李四\"},{\"id\":3,\"password\":\"1876543\",\"username\":\"王五\"}]\n{% endcodeblock %}\n  + 测试成功\n\n#### SSM项目部署到远端服务器\n##### 配置pom文件\n  + 增加一段代码,使得部署到远端服务器后能够像在本地idea里访问一样正常的访问\n{% codeblock lang:xml %}\n    <resources>\n      <resource>\n        <directory>src/main/java</directory>\n        <includes>\n          <include>**/*.xml</include>\n        </includes>\n      </resource>\n      <resource>\n        <directory>src/main/resouces/</directory>\n      </resource>\n    </resources>\n{% endcodeblock %}\n\n##### 编译项目\n  + 使用maven管理项 \n    编译安装target命令\n    ![deployee6](deployee6.png)\n  + 打开idea终端，使用maven命令\n{% codeblock lang:shell %}\nmvn clean  #清理生成的编译项目\nmvn package #生成target项目\nmvn install #编译生成target项目，比package命令更完善\n{% endcodeblock %}\n  + 最终得到项目打包war\n    ![deployee7](deployee7.png)\n##### 复制war包到远端\n  + 复制deployee.war路径\n{% codeblock lang:shell %}\nscp scp /home/share/workspace/deployee/target/deployee.war root@ip address:/usr/local/tomcat/apache-tomcat-8.0.9/webapps\ncd /usr/local/tomcat/apache-tomcat-8.0.9/bin\n./shutdown.sh\n./startup.sh\n{% endcodeblock %}\n\n##### 远端测试\n  + 进入浏览器测试(输入ip address:8080)\n{% codeblock lang:java %}\n[{\"id\":1,\"password\":\"123456\",\"username\":\"张三\"},{\"id\":2,\"password\":\"12345678\",\"username\":\"李四\"},{\"id\":3,\"password\":\"1876543\",\"username\":\"王五\"}]\n{% endcodeblock %}\n  + 测试成功\n","tags":["SSM"],"categories":["SSM"]},{"title":"mysql安装","url":"%2F2019%2F05%2F29%2FMysql%2Fmysql%E5%AE%89%E8%A3%85%2F"},{"title":"mysql普通用户","url":"%2F2019%2F05%2F29%2FMysql%2Fmysql%E5%88%9B%E5%BB%BA%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%2F","content":"\n### mysql环境\n  + 类型\n    mysql5.7版本及以上\n  + 版本问题\n    mysql5.7以上的mysql中的user表里的password字段由authentication_string字段代替 \n### mysql普通用户\n  + 首先，需要用登录root来登录，进行操作\n{% codeblock %}\nmysql -uroot -p \nEnter password: #输入密码，进入root\n{% endcodeblock %}\n  + 之后，就能进行各种骚操作了。\n<!--more-->\n#### 创建普通用户\n  + 首先，添加用户\n{% codeblock %}\n#添加一个能够远程访问的用户\nMySQL [mysql]> create user 'leen'@'%' identified by '111111';\nQuery OK, 0 rows affected (0.044 sec)\n\n#添加一个只能本地访问的用户\nMySQL [mysql]> create user 'rack'@'localhost' identified by '111111';\nQuery OK, 0 rows affected (0.044 sec)\n{% endcodeblock %}\n  + 然后，给新用户授权\n{% codeblock %}\n#授予rack@localhost在*.*(整个mysql)中的所有特权,并将密码改为123456\ngrant all privileges on *.* to 'rack'@'localhost' identified by '123456';\ngrant all privileges on *.* to 'leen'@'%' identified by '123456';\n{% endcodeblock %}\n\n#### 删除普通用户\n{% codeblock %}\ndelete from user where user='rack' and host='%';\n{% endcodeblock %}\n\n","tags":["Mysql"],"categories":["Mysql"]},{"title":"mysql开启远程访问","url":"%2F2019%2F05%2F29%2FMysql%2Fmysql%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%2F","content":"\n### mysql环境\n  + 类型\n    mysql5.7版本及以上\n  + 版本问题\n    mysql5.7以上的mysql中的user表里的password字段由authentication_string字段代替 \n\n### mysql开启远程访问\n\n#### root账户开启远程\n{% codeblock %}\n#为root账户设置远程访问权限\n#123456是重新设置的密码\ngrant all privileges on *.* to 'root'@'%' identified by '123456'; \nflush privileges ; #刷新\n{% endcodeblock %}\n\n#### root用户无法登录\n{% codeblock %}\n\n# 更改配置文件，使得无密码登录\nvim /etc/my.cnf\n#在[mysql]下加入以下语句\nskip-grant-tables=1\n# 更新root密码\nupdate user set authentication_string = password('123456'), password_expired = 'N', password_last_changed = now() where user = 'root';\n# 如果出现错误  \nERROR 1175 (HY000): You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column\n# 使用下面的命令，就能免去错误\nset sql_safe_updates=0;\nflush privileges ;\n{% endcodeblock %}\n","tags":["Mysql"],"categories":["+ Mysql"]},{"title":"redis数据库安装","url":"%2F2019%2F05%2F29%2FRedis%2Fredis%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%2F","content":"\n### redis数据库安装\n#### 下载redis源码包\n  + [下载redis5.0.5](redis/redis-5.0.5.tar.gz)\n#### 解压源码包\ntar -zxvf redis-5.0.5.tar.gz -C /usr/src/\n#### 编译安装\ncd /usr/src/redis-5.0.5/ ; make \ncd src ; make install PREFIX=/usr/local/redis\n"},{"title":"WebService应用4-与Spring整合","url":"%2F2019%2F05%2F28%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FWebService%2FWebService%E5%BA%94%E7%94%A84-%E4%B8%8ESpring%E6%95%B4%E5%90%88%2F","content":"\n### WebService应用4-与Spring整合\n> Spring作为一个万能框架，能够将许多的第三方框架整合到一起\n接续上面几篇，还是以myWebService项目为父项目，将整合的项目作为其中的子项目。整合项目是将上面一篇的client子项目和server子项目与Spring框架进行整合。\n#### Server端整合\n##### 创建webServer子项目\n  + 首先，进入父项目，右键点击父项目名，选择New->Moudle，然后进入以下界面\n  ![webserver1](webClient1.jpg)\n  + 之后，填入子项目名\n  ![webserver2](webServer2.png)\n  + 然后，点击File->Project Structure->Libraies，点击+,然后点击其中的Java项，获得以下界面，点击选中项,导入需要的java库\n  ![webServer3](webServer3.png)\n##### 创建intercepter和server包\n  + 将server项目中的intercepter和server包完整复制过来就行了。\n##### 编辑web.xml文件\n{% codeblock lang:xml %}\n<!DOCTYPE web-app PUBLIC\n \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"\n \"http://java.sun.com/dtd/web-app_2_3.dtd\" >\n\n<web-app>\n  <display-name>Archetype Created Web Application</display-name>\n  <!--配置Spring-->\n  <context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>classpath:bean-cxf.xml</param-value> <!--Spring的配置文件-->\n  </context-param>\n\n  <!--配置监听器-->\n  <listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n  </listener>\n\n  <!--配置CXF的Servlet-->\n  <!--配置自身的拦截器-->\n  <servlet>\n    <servlet-name>CXFServlet</servlet-name> <!--拦截器名-->\n    <servlet-class>org.apache.cxf.transport.servlet.CXFServlet</servlet-class> <!--拦截器使用的类-->\n    <load-on-startup>1</load-on-startup> <!--使得服务与服务器一起启动-->\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>CXFServlet</servlet-name>\n    <url-pattern>/*</url-pattern> <!--拦截器作用的范围-->\n  </servlet-mapping>\n</web-app>\n{% endcodeblock %}\n##### cxf配置文件\n从cxf包中复制出cxf的三个配置文件，分别为：\n  cxf.xml\n  cxf.extension-soap.xml\n  cxf-servlet.xml\n##### Spring配置文件\n  + 创建Spring的配置文件bean-cxf.xml\n  ![webService4](webServer4.png)\n  + 编辑Spring的配置文件bean-cxf.xml\n{% codeblock lang:xml %}\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:jaxws=\"http://cxf.apache.org/jaxws\"\n       xsi:schemaLocation=\"\n    http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd\">\n\n<!--初始化cxf框架中的对象，将cxf的对象加入Spring框架的IOC容器中-->\n\n    <!--导入resources资源文件中的cxf的xml配置文件，-->\n    <import resource=\"classpath:cxf.xml\"/>\n    <import resource=\"classpath:cxf-extension-soap.xml\"/>\n    <import resource=\"classpath:cxf-servlet.xml\"/>\n\n    <!--配置拦截器-->\n    <jaxws:endpoint address=\"http://127.0.0.1:8080/myWebService/rack\" implementor=\"webService.server.UserService\" serviceName=\"userService\">\n    <jaxws:inInterceptors>\n        <!--确定定义的拦截器实例-->\n        <bean class=\"webService.intercepter.ServerIntercepter\"></bean>\n    </jaxws:inInterceptors>\n    </jaxws:endpoint>\n</beans>\n{% endcodeblock %}\n\n##### 更改测试文件\n  + 更改测试类TestApp\n{% codeblock lang:java %}\npackage webService.server;\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n//使用IOC容器来启动\npublic class TestApp {\n    public static void main(String[] args) {\n\n        //获取一个IOC容器实例\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:bean-cxf.xml\");\n        //启动IOC容器实例\n        context.start();\n    }\n}\n{% endcodeblock %}\n##### 最终测试结果\n  + server端成功启动\n{% codeblock %}\n五月 28, 2019 10:23:36 下午 org.springframework.context.support.AbstractApplicationContext prepareRefresh\n信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@51521cc1: startup date [Tue May 28 22:23:36 CST 2019]; root of context hierarchy\n五月 28, 2019 10:23:36 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\n信息: Loading XML bean definitions from class path resource [bean-cxf.xml]\n五月 28, 2019 10:23:37 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\n信息: Loading XML bean definitions from class path resource [cxf.xml]\n五月 28, 2019 10:23:38 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\n信息: Loading XML bean definitions from class path resource [cxf-extension-soap.xml]\n五月 28, 2019 10:23:38 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\n信息: Loading XML bean definitions from class path resource [cxf-servlet.xml]\n五月 28, 2019 10:23:40 下午 org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons\n信息: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@29ca901e: defining beans [cxf,org.apache.cxf.bus.spring.BusWiringBeanFactoryPostProcessor,org.apache.cxf.bus.spring.Jsr250BeanPostProcessor,org.apache.cxf.bus.spring.BusExtensionPostProcessor,org.apache.cxf.binding.soap.SoapBindingFactory,org.apache.cxf.binding.soap.SoapTransportFactory,org.apache.cxf.binding.soap.customEditorConfigurer,org.apache.cxf.jaxws.EndpointImpl--683175349]; root of factory hierarchy\n五月 28, 2019 10:23:41 下午 org.apache.cxf.service.factory.ReflectionServiceFactoryBean buildServiceFromClass\n信息: Creating Service {http://www.springframework.org/schema/beans}userService from class webService.server.IUserService\n五月 28, 2019 10:23:42 下午 org.apache.cxf.endpoint.ServerImpl initDestination\n信息: Setting the server's publish address to be http://127.0.0.1:8080/myWebService/rack\n五月 28, 2019 10:23:42 下午 org.eclipse.jetty.server.Server doStart\n信息: jetty-7.5.4.v20111024\n五月 28, 2019 10:23:43 下午 org.eclipse.jetty.server.AbstractConnector doStart\n信息: Started SelectChannelConnector@127.0.0.1:8080 STARTING\n五月 28, 2019 10:23:43 下午 org.eclipse.jetty.server.handler.ContextHandler startContext\n信息: started o.e.j.s.h.ContextHandler{/myWebService,null}\n{% endcodeblock %}\n#### Client端整合\n##### 创建webClient子项目\n  + 首先，进入父项目，右键点击父项目名，选择New->Moudle，然后进入以下界面\n  ![webclient1](webClient1.jpg)\n  + 之后，填入子项目名\n  ![webclient2](webClient2.jpg)\n  + 然后，点击File->Project Structure->Libraies，点击+,然后点击其中的Java项，获得以下界面，点击选中项,导入需要的java库\n  ![webClient3](webClient3.png)\n##### 创建包\n  + 将client项目中的intercepter和client完整复制过来就行了。\n  + 重新生成server包\n{% codeblock lang:java %}\ncd /home/share/workspace/myWebService/web-Client/src/main/java/\nwsimport -keep http://127.0.0.1:8080/myWebService/rack\\?wsdl\n{% endcodeblock %}\n##### 编辑web.xml文件\n{% codeblock lang:xml %}\n<!DOCTYPE web-app PUBLIC\n \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"\n \"http://java.sun.com/dtd/web-app_2_3.dtd\" >\n\n<web-app>\n  <display-name>Archetype Created Web Application</display-name>\n\n  <!--配置Spring-->\n  <context-param>\n    <param-name>contextConfigLocation</param-name> <!--Spring的本地配置文件-->\n    <param-value>classpath:bean-cxf.xml</param-value> <!-- 配置文件路径 -->\n  </context-param>\n  \n  <!--监听器-->\n  <listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n  </listener>\n\n</web-app>\n{% endcodeblock %}\n##### cxf配置文件\n从cxf包中复制出cxf的三个配置文件到resources资源目录中，分别为：\n  cxf.xml\n  cxf.extension-soap.xml\n  cxf-servlet.xml\n##### Spring配置文件\n  + 创建Spring的配置文件bean-cxf.xml\n  + 编辑Spring的配置文件bean-cxf.xml\n{% codeblock lang:xml %}\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:jaxws=\"http://cxf.apache.org/jaxws\"\n       xsi:schemaLocation=\"\n    http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd\">\n\n<!--初始化cxf框架中的对象，将cxf的对象加入Spring框架的IOC容器中-->\n\n    <!--配置拦截器-->\n    <jaxws:client address=\"http://127.0.0.1:8080/myWebService/rack?wsdl\" serviceClass=\"org.springframework.schema.beans.IUserService\" name=\"userService\">\n        <!--配置客户端的出拦截器-->\n        <jaxws:outInterceptors>\n            <bean class=\"webservice.intercepter.ClientIntercepter\">\n                <!--给有参构造器赋值-->\n                <constructor-arg name=\"userName\" value=\"rack\"></constructor-arg>\n                <constructor-arg name=\"password\" value=\"123456\"></constructor-arg>\n            </bean>\n        </jaxws:outInterceptors>\n    </jaxws:client>\n</beans>\n{% endcodeblock %}\n\n##### 更改测试类\n  + 更改client端测试类TestApp\n{% codeblock lang:java %}\npackage webservice.client;\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport org.springframework.schema.beans.IUserService;\n\npublic class TestApp {\n    public static void main(String[] args) {\n        //加载xml配置文件，获取Spring的IOC容器\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:bean-cxf.xml\");\n        //通过对接口的反射，获取接口对应的实现的对象\n        IUserService userService = context.getBean(IUserService.class);\n        //可以使用获取的对象调用方法\n        String str = userService.getStr(\"hello\");\n        System.out.println(str);\n    }\n}\n\n{% endcodeblock %}\n##### 最终测试结果\n{% codeblock lang %}\n五月 29, 2019 12:25:48 下午 org.springframework.context.support.AbstractApplicationContext prepareRefresh\n信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@51521cc1: startup date [Wed May 29 12:25:48 CST 2019]; root of context hierarchy\n五月 29, 2019 12:25:48 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\n信息: Loading XML bean definitions from class path resource [bean-cxf.xml]\n五月 29, 2019 12:25:49 下午 org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons\n信息: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@73ad2d6: defining beans [userService.proxyFactory,userService]; root of factory hierarchy\n五月 29, 2019 12:25:50 下午 org.apache.cxf.service.factory.ReflectionServiceFactoryBean buildServiceFromClass\n信息: Creating Service {http://server.webService/}IUserServiceService from class org.springframework.schema.beans.IUserService\n加工后的数据：hello\n{% endcodeblock %}\n","tags":["WebService"],"categories":["WebService"]},{"title":"WebService应用3-getWeather","url":"%2F2019%2F05%2F27%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FWebService%2FWebService%E5%BA%94%E7%94%A83-getWeather%2F"},{"title":"WebService应用2-拦截器","url":"%2F2019%2F05%2F27%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FWebService%2FWebService%E5%BA%94%E7%94%A82-%E6%8B%A6%E6%88%AA%E5%99%A8%2F","content":"\n### WebService应用2-拦截器\n  + 对[WebService应用1](https://rack-leen.github.io/2019/05/27/Java/WebService/WebService%E5%BA%94%E7%94%A81/)的强化\n\n#### 创建server拦截器\n##### 创建包\n  + 创建server的拦截器包com.rack.webService.intercepter\n<!-- more -->\n##### 创建server拦截器类\n  + 创建类ServerIntercepter\n{% codeblock lang:java %}\npackage com.rack.webService.intercepter;\n\nimport org.apache.cxf.binding.soap.SoapMessage;\nimport org.apache.cxf.binding.soap.interceptor.AbstractSoapInterceptor;\nimport org.apache.cxf.headers.Header;\nimport org.apache.cxf.interceptor.Fault;\nimport org.apache.cxf.phase.Phase;\nimport org.w3c.dom.Element;\n\nimport javax.xml.namespace.QName;\n\n/**\n * 服务器端的拦截器\n * 这个拦截器是用来拦截客户端发来的用户信息，\n * 如果用户信息与服务器中存储的用户信息不符则进行拦截\n * 如果相符合则通过\n */\n\npublic class ServerIntercepter extends AbstractSoapInterceptor {\n    private static final String USER_NAME = \"rack\";\n    private static final String PASSWORD = \"111111\";\n\n    //协议化数据之前进行拦截\n    public ServerIntercepter() {\n        super(Phase.PRE_PROTOCOL);\n    }\n\n    @Override\n    public void handleMessage(SoapMessage soapMessage) throws Fault {\n        //1. 取出消息头(消息头名为节点名)\n        Header user = soapMessage.getHeader(new QName(\"user\"));\n        //从节点中获取元素\n        Element element = (Element) user.getObject();\n        String userName = element.getElementsByTagName(\"userName\").item(0).getTextContent();\n        String password = element.getElementsByTagName(\"password\").item(0).getTextContent();\n        if (USER_NAME.equals(userName) && PASSWORD.equals(password)) {\n            //通过则返回\n            return;\n        }else{\n            //如果与服务端的信息不匹配，则抛出异常\n            throw new Fault(new RuntimeException(\"输入信息不正确...\"));\n        }\n\n    }\n}\n{% endcodeblock %}\n\n##### 更改server测试类\n  + 更改测试类TestApp\n{% codeblock lang:java %}\npackage com.rack.webService.server;\n\nimport com.rack.webService.intercepter.ServerIntercepter;\nimport org.apache.cxf.interceptor.Interceptor;\nimport org.apache.cxf.interceptor.LoggingInInterceptor;\nimport org.apache.cxf.jaxws.EndpointImpl;\nimport org.apache.cxf.message.Message;\n\nimport javax.xml.ws.Endpoint;\nimport java.util.List;\n\npublic class TestApp {\n    public static final String PATH=\"http://127.0.0.1:8080/myWebService/rack\";\n    public static void main(String[] args) {\n        /**\n         * 这个静态方法是用来发布webservice的\n         * PATH变量是用来存储需要发布的路径\n         * service是需要应用的对象\n         */\n        UserService service = new UserService();\n        //获取发布实例\n        EndpointImpl publish = (EndpointImpl)Endpoint.publish(PATH, service);\n        //从发布实例中获取入服务器的拦截器\n        List<Interceptor<? extends Message>> inInterceptors = publish.getInInterceptors();\n        //将日志拦截器添加入拦截器中\n        inInterceptors.add(new LoggingInInterceptor());\n        //添加自定义拦截器\n        inInterceptors.add(new ServerIntercepter());\n        System.out.println(\"发布成功\");\n    }\n}\n{% endcodeblock %}\n#### 创建client拦截器\n##### 创建client拦截器类\n  + 创建类ClientIntercepter\n{% codeblock lang:java %}\npackage com.rack.webservice.intercepter;\n\nimport org.apache.cxf.binding.soap.SoapMessage;\nimport org.apache.cxf.binding.soap.interceptor.AbstractSoapInterceptor;\nimport org.apache.cxf.headers.Header;\nimport org.apache.cxf.interceptor.Fault;\nimport org.apache.cxf.phase.Phase;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.util.List;\n\n/**\n * 客户端的拦截器\n * 这个拦截器是用来将输入的用户信息放入wsdl文档中\n */\npublic class ClientIntercepter extends AbstractSoapInterceptor {\n\n    private String userName ;\n    private String password ;\n\n    //在数据进行协议化之前拦截\n    public ClientIntercepter(String userName,String password){\n        super(Phase.PRE_PROTOCOL);\n        this.userName = userName ;\n        this.password = password ;\n    }\n\n    //将输入的用户信息加入构建文档wsdl\n    @Override\n    public void handleMessage(SoapMessage soapMessage) throws Fault {\n\n        try {\n            //1. 从文档构建者工厂中获取一个文档构建者工厂实例\n            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            //2. 从文档构建者工厂中获取一个文档构建者实例\n            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n            //3. 从文档构建者对象中获取一个文档实例\n            Document document = documentBuilder.newDocument();\n            //4. 创建一个user元素\n            Element userElement = document.createElement(\"user\");\n            //5. 创建一个userName元素并为其设置值\n            Element userNameElement = document.createElement(\"userName\");\n            userNameElement.setTextContent(userName);\n            //6. 创建一个password元素并为其设置值\n            Element passwordElement = document.createElement(\"password\");\n            passwordElement.setTextContent(password);\n\n            //7. 将元素userNameElement和passwordElement加入userElement中\n            userElement.appendChild(userNameElement);\n            userElement.appendChild(passwordElement);\n\n            //8. 将wsdl文档中的元素存放到headers集合中\n            List<Header> headers = soapMessage.getHeaders();\n            //9. 将新的节点作为一个对象加入集合中，并为其命名\n            headers.add(new Header(new QName(\"rack\"),userElement));\n\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        } finally {\n        }\n    }\n}\n{% endcodeblock %}\n\n##### 更改client测试类\n  + 更改测试类TestApp\n{% codeblock lang:java %}\npackage com.rack.webservice.client;\n\nimport com.rack.webservice.intercepter.ClientIntercepter;\nimport com.rack.webservice.server.UserService;\nimport com.rack.webservice.server.UserServiceService;\nimport org.apache.cxf.endpoint.Client;\nimport org.apache.cxf.frontend.ClientProxy;\nimport org.apache.cxf.interceptor.Interceptor;\nimport org.apache.cxf.interceptor.LoggingOutInterceptor;\nimport org.apache.cxf.message.Message;\n\nimport java.util.List;\n\npublic class TestApp {\n    public static void main(String[] args) {\n        //创建代理类对象，代理类的类名在wsdl文档的最后一个节点server中的name属性里\n        UserServiceService userServiceService = new UserServiceService();\n        //通过代理对象获取到userService对象(真正的被代理对象)\n        UserService userServicePort = userServiceService.getUserServicePort();\n        //生成客户端的代理对象，使用代理对象进行调用(代理对象可以使用代理工具进行调用，用客户端对象有诸多限制)\n        Client client = ClientProxy.getClient(userServicePort);\n        //获取所有的出拦截器\n        List<Interceptor<? extends Message>> outInterceptors = client.getOutInterceptors();\n        //添加日志拦截器\n        outInterceptors.add(new LoggingOutInterceptor());\n        //添加自定义拦截器\n        outInterceptors.add(new ClientIntercepter(\"rack\",\"111111\"));\n        //被代理对象调用方法\n        String str = userServicePort.getStr(\"rack\");\n        System.out.println(str);\n    }\n}\n\n{% endcodeblock %}\n\n","tags":["WebService"],"categories":["WebService"]},{"title":"WebService应用1","url":"%2F2019%2F05%2F27%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FWebService%2FWebService%E5%BA%94%E7%94%A81%2F","content":"\n### WebService应用1\n\n#### 创建父项目myWebService\n  + 首先，进入New Project页面,选择Maven项创建Maven项目，再勾选Create from archetype选项，选择勾选项\n    ![创建父项目](创建父项目.png)\n  + 然后，进入下图这个页面，填入需要创建父项目的项目发布id\n    ![创建父项目1](创建父项目1.png)\n  + 之后，进入下图页面，选择自己的maven的settings.xml和maven仓库,下面小窗口中name填入archetypeCatalog,value中填入internal(local在本地库中搜索，internal在设置的网络仓库中搜索),这样会让项目创建的快一点，不需要等几分钟。\n    ![创建父项目2](创建父项目2.png)\n  + 接着，进入下一个页面，这个页面Project format需要设置为.idea\n    ![创建父目录3](创建父目录3.png)\n  + 最终点击finish完成项目创建\n<!-- more -->\n#### 创建子项目server\n  + 首先，右键点击项目名，选择new选项的Moudle，进入下图这个页面。之后选择Maven，选中Create from archetype,然后选中勾选项\n    ![创建子项目server](创建子项目server.png)\n  + 然后，进入下图页面，填入需要创建的子项目的项目发布id\n    ![创建子项目server1](创建子项目server1.png)\n  + 之后的流程与上面父项目的一样\n##### 创建包\n  + 在server子项目中创建一个包com.rack.webService.server\n##### 创建接口IUserService\n{% codeblock lang:java %}\npackage com.rack.webService.server;\nimport javax.jws.WebMethod;\nimport javax.jws.WebService;\n@WebService //这个注解是用来标明这个类是WebService类\npublic interface IUserService {\n    @WebMethod ////这个注解是用来标明这个方法是WebService方法\n    String getStr(String str);\n}\n{% endcodeblock %}\n##### 创建实现类UserService\n{% codeblock lang:java %}\npackage com.rack.webService.server;\n\nimport javax.jws.WebMethod;\nimport javax.jws.WebService;\n\n@WebService\npublic class UserService implements IUserService {\n    @WebMethod\n    @Override\n    public String getStr(String str) {\n        System.out.println(\"加工后的数据：\"+str);\n        return \"加工后的数据：\"+str;\n    }\n}\n{% endcodeblock %}\n##### 创建测试类TestApp\n{% codeblock lang:java %}\npackage com.rack.webService.server;\nimport javax.xml.ws.Endpoint;\npublic class TestApp {\n    public static final String PATH=\"http://127.0.0.1:8080/myWebService/rack\";\n    public static void main(String[] args) {\n        /**\n         * 这个静态方法是用来发布webservice的\n         * PATH变量是用来存储需要发布的路径\n         * service是需要应用的对象\n         */\n        UserService service = new UserService();\n        Endpoint.publish(PATH,service);\n        System.out.println(\"发布成功\");\n    }\n}\n{% endcodeblock %}\n\n#### 创建子项目client\n  + 首先，右键点击项目名，选择new选项的Moudle，进入下图这个页面。之后选择Maven，选中Create from archetype,然后选中勾选项\n    ![创建子项目client](创建子项目client.png)\n  + 然后，进入下图页面，填入需要创建的子项目的项目发布id\n    ![创建子项目client2](创建子项目client1.png)\n  + 之后的流程与上面父项目的一样\n##### 自动生成包\n  + 使用命令自动生成包com.rack.webservice.server\n{% codeblock lang:shell %}\ncd /home/share/workspace/myWebService/client/src/main/java #进入client的源码目录\nwsimport -keep http://127.0.0.1:8080/myWebService/rack?wsdl #使用jdk自带的wsimport命令在当前目录自动生成服务端的代码\n{% endcodeblock %}\n##### 创建包\n  + 在client项目中创建包com.rack.webservice.client\n##### 创建测试类TestApp\n{% codeblock lang:java %}\npackage com.rack.webservice.client;\n\nimport com.rack.webservice.server.UserService;\nimport com.rack.webservice.server.UserServiceService;\n\npublic class TestApp {\n    public static void main(String[] args) {\n        //创建代理类对象，代理类的类名在wsdl文档的最后一个节点server中的name属性里\n        UserServiceService userServiceService = new UserServiceService();\n        //通过代理对象获取到userService对象(真正的被代理对象)\n        UserService userServicePort = userServiceService.getUserServicePort();\n        //被代理对象调用方法\n        String str = userServicePort.getStr(\"rack\");\n        System.out.println(str);\n    }\n}\n{% endcodeblock %}\n\n#### 导入库\n> 这个项目需要导入cxf框架\n##### CXF\n  + 介绍\n    Apache CXF 是一个开源的 Services 框架,用于WebService，支持soap协议，可以和spring无缝集成。\n  + File->Project Structure->Libraries，进入下图页面\n    ![cxf1](cxf1.png)\n  + 点击\"+\",选择Java,之后选择你的cxf目录，再选择需要用到的子项目，这样就能将cxf加入项目(需要用到的项目就加)\n    ![cxf2]{cxf2.png}\n#### 测试myWebService应用1\n##### 运行server\n运行server中的TestApp\n{% codeblock lang:java %}\n发布成功\n{% endcodeblock %}\n\n##### 运行client\n运行client的TestApp\n{% codeblock lang:java %}\n加工后的数据：rack\n{% endcodeblock %}\n\n","tags":["WebService"],"categories":["WebService"]},{"title":"WebService初识","url":"%2F2019%2F05%2F27%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FWebService%2FWebService%E5%88%9D%E8%AF%86%2F"},{"title":"数据结构C语言版","url":"%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88%2F"},{"title":"Linux下texlive2019安装笔记","url":"%2F2019%2F05%2F25%2FLatex%2F%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%2FLinux%E4%B8%8Btexlive2019%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0%2F","content":"\n### Linux下texlive2019安装笔记\n\n#### 准备\n  + 下载镜像\n    从中科大镜像站下载texlive2019的iso镜像,这里使用的是axel命令行工具进行下载。\n{% codeblock lang:shell %}\naxel -n 12 \"http://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/texlive2019-20190410.iso\" -o texlive2019-20190410.iso\n{% endcodeblock %}\n  + 挂载镜像\n{% codeblock lang:shell %}\nsudo mount ~/texlive2019-20190410.iso /mnt #将镜像挂载到mnt目录\ncd /mnt/\n./install_tl  #执行安装程序\n{% endcodeblock %}\n<!-- more -->\n#### 安装流程\n  1. 执行sudo ./install_tl进入初始化界面\n{% codeblock lang:shell %}\nLoading ./tlpkg/texlive.tlpdb\nInstalling TeX Live 2019 from: . (verified)\nPlatform: x86_64-linux => 'GNU/Linux on x86_64'\nDistribution: inst (compressed)\nDirectory for temporary files: /tmp/nxPvl2SvBX\n======================> TeX Live installation procedure <=====================\n\n======>   Letters/digits in <angle brackets> indicate   <=======\n======>   menu items for actions or customizations      <=======\n\n Detected platform: GNU/Linux on x86_64\n \n <B> set binary platforms: 1 out of 5 #安装平台\n\n <S> set installation scheme: scheme-full #安装模式\n\n <C> set installation collections: #安装选项\n     40 collections out of 41, disk space required: 5845 MB\n\n <D> set directories:  #安装目录\n   TEXDIR (the main TeX directory):\n     !! default location: /usr/local/texlive/2019\n     !! is not writable or not allowed, please select a different one!\n   TEXMFLOCAL (directory for site-wide local files):\n     /usr/local/texlive/texmf-local\n   TEXMFSYSVAR (directory for variable and automatically generated data):\n     /usr/local/texlive/2019/texmf-var\n   TEXMFSYSCONFIG (directory for local config):\n     /usr/local/texlive/2019/texmf-config\n   TEXMFVAR (personal directory for variable and automatically generated data):\n     ~/.texlive2019/texmf-var\n   TEXMFCONFIG (personal directory for local config):\n     ~/.texlive2019/texmf-config\n   TEXMFHOME (directory for user-specific files):\n     ~/texmf\n\n <O> options: #选项\n   [ ] use letter size instead of A4 by default\n   [X] allow execution of restricted list of programs via \\write18\n   [X] create all format files\n   [X] install macro/font doc tree\n   [X] install macro/font source tree\n   [ ] create symlinks to standard directories\n   [X] after install, set CTAN as source for package updates\n\n <V> set up for portable installation\n\nActions:\n <I> start installation to hard disk\n <P> save installation profile to 'texlive.profile' and exit\n <H> help\n <Q> quit\n\nEnter command: O #这里输入选项O,进入选项界面，选择自己需要的模块\n{% endcodeblock %}\n\n  2. 输入选项O,勾选必要选项\n{% codeblock lang:shell %}\n===============================================================================\nOptions customization:\n\n <P> use letter size instead of A4 by default: [ ] #使用信纸尺寸而不是默认的A4纸\n <E> execution of restricted list of programs: [X]\n <F> create all format files:                  [X] #创建所有的格式文件\n <D> install font/macro doc tree:              [X] #安装字体或者宏的文档树\n <S> install font/macro source tree:           [X] #安装字体或者宏的源码树\n <L> create symlinks in standard directories:  [ ] #在标准目录创建符号连接\n            binaries to: \n            manpages to: \n                info to: \n <Y> after install, set CTAN as source for package updates: [X] #安装之后，设置CTAN作为包更新\n\nActions: (disk space required: 5845 MB)\n <R> return to main menu\n <Q> quit\n\nEnter command: L\n{% endcodeblock %}\n\n  3. 敲击Enter键，使用默认路径\n{% codeblock lang:shell %}\nNew value for binary directory [/usr/local/bin]: #二进制目录\nNew value for man directory    [/usr/local/man]: #man帮助手册目录\nNew value for info directory   [/usr/local/info]:#info手册目录\n{% endcodeblock %}\n\n\n  4. 重新回到选项界面，并将L选项选中(用X作为选中标记)\n{% codeblock lang:shell %}\n===============================================================================\nOptions customization:\n\n <P> use letter size instead of A4 by default: [ ]\n <E> execution of restricted list of programs: [X]\n <F> create all format files:                  [X]\n <D> install font/macro doc tree:              [X]\n <S> install font/macro source tree:           [X]\n <L> create symlinks in standard directories:  [X]\n            binaries to: /usr/local/bin\n            manpages to: /usr/local/man\n                info to: /usr/local/info\n <Y> after install, set CTAN as source for package updates: [X]\n\nActions: (disk space required: 5845 MB)\n <R> return to main menu\n <Q> quit\n\nEnter command: R \n{% endcodeblock %}\n\n  5. 返回初始化界面(正式进行安装)\n{% codeblock lang:shell %}\n <O> options:\n   [ ] use letter size instead of A4 by default\n   [X] allow execution of restricted list of programs via \\write18\n   [X] create all format files\n   [X] install macro/font doc tree\n   [X] install macro/font source tree\n   [X] create symlinks to standard directories\n   [X] after install, set CTAN as source for package updates\n\n <V> set up for portable installation\n\nActions:\n <I> start installation to hard disk\n <P> save installation profile to 'texlive.profile' and exit\n <H> help\n <Q> quit\n\nEnter command: I\n{% endcodeblock %}\n\n  6. 选中I选项开始正式安装到硬盘\n{% codeblock lang:shell %}\n#大约需要半个小时的时间\nEnter command: I\nInstalling to: /usr/local/texlive/2019\nInstalling [0001/3768, time/total: ??:??/??:??]: 12many [376k]\nInstalling [0002/3768, time/total: 00:01/02:07:26]: 2up [66k]\nInstalling [0003/3768, time/total: 00:01/01:48:31]: Asana-Math [482k]\nInstalling [0004/3768, time/total: 00:01/51:50]: ESIEEcv [137k]\nInstalling [0005/3768, time/total: 00:01/45:09]: FAQ-en [4971k]\nInstalling [0006/3768, time/total: 00:02/15:51]: GS1 [1125k]\nInstalling [0007/3768, time/total: 00:03/20:02]: HA-prosper [266k]\nInstalling [0008/3768, time/total: 00:03/19:19]: IEEEconf [188k]\nInstalling [0009/3768, time/total: 00:03/18:51]: IEEEtran [1323k]\nInstalling [0010/3768, time/total: 00:03/16:03]: MemoirChapStyles [739k]\nInstalling [0011/3768, time/total: 00:04/19:46]: SIstyle [338k]\nInstalling [0012/3768, time/total: 00:04/19:06]: SIunits [284k]\nInstalling [0013/3768, time/total: 00:04/18:35]: Tabbing [217k]\nInstalling [0014/3768, time/total: 00:04/18:12]: Type1fonts [516k]\nInstalling [0015/3768, time/total: 00:05/21:41]: a0poster [119k]\nInstalling [0016/3768, time/total: 00:05/21:27]: a2ping [69k]\nInstalling [0017/3768, time/total: 00:05/21:19]: a2ping.x86_64-linux [1k]\nInstalling [0018/3768, time/total: 00:05/21:19]: a4wide [133k]\n{% endcodeblock %}\n\n  7. 安装完成\n{% codeblock lang:shell %}\nWelcome to TeX Live!\n\n\nSee /usr/local/texlive/2019/index.html for links to documentation.\nThe TeX Live web site (https://tug.org/texlive/) contains any updates and\ncorrections. TeX Live is a joint project of the TeX user groups around the\nworld; please consider supporting it by joining the group best for you. The\nlist of groups is available on the web at https://tug.org/usergroups.html.\nLogfile: /usr/local/texlive/2019/install-tl.log\n{% endcodeblock %}\n\n#### 配置中文环境\n  1. 设置更新源和texlive字体\n{% codeblock lang:shell %}\n#将texlive自带的字体配置放入系统字体配置中，使得系统能使用texlive的系统配置\nsudo cp -r /usr/local/texlive/2019/texmf-var/fonts/conf/texlive-fontconfig.conf /etc/fonts/conf.d/09-textlive.conf\nsudo fc-cache -fsv\n#设置CTAN的更新源，这里选择的是中科大的更新源\nsudo tlmgr option repository https://mirrors.tuna.ustc.edu.cn/CTAN/systems/texlive/tlnet\nsudo tlmgr update --self --all\n{% endcodeblock %}\n  2. 加入windows中文字体\n    [下载字体](fonts.tar.gz)\n    [下载工具](gbkfonts-linux-0.3.tar.gz)\n{% codeblock lang:shell %}\ntar -zxvf fonts.tar.gz #解压字体\ntar -zxvf gbkfonts-linux-0.3.tar.gz #解压字体工具\n./gbkfonts simsun.ttf song\n./gbkfonts simkai.ttf kai\n./gbkfonts simhei.ttf hei\n./gbkfonts SIMLI.TTF  li\n\n#更新系统搜索路径\nmktexlsr\n{% endcodeblock %}\n  3. picins[下载](picins.zip)\n    如果不安装这个包，在用xelatex编译中文时会出现错误。\n{% codeblock lang:shell %}\nmkdir picins ; mv picins.zip picins\ncd picins ; unzip picins.zip\ncp -r picins cd /usr/local/texlive/2019/texmf-dist/tex/latex/\nmktexlsr\n{% endcodeblock %}\n\n#### 出现的一些问题\n##### 问题1 \n  + 问题:\n    使用xelatex编译生成的pdf后，用evince查看pdf无法显示中文\n  + 解决:xeCJK+xelatex\n{% codeblock lang:tex %}\n%%=====================================================================================\n%%\n%%       Filename:  1.tex\n%%\n%%    Description:  \n%%\n%%        Version:  1.0\n%%        Created:  2019年05月26日\n%%       Revision:  none\n%%\n%%         Author:  YOUR NAME (), \n%%   Organization:  \n%%      Copyright:  Copyright (c) 2019, YOUR NAME\n%%\n%%          Notes:  \n%%\n%%=====================================================================================\n\\documentclass[UTF8]{article}\n%1.若设置ctexart是使用ctex的article。\n%2.代码意思为：文本类下的article(p.s:It also include report,slides(PPT)&book,)使用[UTF8]编码\n%3.代码调用Article Templates\n%4.[]内为补充项，{}内为选定项，[]内可以设定全局字体大小如15.75pt中文三号,10pt(default);a4paper,letterpaper(default);twoside(book默认),oneside(article,report默认)；one column,two column(将文本分为两列排版)。\n%5.这里既是设置[utf8]编码也需要重新将txt另存为UTF8编码才管用\n\n%%%%%%%%%%宏包我使用的%%%%%%%%%%\n\\usepackage{xeCJK}\n%1.google说XeLaTeX+xeCJK是最好的中文排版解决方案\n%2.xeCJK 是一个在 XeTeX 引擎下处理CH文字断行、标点调整、字体选择的一个基础性宏包\n\\usepackage{fontspec,xunicode,xltxtra}\n%1.fontspec允许本地字体支持，xunicode(p.s我老读成虚拟code···\n%2.其实是x-unicode)扩展统一编码，xltxtra is means of “XeLaTeX Extras”\n%3.CTAN上解释是很多他的功能被fontspec容纳，但是它存在的意义是为LaTeX使用XeTeX提供后向支持,配合使用fontspec，metalogo，realscript。\n\\usepackage{geometry}%允许页面边距的调整\n\\usepackage{lscape}%允许设置页面horizontal\n\\usepackage{indentfirst}%允许设置段首锁进\n\n\n%%%%%%%%%%paragraph%%%%%%%%%%\n\\usepackage[raggedleft]{titlesec}%默认左对齐，也可以设置center or raggedright\n\\usepackage{indentfirst}%段首缩进需要的宏包\n\\setlength{\\parindent}{2em}%设置段首缩进两个汉字\n\\setlength{\\parskip}{1em}%paragraph skip,调整的是段落间距离\n\\renewcommand{\\baselinestretch}{1.8}%重新定义行间距为单倍的1.28倍\n\\setlength{\\parindent}{2em}%设置每个段首缩进两个字节\n%%%%%%%%%%pageSetting%%%%%%%%%%\n\\geometry{left=3.0cm,right=2.5cm,top=2.8cm,bottom=2.5cm}\n\\begin{document}\n\\newgeometry{left=2.0cm,right=2.0cm,top=2.0cm,bottom=2.0cm}%重新定义本页页面\n\\begin{center}%居中环境\n吾皇无双，武侯韬略\n\\clearpage%另起一页\n\n\\begin{landscape}%使当下页面为横向页面\n\\begin{center}\n天下太平，万世无疆\n\\end{center}\n\\end{landscape}\n\\end{center}\n\\restoregeometry%恢复原先的页面设置\n\\end{document}\n{% endcodeblock %}\n","tags":["Latex"],"categories":["安装和配置"]},{"title":"二叉树遍历","url":"%2F2019%2F05%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E8%AE%B0%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%2F","content":"\n### 二叉树遍历\n> 二叉树遍历是沿着某条路径，依次对每个节点均做一次且仅做一次访问。\n二叉树遍历按照节点访问顺序分为前序遍历、中序遍历和后序遍历。\n#### 前序遍历\n##### 访问方式\n按照根节点->左子树->右子树的方式访问二叉树。\n![前序遍历](二叉树遍历/前序遍历.png)\n##### 理解\n  1. 首先访问根节点A\n  2. 之后访问根节点的左子树的B节点\n  3. 以B节点为根，访问B节点的左边节点D，D节点已经是最末节点\n  4. 之后访问B节点的右边节点F\n  5. 然后以节点F为根，首先访问F节点的左边节点E，E节点已经为最末节点\n  6. 并且F节点没有右边节点，这时，二叉树的左子树访问完毕\n  7. 开始访问二叉树的右子树的C节点\n  8. 节点C有左节点G，首先访问左节点G\n  9. G没有左节点，却有右节点，因此访问G节点的右边节点H\n  10. 节点H已经是最末节点，C节点的左子树访问完毕\n  11. 开始访问C节点的右子树上的节点I\n  12. 节点I没有任何子树，因此I节点是末端节点\n  13. 至此，整个二叉树的节点访问完毕\n前序遍历结果：A->B->D->F->E->C->G->H->I\n#### 中序遍历\n##### 访问方式\n按照左子树->根节点->右子树的方式访问二叉树。\n![中序遍历](二叉树遍历/中序遍历.png)\n##### 理解\n  1. 首先访问左子树，从左子树的最左端D节点开始\n  2. 由于D节点没有子节点，因此D节点回溯到D的父节点B\n  3. 从B节点的右子树的最左端E开始\n  4. E节点访问父节点F,此时，二叉树的左子树访问完毕\n  5. 开始访问二叉树的根节点A\n  6. 开始访问二叉树的右子树，从右子树的最左端G开始\n  7. G有一个子节点H，首先访问H\n  8. G访问完子节点后开始回溯到父节点C\n  9. C节点有右边节点I\n  10. I没有任何子节点，此时，整个二叉树访问完毕。\n中序遍历的结果：D->B->E->F->A->G->H->C->I\n由此可知，中序遍历是从左到右遍历的，计算中序遍历有简单直观的投影法\n![中序投影法](二叉树遍历/中序投影法.jpg)\n#### 后序遍历\n##### 访问方式\n按照左子树->右子树->根节点的方式访问二叉树。\n![后序遍历](二叉树遍历/后序遍历.png)\n##### 理解\n  1. 从左子树的最左端D节点开始访问，D节点的父节点是B节点\n  2. 之后从左子树的最右端E节点访问，E节点的父节点是F节点\n  3. E节点已经是最右端了，因此开始访问E节点的父节点F节点\n  4. F节点也已经是最右端节点，并且与D节点有同一个父节点B\n  5. 因此，最终访问父节点B，B节点的父节点A是整个二叉树的根节点，需要最后访问\n  6. 左子树访问完毕，开始访问右子树。从右子树的最左端H节点开始访问\n  7. H节点没有子节点，因此访问父节点G\n  8. G节点的子节点访问完后，开始访问其父节点C的右子树的节点I\n  9. I节点没有子节点，因此可以最终访问父节点C\n  10. 这时二叉树的右子树访问完毕，并且左子树也访问完毕，最终访问根节点A\n后序遍历的结果：D->E->F->B->H->G->I->C->A\n\n#### 结论\n由以上二叉树访问流程可知，整个二叉树的遍历就是一个递归的过程。\n","tags":["二叉树遍历"],"categories":["二叉树遍历"]},{"title":"二叉树","url":"%2F2019%2F05%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E8%AE%B0%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F"},{"title":"数据结构杂记","url":"%2F2019%2F05%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E8%AE%B0%2F"},{"title":"解释器模式","url":"%2F2019%2F05%2F19%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%2F","content":"\n## 解释器模式\n\n### 定义\n> Given a language,define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language\n> 给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。\n\n### 解释器模式示意图\n![解释器模式](解释器模式.png)\n\n### 流程\n  1. 定义一个总的抽象表达式类，是所有表达式的父类。表达式又分为变量表达式和符号表达式。\n  2. 变量表达式需要输入公式变量与数字的映射关系，通过映射关系用公式变量取出对应的具体数字，将具体数字套入公式。\n  3. 抽象符号表达式类是所有符号运算类的父类，符号运算包括加减乘除的运算规则。\n  4. 通过客户端提供公式以及公式变量与数字的映射关系，将这两个输入计算器对象中，按多态性来根据公式符号选择需要的符号解释器，将公式变量与数字的映射关系输入变量解释器，将对应的数字套入结果表达式中，获取最终结果。\n\n### 代码实现\n#### 表达式\n  1. 抽象表达式Expression\n```Java\npackage org.example.interpreter;\n\nimport java.util.HashMap;\n\n/**\n * 抽象表达式，用来组合不同种类的解释器，形成一个表达式。\n * 每种解释器就是一个算术因子，是加减乘除需要的算术因子。\n */\npublic abstract class Expression {\n    /**\n     * @param var String是表达式中的值，Integer是表达式中值的索引值\n     * @return 返回表达式计算出的值\n     */\n    public abstract int interpreter(HashMap<String , Integer> var);\n}\n```\n  2. 变量表达式VarExpression\n```Java\npackage org.example.interpreter;\n\nimport java.util.HashMap;\n\npublic class VarExpression extends Expression {\n    private String key ;\n\n    public VarExpression(String key){\n        this.key = key ;\n    }\n    /**\n     * 用来从输入的变量中获取变量在表达式中的位置\n     * @param var String是表达式中的值，Integer是表达式中值的索引值\n     * @return\n     */\n    @Override\n    public int interpreter(HashMap<String, Integer> var) {\n        return var.get(key);\n    }\n}\n```\n  3. 抽象符号表达式\n```Java\npackage org.example.interpreter;\n\nimport java.util.HashMap;\n\n/**\n * 符号解释器，用来解释表达式中的运算符号\n */\npublic abstract class SymbolExpression extends Expression {\n    protected Expression left ;\n    protected Expression right ;\n\n    public SymbolExpression(Expression left , Expression right){\n        this.left = left ;\n        this.right = right ;\n    }\n}\n```\n  4. 加法表达式\n```Java\npackage org.example.interpreter;\n\nimport java.util.HashMap;\n\npublic class AddExpression extends SymbolExpression {\n    /**\n     * 从抽象符号表达式中继承计算的左值和右值\n     * @param left\n     * @param right\n     */\n    public AddExpression(Expression left, Expression right) {\n        super(left, right);\n    }\n\n    @Override\n    public int interpreter(HashMap<String, Integer> var) {\n        return super.left.interpreter(var) + super.right.interpreter(var);\n    }\n}\n```\n  5. 减法表达式\n```Java\npackage org.example.interpreter;\n\nimport java.util.HashMap;\n\n/**\n * 减法解释器\n */\npublic class SubExpression extends SymbolExpression{\n\n    /**\n     * 从抽象符号表达式中继承计算的左值和右值\n     * @param left\n     * @param right\n     */\n    public SubExpression(Expression left, Expression right) {\n        super(left, right);\n    }\n\n    @Override\n    public int interpreter(HashMap<String, Integer> var) {\n        return super.left.interpreter(var) - super.right.interpreter(var);\n    }\n}\n```\n  5. 乘法表达式\n```Java\npackage org.example.interpreter;\n\nimport java.util.HashMap;\n\n/**\n * 乘法解释器\n */\npublic class MulExpression extends SymbolExpression {\n\n    /**\n     * 从抽象符号表达式中继承计算的左值和右值\n     * @param left\n     * @param right\n     */\n    public MulExpression(Expression left, Expression right) {\n        super(left, right);\n    }\n\n    @Override\n    public int interpreter(HashMap<String, Integer> var) {\n        return super.left.interpreter(var) * super.right.interpreter(var) ;\n    }\n}\n```\n\n  6. 除法表达式\n```Java\npackage org.example.interpreter;\n\nimport java.util.HashMap;\n\npublic class DivExpression extends SymbolExpression {\n\n    public DivExpression(Expression left, Expression right) {\n        super(left, right);\n    }\n\n    @Override\n    public int interpreter(HashMap<String, Integer> var) {\n        return super.left.interpreter(var) / super.right.interpreter(var) ;\n    }\n}\n```\n#### 计算器\n```Java\npackage org.example.interpreter;\n\nimport java.util.HashMap;\nimport java.util.Stack;\n\npublic class Calculator {\n    private Expression expression ;\n    public Calculator(String expStr){\n        Stack<Expression> stack = new Stack<>();\n        Expression left = null ;\n        Expression right = null ;\n\n        System.out.println(expStr);\n        char[] array = expStr.toCharArray();\n        for (int i=0 ; i<array.length ; i++){\n            switch (array[i]){\n                case '+' :\n                    left = stack.pop(); // 如果现在是+这个符号，表示前面有一个数已经入栈，这个已经入栈的数就是左值\n                    right = new VarExpression(String.valueOf(array[++i])); //获取符号后面的数值作为右值\n                    stack.push(new AddExpression(left , right)); // 将计算结果压栈\n                    break;\n                case '-' :\n                    left = stack.pop();\n                    right = new VarExpression(String.valueOf(array[++i]));\n                    stack.push(new SubExpression(left , right)) ;\n                    break;\n                case '*' :\n                    left = stack.pop();\n                    right = new VarExpression(String.valueOf(array[++i]));\n                    stack.push(new MulExpression(left , right)) ;\n                    break;\n                case '/' :\n                    left = stack.pop() ;\n                    right = new VarExpression(String.valueOf(array[++i]));\n                    stack.push(new DivExpression(left , right)) ;\n                    break;\n                default:\n                    stack.push(new VarExpression(String.valueOf(array[i]))) ;\n                    break;\n            }\n        }\n        this.expression = stack.pop() ; // 将最终的运算结果赋值\n    }\n\n    public int run(HashMap<String , Integer> var){\n        return this.expression.interpreter(var) ;\n    }\n}\n```\n#### 场景实现\n```Java\npublic class App {\n    /**\n     * 解释器模式\n     * @param args\n     */\n    public static void main(String[] args) {\n        /* 公式变量与数字的映射关系 */\n        HashMap<String, Integer> map = new HashMap<>();\n        map.put(\"a\" , 100);\n        map.put(\"b\" , 20);\n        map.put(\"c\" , 30);\n        /* 需要的公式模板 */\n        String expStr = \"a+b-c\";\n        Calculator calculator = new Calculator(expStr);\n        System.out.println(calculator.run(map));\n    }\n}\n```\n### 应用场景\n  1. 重复发生的问题，规则不同，但是有相同的元素，久可以使用解释器模式。\n  2. 一个简单语法需要解释。如果是复杂语法，会导致类膨胀。\n### 解释器模式的优缺点\n#### 优点\n  1. 解释器是一个简单的语法分析工具，优点是扩展性，修改语法规则只需要修改对应的符号表达式就行了。\n#### 缺点\n  1. 会引起类膨胀，每种语法都会产生一个规则类，语法规则很复杂时会产生很多规则类。\n  2. 解释器模式采用递归调用，使用栈。调试非常麻烦。\n  3. 解释器模式使用递归和栈，效率很低。\n#### 注意事项\n  1. 不要在重要模块使用解释器模式，这样会导致很难维护。\n  2. 解释器模式在实际中很少使用,主要在数据分析工具、报表设计工具、科学计算工具使用。\n  3. 可以使用Expression4J,MESP,Jep开源解析工具来代替自己写解释器模式。\n","tags":["行为型模式"],"categories":["行为型模式"]},{"title":"访问者模式","url":"%2F2019%2F05%2F19%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%2F","content":"\n## 访问者模式\n\n### 定义\n> Represent an operation to be performed on the elements of an objects structure.Vistor lets you define a new operation without changing the classes of the elements on which it operates.\n> 封装一些作用于某种数据结构中的各元素操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。\n\n### 访问者模式示意图\n![访问者模式](访问者模式.png) \n### 流程\n  1. 客户获取需要的信息，首先需要让对象结构生产出元素对象。\n  2. 元素先接受访问者的访问，访问者就可以获取生产的元素对象。\n  3. 访问者就可以按自己的方式操作元素对象，获得客户端需要的信息。\n  4. 最终客户端能够得到需要的信息。\n\n### 代码实现\n\n#### 元素\n  1. 创建所有元素的抽象类\n```Java\n/**\n * 元素的抽象类，定义所有元素共同操作\n */\npublic abstract class Element {\n    /* 元素的动作 */\n    public abstract void test();\n    /* 元素接受访问者访问，访问者可以在自己那里定义访问动作 */\n    public abstract void accept(IVisitor visitor);\n}\n```\n  2. 创建继承抽象类的具体元素1\n```Java\n/**\n * 元素1的实现类\n */\npublic class ConcreteElement1 extends Element {\n    @Override\n    public void test() {\n        System.out.println(\"元素1\");\n    }\n\n    /**\n     * 接受访问者的访问，并将产生的元素对象送给访问者，让访问者操作元素对象\n     * @param visitor\n     */\n    @Override\n    public void accept(IVisitor visitor) {\n        visitor.visit(this);\n    }\n}\n```\n  3. 创建继承抽象类的具体元素2\n```Java\n/**\n * 元素2的实现类\n */\npublic class ConcreteElement2 extends Element{\n    @Override\n    public void test() {\n        System.out.println(\"元素2\");\n    }\n\n    /**\n     * 接受访问者的访问，将元素2的对象送给访问者，让访问者能操作元素2的对象\n     * @param visitor\n     */\n    @Override\n    public void accept(IVisitor visitor) {\n        visitor.visit(this);\n    }\n}\n```\n#### 访问者\n  1. 创建所有访问者需要实现的接口\n```Java\n/**\n * 访问者接口\n */\npublic interface IVisitor {\n    /* 用于访问元素1 */\n    public void visit(ConcreteElement1 element1);\n    /* 用于访问元素2 */\n    public void visit(ConcreteElement2 element2);\n}\n```\n  2. 创建访问者,这个访问者能够访问元素1和元素2\n```Java\n/**\n * 访问者\n */\npublic class ConcreteVisitor implements IVisitor {\n\n    /**\n     * 访问者访问元素1的方法，元素1接受了访问者的访问，访问者能够获取到元素1的对象，然后在这个方法中自由操作元素对象\n     * @param element1\n     */\n    @Override\n    public void visit(ConcreteElement1 element1) {\n        element1.test();\n    }\n\n    /**\n     * 访问者访问元素2的方法，元素1接受了访问者的访问，访问者能够获取到元素2的对象，然后在这个方法中自由操作元素对象\n     * @param element2\n     */\n    @Override\n    public void visit(ConcreteElement2 element2) {\n        element2.test();\n    }\n}\n```\n#### 对象结构\n  1. 创建一个用来生产元素对象的对象结构\n```Java\n/**\n * 对象结构，用来生产元素对象，这里随机生产出元素1或者元素2\n */\npublic class ObjectStructure {\n    public static Element createElement(){\n        Random random = new Random();\n        if (random.nextInt(100) > 50) {\n            return new ConcreteElement1();\n        }else {\n            return new ConcreteElement2();\n        }\n    }\n}\n```\n#### 场景实现\n```Java\npublic class Test{\n\tpublic static void main(String[] args) {\n\t        for (int i=0 ; i<10 ; i++){\n            /* 创建元素对象 */\n            Element element = ObjectStructure.createElement();\n            /* 让元素接受访问者的访问 */\n            /* 接受访问后，访问者就获取元素对象，操作元素对象 */\n            element.accept(new ConcreteVisitor());\n        }\n\t}\n}\n```\n### 应用场景\n  1. 一个对象结构有很多不同接口的对象，我们需要对这些对象实施依赖具体类的操作。\n  2. 需要对一个对象结构中的对象进行很多不同且不相关的操作。\n  3. 访问者模式使迭代器模式的扩展，当迭代器不能胜任，我们能使用访问者模式。\n### 访问者模式的优点和缺点\n\n#### 优点\n  1. 符合单一职责原则，元素只负责加载数据，访问者只负责展现数据，对象结构只负责创建对象。\n  2. 扩展性非常好。对数据的操作很快捷，如果要增加操作，只需要在访问者中增加对应方法就行了。\n  3. 非常好的灵活性。\n#### 缺点\n  1. 具体元素对访问者公开，违反迪米特原则。\n  2. 具体元素变更很困难。\n  3. 访问者直接访问具体元素，违反了依赖倒置原则。\n","tags":["行为型模式"],"categories":["行为型模式"]},{"title":"迭代器模式","url":"%2F2019%2F05%2F19%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F","content":"\n## 迭代器模式\n\n### 定义\n> Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.\n> 它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节\n### 迭代器模式示意图\n![迭代器模式](迭代器模式.png)\n### 流程\n  1. 创建一个容器，用来存储元素\n  2. 创建一个迭代器，用来迭代容器中的对象\n  3. 最终通过迭代器，我们能将容器中的所有对象迭代出来\n\n### 代码实现\n#### 准备\n我们现在模拟map容器的元素迭代。\n#### 迭代器\n  1. 抽象迭代器\n```Java\npackage org.example.iterator;\n\n/**\n * 迭代器接口，java有现成的迭代器模式，每个java中的容器(map,set,list)都是用迭代器模式实现的\n */\npublic interface Iterator {\n    /* 判断下一个迭代元素是否存在 */\n    public boolean hasNext();\n    /* 获取下一个迭代元素 */\n    public Object next();\n    /* 溢出当前迭代n元素 */\n    public boolean remove();\n}\n```\n  2. 具体迭代器\n```Java\npackage org.example.iterator;\nimport java.util.Vector;\n\n/**\n * 具体迭代器\n */\npublic class ConcreteIterator implements Iterator {\n    /* 用来存放需要迭代的集合 */\n    private Vector vector = new Vector() ;\n    /* 当前迭代所在游标处 */\n    public int cursor = 0 ;\n\n    /**\n     * 将输入的需要迭代的集合存放到当前类的容器中，用于迭代\n     * @param vector\n     */\n    public ConcreteIterator(Vector vector){\n        this.vector = vector ;\n    }\n\n    /**\n     * 判断是否有下一个迭代元素\n     * @return\n     */\n    @Override\n    public boolean hasNext() {\n        /* 如果当前游标所在的位置已经是集合末尾，表示没有下一个迭代元素 */\n        if (this.cursor == this.vector.size()){\n            return false ;\n        }else {\n            return true ;\n        }\n    }\n\n    /**\n     * 用来获取下一个迭代元素\n     * @return\n     */\n    @Override\n    public Object next() {\n        Object result = null ;\n        /* 如果下一个迭代元素存在，就返回下一个迭代元素 */\n        if (this.hasNext()){\n            result = this.vector.get(this.cursor++) ;\n        }else {\n            result = null ;\n        }\n        return result ;\n    }\n\n    /**\n     * 移出当前迭代的元素，移出方法使用容器实现的移除方法\n     * @return\n     */\n    @Override\n    public boolean remove() {\n        this.vector.remove(this.cursor);\n        return true;\n    }\n}\n```\n#### 容器\n  1. 抽象容器\n```Java\npackage org.example.iterator;\n\n/**\n * 抽象容器\n */\npublic interface Aggregate {\n    /* 将元素增加到容器中 */\n    public void add(Object object);\n    /* 将指定元素移出容器 */\n    public void remove(Object object);\n    /* 用来迭代容器中的元素 */\n    public Iterator iterator() ;\n}\n```\n  2. 具体容器\n```Java\npackage org.example.iterator;\n\nimport java.util.Vector;\n\n/**\n * 具体容器\n */\npublic class ConcreteAggregate implements Aggregate {\n    /* 用来存放使用add的元素对象 */\n    private Vector vector = new Vector() ;\n\n    /**\n     * 用来增加object到容器中\n     * @param object\n     */\n    @Override\n    public void add(Object object) {\n        this.vector.add(object);\n    }\n\n    /**\n     * 将元素object从容器中移除\n     * @param object\n     */\n    @Override\n    public void remove(Object object) {\n        this.vector.remove(object);\n    }\n\n    /**\n     * 容器的迭代器,创建一个迭代器对象，获取一个迭代器，用来迭代容器中的元素\n     * @return\n     */\n    @Override\n    public Iterator iterator() {\n        return new ConcreteIterator(vector);\n    }\n}\n```\n#### 场景实现\n```Java\npublic class App {\n    /**\n     * 迭代器模式，使用方式和map迭代器相同\n     * @param args\n     */\n    public static void main(String[] args) {\n        /**\n         * 创建容器对象，将元素加入容器\n         */\n        ConcreteAggregate aggregate = new ConcreteAggregate();\n        aggregate.add(\"a\");\n        aggregate.add(\"b\");\n        aggregate.add(\"c\");\n\n        /* 从容器中获取迭代器对象 */\n        Iterator iterator = aggregate.iterator();\n        /* 通过迭代器来进行元素迭代 */\n        while (iterator.hasNext()){\n            Object next = iterator.next();\n            System.out.println(next);\n        }\n\n    }\n}\n```\n### 应用场景\n  1. 迭代器模式应用的非常普遍，比如java里面的list,map等容器都用迭代器模式来迭代元素。迭代模式已经成为开发中最普遍的工具。\n  2. 在java开发中，直接用java提供的Iterator久可以满足我们的迭代器模式的需求。\n","tags":["行为型模式"],"categories":["行为型模式"]},{"title":"策略模式","url":"%2F2019%2F05%2F19%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F","content":"\n## 策略模式\n\n### 定义\n> Define a family of algorithms , encapsulate each one , and make them interchangeable.\n> 定义一组算法，将每个算法封装起来，并且使它们之间可以互换。\n### 策略模式示意图\n![策略模式](策略模式.png)\n### 流程\n  1. 定义一个总的策略接口，所有的具体策略都要实现这个接口，因为这些策略都有相同的目标。\n  2. 将策略封装进策略上下文，让策略有完整的过程。\n  3. 客户直接就使用这个完整的过程。\n### 代码实现\n#### 策略\n  1. 策略总接口\n```Java\n/**\n * 策略总接口\n */\npublic interface IStrategy {\n    /* 对外提供的策略接口 */\n    public void strategy();\n}\n```\n  2. 实现总接口的具体策略1\n```Java\npublic class Strategy1 implements IStrategy {\n    /* 具体策略1，我们需要的第一个策略 */\n    @Override\n    public void strategy() {\n        System.out.println(\"策略1\");\n    }\n}\n```\n  3. 实现总接口的具体策略2\n```Java\npublic class Strategy2 implements IStrategy{\n    /* 具体策略2，我们需要的第二个策略 */\n    @Override\n    public void strategy() {\n        System.out.println(\"策略2\");\n    }\n}\n```\n  4. 实现总接口的具体策略3\n```Java\npublic class Strategy3 implements IStrategy {\n    /* 具体策略3，我们需要的第三个策略 */\n    @Override\n    public void strategy() {\n        System.out.println(\"策略3\");\n    }\n}\n```\n#### 封装\n将策略进行封装\n```Java\n/**\n * 策略上下文，封装策略，将需要的策略置于需要的场景中\n */\npublic class Context {\n    private IStrategy strategy ;\n\n    /* 获取封装的策略 */\n    public IStrategy getStrategy(){\n        return strategy ;\n    }\n\n    /* 将需要的策略放入策略上下文中 */\n    public void setStrategy(IStrategy strategy){\n        this.strategy = strategy ;\n    }\n\n    /* 执行策略,可以在策略周围添加我们需要的逻辑 */\n    public void executeStrategy(){\n        System.out.println(\"策略开始执行\");\n        strategy.strategy();\n        System.out.println(\"策略执行完成\");\n    }\n}\n```\n#### 场景实现\n```Java\npublic class Test{\n    public static void main(String[] args) {\n        /* 先创建需要的具体策略 */\n        IStrategy strategy1 = new Strategy1();\n        /* 然后创建执行过程 */\n        Context context = new Context();\n        /* 将策略放入执行过程 */\n        context.setStrategy(strategy1);\n        /* 添加上我们的逻辑后，我们就可以开始执行策略了 */\n        context.executeStrategy();\n    }\n}\n```\n### 应用场景\n  1. 多个类只有在算法或行为上稍有不同的场景。\n  2. 算法需要自由切换。\n  3. 需要屏蔽算法规则。\n  4. 如果具体策略数量大于3个，可以考虑使用混合模式。\n\n### 策略模式的优缺点\n#### 优点\n  1. 策略算法可以自由切换\n  2. 避免使用多重条件判断，我们有这么多策略，不需要使用判断语句来判断需要使用哪种策略，我们这是被动选择策略。我们可以使用多态来，我们主动选择策略。\n  3. 扩展性好，我们可以随时添加一个策略而不用改任何代码。\n#### 缺点\n  1. 每个策略类就是一种策略，具体策略类不能被复用，这样策略变多，会显得很臃肿。\n  2. 我们需要创建具体策略对象，这样所有的策略类都会向对外暴露，违反了迪米特法则。\n","tags":["行为型模式"],"categories":["行为型模式"]},{"title":"责任链模式","url":"%2F2019%2F05%2F19%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F","content":"\n## 责任链模式\n\n### 定义\n> Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.Chain the receiving objects and pass the request along the chain until an object handles it.\n> 使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。\n\n### 责任链模式示意图\n![责任链模式](责任链模式.png)\n\n### 流程\n  1. 定义一个请求以及这个请求对应的处理器标识。\n  2. 创建一个抽象处理器，用来封装所有处理器的相同部分，所有实体处理器都要继承这个抽象类。\n  3. 我们定义的请求会访问抽象处理器(使用多态)，所有的处理器组成一个责任链条，我们的请求会从责任链条头部一个个节点的比对处理器标识，如果处理器标识比对成功，就获取对应处理器。\n  4. 获取到对应处理器后，处理器就开始响应这个请求。\n\n### 代码实现\n#### 处理器\n  1. Handler(抽象处理器)\n```Java\npackage org.example.chain;\n\n/**\n * 抽象处理器，所有的处理器实体都要集成这个处理器\n */\npublic abstract class Handler {\n\n    /**\n     * 处理器需要处理的请求等级\n     */\n    public final static int GET_REQUEST = 0 ;\n    public final static int POST_REQUEST = 1 ;\n    public final static int OTHER_REQUEST = 2 ;\n\n    private int handlerCount = 0 ;\n    \n    /**\n     * 成员变量\n     */\n    private Handler nextHandler ;\n    private int level ;\n\n    /**\n     * 处理器用来初始化输入请求的等级\n     * @param level\n     */\n    public Handler(int level){\n        this.level = level ;\n    }\n\n    /**\n     * 处理器处理请求的业务逻辑\n     * @param request\n     */\n    public void handlerMessage(Request request){\n        // 如果请求等级相同\n        if (this.level == request.getType()){\n            this.response(request); // 那么就使用当前处理器\n        }else {\n            // 如果还有下一个处理器，就将请求交给下一个处理器处理\n            if (nextHandler != null){\n                this.nextHandler.handlerMessage(request); // 使用下一个处理器\n            }else { // 如果没有处理器了，就不处理该请求\n                System.out.println(\"没有适合的处理器处理请求。\");\n            }\n        }\n    }\n\n    /**\n     * 将各个处理器连接起来，形成一个责任链条\n     * @param handler\n     */\n    public void setNextHandler(Handler handler){\n        if (handlerCount < 5){\n            this.nextHandler = handler ;\n            handlerCount++ ;\n        }else {\n            System.out.println(\"责任链条超出阈值\");\n        }\n    }\n\n    /**\n     * 处理器响应请求\n     * @param request\n     */\n    protected abstract void response(Request request);\n}\n```\n  2. GetHandler(get请求处理器)\n```Java\npackage org.example.chain;\n\n/**\n * get请求的处理器\n */\npublic class GetHandler extends Handler {\n\n    /**\n     * 初始化get请求的等级\n     */\n    public GetHandler(){\n        super(Handler.GET_REQUEST);\n    }\n    // 表示获取的请求是一个get请求\n    @Override\n    protected void response(Request request) {\n        System.out.println(\"开始处理GET请求:\"+request.getRequest());\n    }\n}\n```\n  3. PostHandler(post请求处理器)\n```Java\npackage org.example.chain;\n\n/**\n *\n */\npublic class PostHandler extends Handler {\n    /**\n     * 初始化post请求的等级\n     */\n    public PostHandler(){\n        super(Handler.POST_REQUEST);\n    }\n\n    /**\n     * 处理器响应post请求\n     * @param request\n     */\n    @Override\n    protected void response(Request request) {\n        System.out.println(\"开始处理POST请求：\"+request.getRequest());\n    }\n}\n```\n  4. OtherHandler(其他请求处理器)\n```Java\npackage org.example.chain;\n\npublic class OtherHandler extends Handler {\n    public OtherHandler(){\n        super(Handler.OTHER_REQUEST);\n    }\n    @Override\n    protected void response(Request request) {\n        System.out.println(\"开始处理其他请求：\"+request.getRequest());\n    }\n}\n```\n#### 请求\n  1. Request(请求实体)\n```Java\npackage org.example.chain;\n\n/**\n * 请求角色，为请求设置等级，用来匹配责任链中的处理器\n */\npublic class Request {\n\n    private int type ;\n    private String request ;\n\n    /**\n     * type = 0 表示是GET请求\n     * type = 1 表示是POST请求\n     */\n    public Request(int type , String request){\n        this.type = type ;\n        switch (type){\n            case 0 :\n                this.request = request+\"是一个GET请求\";\n                break;\n            case 1 :\n                this.request = request+\"是一个POST请求\";\n                break;\n            case 2 :\n                this.request = request+\"是一个未知请求\";\n                break;\n        }\n    }\n\n    public int getType(){\n        return this.type ;\n    }\n\n    public String getRequest(){\n        return this.request ;\n    }\n}\n```\n#### 场景实现\n```Java\npublic class App {\n    /**\n     * 责任链模式\n     * @param args\n     */\n    public static void main(String[] args) {\n        // 先创建一个get请求\n        Request request = new Request(0 , \"http://example.com/get?a=b\");\n        // 创建一个post请求\n        Request request1 = new Request(1, \"http://example.com/post\");\n        Request request2 = new Request(2, \"http://example.com/other\");\n\n        // 创建责任链节点\n        GetHandler getHandler = new GetHandler();\n        PostHandler postHandler = new PostHandler();\n        OtherHandler otherHandler = new OtherHandler();\n\n        // 将责任链的各个节点连接起来，形成一个链条\n        getHandler.setNextHandler(postHandler);\n        postHandler.setNextHandler(otherHandler);\n\n        // 请求开始通过责任链进行判断\n        getHandler.handlerMessage(request);\n        getHandler.handlerMessage(request1);\n        getHandler.handlerMessage(request2);\n    }\n}\n```\n### 应用场景\n\n### 责任链模式的优缺点\n#### 优点\n  1. 将请求和处理分开，两者解耦。\n#### 缺点\n  1. 性能问题。每次请求都要从头开始遍历，如果请求匹配的处理器都是在末尾，非常耗费性能。\n  2. 调试不方便。采用了递归方式，调试时逻辑比较复杂。\n#### 注意事项\n  1. 责任链中的节点需要控制数量，责任链不能太长。一般做法是在抽象处理器中设置责任链最大节点数。\n","tags":["行为型模式"],"categories":["行为型模式"]},{"title":"适配器模式","url":"%2F2019%2F05%2F19%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F","content":"## 适配器模式\n\n### 定义\n> Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.\n> 将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。\n\n### 适配器模式示意图\n![适配器模式](适配器模式.png)\n\n### 流程\n  1. 有一个与目标不兼容的适配者，我们可以在目标与适配者之间加一个适配器。\n  2. 让适配者连接适配器，让目标连接适配器。\n  3. 这样就能让目标与适配者间接连接。\n  \n### 需求\n现在我们有一部没电的手机，我们需要充电。\n这里有两个充电器，一个是手机原配充电器，另一个是与手机不兼容的充电器。\n我们需要让不兼容的充电器让手机能充电。\n### 代码实现\n\n#### 创建目标\n  1. 首先创建手机抽象类，作为所有类型手机的模板\n```Java\n/**\n * 这是所有手机都要实现的接口\n */\npublic interface Phone {\n    /* 手机请求充电 */\n    public void requestCharger();\n\n    /* 充电完成 */\n    public void ok();\n}\n```\n  2. 创建iphone手机\n```Java\n/**\n * 这里有一个苹果手机\n */\npublic class IPhone implements Phone {\n    @Override\n    public void requestCharger() {\n        System.out.println(\"IPhone请求充电\");\n    }\n\n    @Override\n    public void ok() {\n        System.out.println(\"IPhone充电完成\");\n    }\n}\n```\n\n#### 创建适配者(充电器)\n  1. 先创建充电器抽象类，作为所有充电器类型的接口\n```Java\n/**\n * 这是都需要实现的接口，这里有所有充电器都需要的功能\n */\npublic interface BatterCharger {\n\n    /* 充电 */\n    public void recvCharger();\n}\n```\n  2. 创建一个安卓手机充电器\n```Java\npublic class AndroidBatterCharger implements BatterCharger {\n    @Override\n    public void recvCharger() {\n        System.out.println(\"Android手机充电器\");\n    }\n}\n```\n  3. 创建一个苹果手机充电器\n```Java\npublic class IPhoneBatterCharger implements BatterCharger {\n    @Override\n    public void recvCharger() {\n        System.out.println(\"IPhone手机充电器\");\n    }\n}\n```\n\n#### 创建适配器\n  1. 创建一个适配器抽象类\n```Java\npublic abstract class Adapter {\n    public abstract void charger();\n}\n```\n  2. 现在我们为苹果手机创建一个适配器，适配一个需要的充电器。这个适配器需要对接手机和充电器两方，这样才能将手机和充电器连接，进行充电。因此，我们需要继承苹果类，实现充电器接口\n```Java\npublic class IPhoneAdapter extends IPhone implements BatterCharger {\n    @Override\n    public void recvCharger() {\n        System.out.println(\"获取IPhone充电器,开始充电\");\n    }\n}\n```\n#### 场景类\n我们需要给苹果手机充电，这里有苹果和安卓两个充电器，有一个苹果手机和一个适配器。\n我们先将苹果和安卓充电器对外提供接口与适配器连接，让适配器可以自由选择连接哪个充电器。\n然后将适配器与苹果手机连接。这就可以进行充电了。\n```Java\npublic class Test{\n\tpublic static void main(String[] args) {\n\t\t/* 创建一个iphone手机 */\n        Phone phone = new IPhone();\n        /* 请求充电器 */\n        phone.requestCharger();\n\n        /* 创建一个iphone手机充电器 */\n        IPhoneAdapter iPhoneAdapter = new IPhoneAdapter();\n        /* 开始充电 */\n        iPhoneAdapter.recvCharger();\n\n        /* 充电完成 */\n        phone.ok();\n\t}\n}\n```\n\n### 应用场景\n  1. 我们的项目已经存在，并且与我们的需求不兼容，才需要进行适配。\n### 适配器模式优点和注意事项\n#### 优点\n  1. 适配器能让两个没有任何关联的类在一起运行，只需要让适配器作为中转。\n  2. 增加了类的透明性。我们访问的是目标角色，但是我们将具体实现委托给了适配者，而这些模块对高层模块是透明的。\n  3. 提供了类的复用度。适配者可以在不变的情况下再与新的目标连接。\n  4. 灵活性非常好。适配者和目标是分离的，两者想删除就可以删除。\n#### 注意事项\n  1. 适配器模式适用于已经存在的项目，因为项目存在且需要，但是与我们不兼容才进行适配。如果项目还在详细设计阶段，就不用考虑了，因为没有兼容问题，不需要适配器。\n  \n","tags":["结构型模式"],"categories":["结构型模式"]},{"title":"动态代理模式","url":"%2F2019%2F05%2F19%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F","content":"\n### 动态代理模式\n\n#### 引言\n> 用的最广泛的设计模式\n\n#### 定义\n在实现阶段不用关心代理的是那个，在运行阶段才指定具体的代理。\n<!-- more -->\n#### 实现原理\n动态代理技术中的代理能够做比静态代理技术中的代理更多，更广的事。动态代理能够根据被代理类提供的操作动态生成相对应的操作而替代被代理类实现。\n可以这样比喻，动态代理就是一个集代购电子产品，服装，化妆品，食品等业务于一身的综合代购，被代理者(用户)不管你想进行那类操作，代购都能对应的帮你完成。\n动态代理是jdk的技术，使用java.lang.reflect包下提供的Proxy类和InvacationHandler接口，可以生成一个动态代理类和代理对象。\nInvacationHandler接口需要被实现而重写invoke(target,method,args)方法，将被代理者需要进行的操作(通过method.invoke()方法获取相对应操作)和代购需要进行的操作合并，形成代理需要进行的操作。  Proxy类则将被代理者的对象类加载器，被代理者实现的接口以及代理需要进行的操作三者进行合并，用代理者对象类加载器和其实现的接口作为模板，生成相对应的代理类(有共同的接口和相似的类结构),将代理需要进行的操作合并到代理类中，形成新生成的代理类的具体操作。\n![动态代理模式图](动态代理模式/动态代理图.png)\n\n#### 实现步骤\n##### 第一步，创建实体类\n{% codeblock lang:java %}\npackage com.test.bean;\n\n/**\n * 动态代理需要的被代理对象\n */\npublic class User {\n    private int id ;\n    private String name ;\n    private int age ;\n    private String sex ;\n\n    public User() {\n    }\n\n    public User(int id, String name, int age, String sex) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n        this.sex = sex;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", sex='\" + sex + '\\'' +\n                '}';\n    }\n}\n\n{% endcodeblock %}\n##### 第二步，创建事务类\n{% codeblock lang:java %}\npackage com.test.transaction;\n\npublic class MyTransaction {\n    public void before(){\n        System.out.println(\"打开事务\");\n    }\n\n    public void after(){\n        System.out.println(\"关闭事务\");\n    }\n}\n\n{% endcodeblock %}\n##### 第三步，创建共同接口\n{% codeblock lang:java %}\npackage com.test.service;\n\nimport com.test.bean.User;\n\n/**\n * 动态代理需要的公共接口\n */\npublic interface UserService {\n    public void addUser(User u);\n    public void delete(int id);\n}\n\n{% endcodeblock %}\n##### 第四步，创建被代理者的操作\n{% codeblock lang:java %}\npackage com.test.serviceImpl;\n\nimport com.test.bean.User;\nimport com.test.service.UserService;\n\n/**\n * 被代理对象需要做的动作\n */\npublic class UserServiceImpl implements UserService {\n    public void addUser(User u) {\n        System.out.println(\"增加用户\");\n    }\n\n    public void delete(int id) {\n        System.out.println(\"删除用户\");\n    }\n}\n\n{% endcodeblock %}\n##### 第五步，创建动态代理的抽象操作\n{% codeblock lang:java %}\npackage com.test.serviceImpl;\n\nimport com.test.transaction.MyTransaction;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\n/**\n * 动态代理的关键部分，通过实现InvocationHandler，用于表示在执行某个方法之前或者之后需要加入的代码\n * 这里放置代理对象的执行过程\n */\npublic class ObjectIntercepter implements InvocationHandler {\n    private Object target ;\n    private MyTransaction myTransaction ;\n\n    public ObjectIntercepter() {\n    }\n\n    public ObjectIntercepter(Object target, MyTransaction myTransaction) {\n        this.target = target;\n        this.myTransaction = myTransaction;\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        this.myTransaction.before();//开启事务\n        method.invoke(this.target , args); //获取需要代理的对象需要执行的操作\n        this.myTransaction.after();//提交事务\n        return null;\n    }\n}\n\n{% endcodeblock %}\n##### 第六步，测试\n{% codeblock lang:java %}\nimport com.test.bean.User;\nimport com.test.service.UserService;\nimport com.test.serviceImpl.ObjectIntercepter;\nimport com.test.serviceImpl.UserServiceImpl;\nimport com.test.transaction.MyTransaction;\nimport org.junit.Test;\n\nimport java.lang.reflect.Proxy;\n\npublic class test {\n    UserService us = new UserServiceImpl();\n    MyTransaction mt = new MyTransaction();\n    ObjectIntercepter oi = new ObjectIntercepter(us,mt);\n\n\n    /**\n     * 这里使用Proxy类来创建一个代理实例，它通过获取被代理类的类加载器和接口，这样就能为新创建的代理类和被代理类有共同的接口\n     * 代理类创建之后，需要通过oi(动态勾连需要的操作)获取对应的操作\n     * oi传入目标对象(被代理类)和事务(需要的前置和后置条件),通过invoke函数将他们合并，形成代理类最终的操作\n     *\n     * 上述可获取代理类和匹配被代理类需要代理类完成的操作\n     */\n\n    @Test\n    public void test(){\n        UserService userService = (UserService)Proxy.newProxyInstance(us.getClass().getClassLoader(), us.getClass().getInterfaces(), oi);\n        userService.delete(1);\n    }\n}\n\n{% endcodeblock %}\n\n#### 总结\n动态代理技术就相当于一个自动化工厂，将一个个不同型号的零部件适配组装成不同类型的产品。\n理解动态代理，可以与静态代理相结合。动态代理的出现就是解决静态代理的缺陷。知道动态代理的功能后，顺藤摸瓜，就能知道动态代理的实现原理。\n#### 自然言语\n忙了几天，终于抽出时间把动态代理这块给理清了。加上这个已经理清两个设计模式，有朝一日我要把java的23种设计模式都弄出来。\n剩余:21种。\n","tags":["代理模式"],"categories":["代理模式"]},{"title":"静态代理模式","url":"%2F2019%2F05%2F19%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F","content":"\n### 静态代理模式\n\n#### 定义\n静态地为其他对象提供代理，用以对某个对象的访问。静态代理模式共分为三个部分，代理类，被代理类，共同接口。\n  + 共同接口\n    通用接口，代理类和被代理类共同实现，这让代理类能够替代被代理的对象。共同接口使得代理类能够代理这个接口下的一系列的被代理类。\n  + 被代理类\n    可以称作委托者，是业务逻辑的执行者。实现了共同接口，可以被代理类代理。\n  + 代理类\n    获取被代理类引用(获取业务逻辑)，为最终的执行者。实现了共同接口，可以代理被代理类。\n![静态代理模式结构图](静态代理模式/静态代理模式图.png)\n我们可以用代购举例，用户需要购买商品，可以通过代理帮助购买，代理能够帮助购买很多种类的商品，而购买商品操作是用户与代理共同具有的。\n   + 可以有代理**能够购买**和**用户需要**购买的商品操作为共同接口\n   + 用户实现这个接口表示用户需要购买这些商品\n   + 代理实现这个接口表示代理能够购买这些商品\n   + 代理需要访问用户得知需要**购买什么商品**(业务逻辑)\n   + 用户需要告知代理需要**购买什么商品**(业务逻辑)\n   + 并且用户需要给代理钱来购买商品\n   + 最终代理购买了商品给用户\n\n#### 使用静态代理模式\n##### 第一步，创建实体\n{% codeblock lang:java %}\n/**\n * 创建用户实体（需要给代理的钱）\n */\n\npackage com.spring.bean;\n\npublic class User {\n    private int id ;\n    private String name ;\n    private int age ;\n\n    public User() {\n    }\n\n    public User(int id, String name, int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n\n{% endcodeblock %}\n\n##### 第二步，创建共同接口\n{% codeblock lang:java %}\npackage com.spring.service;\n\nimport com.spring.bean.User;\n\n/**\n * 创建共同接口(买东西这个操作)\n */\npublic interface UserService {\n    void addUser(User u);\n    void deleteUser(int id);\n}\n\n{% endcodeblock %}\n\n##### 第三步，创建被代理类\n{% codeblock lang:java %}\npackage com.spring.serviceImpl;\n\nimport com.spring.bean.User;\nimport com.spring.service.UserService;\n\n/**\n * 创建用户的业务逻辑实现(具体买什么东西)\n * 我们需要知道用户要干什么\n */\npublic class UserServiceImpl implements UserService {\n    public void addUser(User u) {\n        System.out.println(\"增加User\");\n    }\n\n    public void deleteUser(int id) {\n        System.out.println(\"删除User\");\n    }\n}\n\n{% endcodeblock %}\n##### 第四步，创建事务类\n{% codeblock lang:java %}\npackage com.spring.transaction;\n\n/**\n * 事务(代理买东西时需要用到的额外工具)\n * 相当于一个代理需要的一个工具\n */\npublic class Transaction {\n    public void before(){\n        System.out.println(\"开始事务\");\n    }\n\n    public void after(){\n        System.out.println(\"提交事务\");\n    }\n\n}\n\n{% endcodeblock %}\n\n##### 第五步，创建代理类\n{% codeblock lang:java %}\npackage com.spring.serviceImpl;\n\nimport com.spring.bean.User;\nimport com.spring.service.UserService;\nimport com.spring.transaction.Transaction;\n\n/**\n{% codeblock lang:java %}\n{% endcodeblock %}\n * 代理类\n * 代理类需要实现共同的接口，使得代理知道用户要干什么\n * 代理之后需要使用工具事务类，帮助代理执行这个操作\n */\n\npublic class ProxyUser implements UserService {\n\n    private UserService userService ;\n    private Transaction transaction ;\n\n    public ProxyUser() {\n    }\n\n    public ProxyUser(UserService userService, Transaction transaction) {\n        this.userService = userService;\n        this.transaction = transaction;\n    }\n\n    public void addUser(User u) {\n        transaction.before();\n        userService.addUser(u);\n        transaction.after();\n    }\n\n    public void deleteUser(int id) {\n        transaction.before();\n        userService.deleteUser(id);\n        transaction.after();\n    }\n}\n\n{% endcodeblock %}\n\n##### 第六步，代理开始工作\n{% codeblock lang:java %}\nimport com.spring.bean.User;\nimport com.spring.service.UserService;\nimport com.spring.serviceImpl.ProxyUser;\nimport com.spring.serviceImpl.UserServiceImpl;\nimport com.spring.transaction.Transaction;\n\npublic class Test {\n\n    /**\n     * 创建实体对象(相当于买东西的钱)\n     * 创建用户业务逻辑对象(需要买什么东西)\n     * 创建事务对象(代购需要的工具)\n     * 创建代理对象(代购人)\n     * 代理对象确定需要代理的对象(userService),使用transaction对象作为工具，实现代理工作\n     */\n\n    @org.junit.Test\n    public void test01(){\n        User user = new User(1, \"张三\", 18);\n        UserService userService = new UserServiceImpl();\n        Transaction transaction = new Transaction();\n        ProxyUser proxyUser = new ProxyUser(userService, transaction);\n        proxyUser.addUser(user);\n    }\n}\n\n{% endcodeblock %}\n\n##### 第七步，测试结果\n{% codeblock lang:java %}\n开始事务\n增加User\n提交事务\n{% endcodeblock %}\n\n#### 优缺点\n##### 优点\n  + 可以将两个类需要通信的类解耦，实现低耦合，高内聚。使我们只需要了解代理类。\n  + 两个类之间的关系能被统一管理。\n##### 缺点\n  + 代理对象的一个接口服务于一种类型的对象(一种代表了代理类和被代理类必须实现同一个接口，这个接口下的所有类都可被代理类访问到)，如果代理的方法很多，需要为每一种方法都进行代理，这样会出现非常多的冗余代码。\n  + 如果共同接口增加一个方法，则代理类和被代理类都需要实现这个方法。这增加了代码维护难度。\n\n#### 自言自语\n静态代理模式使我们只需要改代理类的实现，而不需要更改其他的类。但是静态代理合适应用在小的项目中，如果在大项目中，则需要使用动态代理模式。\n剩余:22种。\n\n","tags":["代理模式"],"categories":["代理模式"]},{"title":"单一职责原则","url":"%2F2019%2F05%2F19%2FJava%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%2F","content":"\n### 单一职责原则(Single Responsibility Principle)\n\n#### 引言\n> 道生一，一生二，二生三，三生万物。正所谓，大道至简，大音希声。\n#### 定义\n单一职责原则就是将不同的职责分离到单独的类，使得有且仅有一个原因引起类的变更。\n#### 应用\n##### 应用场景1\n这里我们以用户管理为例，对用户的管理包括对用户信息的管理(业务对象)和对用户行为的管理(业务逻辑)。根据单一职责原则，可以将用户行为和用户信息两个职责分别作为接口，最终则由另一个操作类来实现两个接口定义的操作。这样，管理者能够只需要通过接口来对用户进行管理，并且使得两个职责分离，一个职责发生变动，不会影响另一个职责。\n\n##### 第一步，创建业务对象接口\n> 提供操作用户信息的接口\n{% codeblock lang:java %}\n/**\n * 业务对象接口\n */\npublic interface IUserBO {\n    void setUserId(String userId);\n    String getUserId();\n    void setPasswd(String passwd);\n    String getPasswd();\n    void setUserName(String userName);\n    String getUserName();\n}\n\n{% endcodeblock %}\n\n##### 第二步，创建业务逻辑接口\n> 提供操作用户行为的接口\n{% codeblock lang:java  %}\n/**\n * 业务逻辑接口\n */\npublic interface IUserBIZ {\n    boolean changePasswd();\n    boolean deleteUser(IUserBO userBO);\n    boolean mapUser(IUserBO userBO);\n    boolean addOrg(IUserBO userBO , int orgID);\n    boolean addRole(IUserBO userBO , int orgID);\n}\n\n{% endcodeblock %}\n\n##### 第三步，创建用户信息类\n> 实现用户信息接口和用户行为接口\n{% codeblock lang:java  %}\n/**\n * 用户信息实现类\n */\npublic class UserInfo implements IUserBO , IUserBIZ {\n    private String userId ;\n    private String passwd ;\n    private String userName ;\n\n    public UserInfo() {\n    }\n\n    public UserInfo(String userId, String passwd, String userName) {\n        this.userId = userId;\n        this.passwd = passwd;\n        this.userName = userName;\n    }\n\n    public boolean changePasswd() {\n        System.out.println(\"改变密码\");\n        return false;\n    }\n\n    public boolean deleteUser(IUserBO userBO) {\n        System.out.println(\"删除用户\");\n        return false;\n    }\n\n    public boolean mapUser(IUserBO userBO) {\n        return false;\n    }\n\n    public boolean addOrg(IUserBO userBO, int orgID) {\n        return false;\n    }\n\n    public boolean addRole(IUserBO userBO, int orgID) {\n        return false;\n    }\n\n    public void setUserId(String userId) {\n        this.userId = userId ;\n    }\n\n    public String getUserId() {\n        return userId ;\n    }\n\n    public void setPasswd(String passwd) {\n        this.passwd = passwd ;\n    }\n\n    public String getPasswd() {\n        return passwd ;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName ;\n    }\n\n    public String getUserName() {\n        return userName ;\n    }\n\n    @Override\n    public String toString() {\n        return \"UserInfo{\" +\n                \"userId='\" + userId + '\\'' +\n                \", passwd='\" + passwd + '\\'' +\n                \", userName='\" + userName + '\\'' +\n                '}';\n    }\n}\n\n{% endcodeblock %}\n\n##### 第四步，测试\n> 通过多态，只需要创建一个对象，就能被用于多种用途\n{% codeblock lang:java  %}\nimport org.junit.Test;\n\npublic class test {\n    @Test\n    public void test(){\n        /**\n         * 创建对象\n         */\n\n        //通过多态创建一个对象\n        IUserBIZ userInfo = new UserInfo();\n        //由于创建的对象实现了两个接口，因此另一个接口的引用能够指向强制转换后的对象\n        IUserBO userBO = (IUserBO)userInfo ;\n        //强制转换后，userBO接口的引用能够调用UserInfo类实现该接口的方法\n        userBO.setPasswd(\"123\");\n        userBO.setUserId(\"1\");\n        userBO.setUserName(\"name\");\n        System.out.println(userBO);\n\n        //IUserBIZ接口的引用能够指向强制转换后的对象\n        IUserBIZ userBIZ = (IUserBIZ)userInfo ;\n        //强制转换后，IUserBIZ接口的引用能够调用UserInfo实现该接口的方法\n        userBIZ.deleteUser(userBO);\n        System.out.println(userBIZ);\n\n    }\n}\n\n{% endcodeblock %}\n\n##### 结果\n\n{% codeblock lang:java %}\nUserInfo{userId='1', passwd='123', userName='name'}\n删除用户\nUserInfo{userId='1', passwd='123', userName='name'}\n{% endcodeblock %}\n\n#### 应用场景2\n电话通话的时候有4个过程发生:拨号，通话，回应，挂机。\n##### 分析\n电话通话包括了两个职责：协议管理和数据传送。\n我们可以将这两个职责抽象为两个接口，让一个手机类来实现。这样就能让这两个职责变得通用，手机类只需要实现自己想要的传输协议和数据传送方式就行。传输协议和传送方式这两个职责任意一个改变都不会影响到另一个职责，这使得代码改动变得更小。\n\n##### 第一步，创建业务对象\n{% codeblock lang:java %}\n/**\n * 协议管理\n */\npublic interface IConnectionManager {\n    void dial(String phoneNumber);\n    void hangup();\n}\n\n{% endcodeblock %}\n\n##### 第二步，创建业务逻辑\n{% codeblock lang:java %}\n/**\n * 数据传送管理\n */\npublic interface IDataTransfer {\n    void DataTransfer(IConnectionManager cm);\n}\n\n{% endcodeblock %}\n##### 第三步，创建手机类\n{% codeblock lang:java %}\n/**\n * 具体实现过程\n */\npublic class Phone implements IConnectionManager , IDataTransfer {\n    private String phoneNumber ;\n\n    public String getPhoneNumber() {\n        return phoneNumber;\n    }\n\n    public void setPhoneNumber(String phoneNumber) {\n        this.phoneNumber = phoneNumber;\n    }\n\n    public void dial(String phoneNumber) {\n        System.out.println(\"接电话\");\n    }\n\n    public void hangup() {\n        System.out.println(\"挂断电话\");\n    }\n\n    public void DataTransfer(IConnectionManager cm) {\n        cm.dial(phoneNumber);\n        System.out.println(\"通话\");\n        cm.hangup();\n    }\n}\n\n{% endcodeblock %}\n\n##### 第四步，测试\n{% codeblock lang:java %}\n @Test\n    public void test2(){\n        //先创建一个对象\n        IConnectionManager phone = new Phone();\n        //利用多态，将对象强制转换，让另一个引用指向对象\n        IDataTransfer dt = (IDataTransfer)phone ;\n        IConnectionManager cm = (IConnectionManager)phone ;\n        //通过对一个对象的不同的引用，再将多个引用进行组装，最终获得一个完整的过程\n        dt.DataTransfer(cm);\n    }\n{% endcodeblock %}\n\n#####　第五步，结果\n\n{% codeblock lang:java %}\n接电话\n通话\n挂断电话\n{% endcodeblock %}\n\n#### 单一职责的好处\n  1. 类的复杂性降低，实现什么职责都有清晰明确的定义\n  2. 复杂性降低，使得更具可读性。\n  3. 可读性提高，使得类更容易维护。\n  4. 类的变更引起的风险降低，这对系统的扩展性，维护性都有非常大的帮助。\n\n#### 单一职责的注意点\n  1. 单一职责中的职责没有一个量化的标准，其最难划分。\n  2. 单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。\n  3. 对于单一职责原则，接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。\n\n#### 自言自语\n一天又过去了，希望明天不下雨...\n","tags":["设计原则"],"categories":["设计原则"]},{"title":"合成复用原则","url":"%2F2019%2F05%2F19%2FJava%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%2F","tags":["Java"],"categories":["Java"]},{"title":"迪米特法则","url":"%2F2019%2F05%2F19%2FJava%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%2F","tags":["Java"],"categories":["Java"]},{"title":"接口隔离原则","url":"%2F2019%2F05%2F19%2FJava%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%2F","tags":["Java"],"categories":["Java"]},{"title":"依赖倒转原则","url":"%2F2019%2F05%2F19%2FJava%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%2F","content":"\n### 依赖倒置原则(Dependence Inversion Principle,DIP)\n> 就是面向接口编程\n#### 定义\n> High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.\n理解:高级别的模块(原子逻辑组装)不能依赖低级别的模块(不可分割的原子逻辑),两者都应该依赖抽象。抽象(接口或抽象类)不应该依赖细节(实现类)，细节应该依赖抽象。\n\n#### 含义\n  1. 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖冠以是通过接口或抽象类产生的。\n  2. 接口或者抽象类不依赖于实现类。\n  3. 实现类依赖接口或抽象类。\n\n\n\n\n","tags":["设计原则"],"categories":["设计原则"]},{"title":"里氏代换原则","url":"%2F2019%2F05%2F19%2FJava%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99%2F","content":"\n### 里式替换原则(Liskov Substitution Principle)\n#### 引言\n> 里式替换原则是用来约束继承的使用的一种规范。里式替换原则鼓励开发者使用接口或抽象类开发，用接口或抽象类的引用来调用对象。\n  + 继承的优点\n    代码共享，减少创建类的工作量。每个子类拥有父类的方法和属性。\n    提高代码的重用性。\n    子类完全继承父类，但也可以拥有自己的方法和属性，是对父类的扩展。\n    提高代码的可扩展性，扩展接口可以继承父类。\n    提高产品或项目的开放性。\n  + 继承的缺点\n    继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法。\n    降低代码的灵活性。子类必须拥有父类的属性和方法。\n    增强了耦合性。当父类被修改，子类也必须要进行响应的更改，这会导致代码的大量重构。\n  + **为了避免继承的缺点，引入里式替换原则**\n<!-- more -->\n#### 定义\n##### 第一种定义\n> If for each object o1 of type S there is an object o2 of type T such that for all progeams P defined in terms of T ,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T .\n如果对每一个类型为S的对象o1,都有类型为T的对象o2,使得以T定义的所有程序P在所有对象o1都代换为o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。\n理解：类型T的对象能够替换类型S的对象，也就是说类型T包含类型S(T是S的父类)\n\n##### 第二种定义\n> Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it\n所有引用基类的地方必须能透明地使用其子类的对象。\n理解：只要父类能出现的地方，子类就可以出现，而且替换子类也不会产生任何错误和异常，使用者根本不用知道是父类还是子类。但是有子类的地方，父类未必能适应。也就是说，父类对象和子类对象没有太大区别，使得使用者能够使用父类接口来使用子类对象。\n\n##### 含义\n  1. 子类必须完全实现父类的抽象方法，不能重写父类已实现的方法[应用](#1)\n    **子类必须完全实现父类的抽象方法：** 因为java中子类需要完整的实现父类的抽象方法，如果子类不完全实现父类抽象方法，那么这个子类也是一个抽象类，因为实体类必须完全实现抽象类的方法。在这里说的子类一般指代实体类，因此实体类必须完全实现抽象父类的抽象方法。\n    **子类不能重写父类已实现的方法：** 父类已实现的方法是一种已定好的契约和规范。\n  2. 子类可以有自己的个性[应用](#2) \n    子类继承了父类，拥有父类的方法，子类也能有自己的方法和属性。\n    如果子类转为父类类型很安全(向上转型，子类完全兼容父类)，但父类类型转子类类型则不安全(向下转型，子类有父类没有的东西，父类不能完全兼容子类)。\n  3. 覆盖或实现父类的方法时输入(**输入参数被称为前置条件**)可以被放大 [应用](#3) \n    子类重载父类方法时，当父类的参数类型范围比子类参数类型范围大时，子类会调用子类自己重载父类的方法，却不会调用子类继承父类的方法。这样子类并不能代替父类执行，不符合里式替换法则。\n    子类重载父类方法时，当父类参数类型范围小于子类参数类型范围时，子类对代替父类执行父类的方法。\n    因此，子类的参数范围需要大于或等于父类的参数类型范围，这样，会调用自动匹配子类继承父类的方法，不会调用子类重载的方法，从而使程序逻辑混乱。\n  4. 覆写或实现父类的方法时输出结果(**返回结果被称为后置条件**)可以被缩小[应用](#4)\n    父类一个方法返回值是类型T,子类重写或重载的方法返回值是S,那么T必须是S的父类(T大于等于S)\n#### 应用\n<h5 id=\"1\">应用场景1</h5>\n###### 子类必须完全实现父类的抽象方法\n  + 创建抽象父类\n{% codeblock lang:java %}\n/**\n * 应用场景\n * 飞机，圆了人类的飞天梦。飞机在20世纪初被发明。其也从最初的种类单一到现在的不同种类的多型机种\n */\npublic abstract class MilitaryAircraft {\n    /**\n     * 飞机能够飞行\n     */\n    public void fly(){\n        System.out.println(\"我能飞\");\n    }\n\n    /**\n     * 飞机型号\n     */\n    public abstract String type();\n\n    /**\n     * 飞机动作\n     */\n    public abstract void attack();\n\n    /**\n     * 类介绍\n     */\n    public abstract void intro();\n\n}\n\n{% endcodeblock %}\n  + 创建子类J20\n{% codeblock lang:java %}\n/**\n * J20第四代隐身重型战斗机\n */\npublic class J20 extends MilitaryAircraft {\n    @Override\n    public String type() {\n        return \"第四代隐身重型战斗机J20\";\n    }\n\n    @Override\n    public void attack() {\n        System.out.println(\"战斗机攻击\");\n    }\n\n    @Override\n    public void intro() {\n        System.out.println(\"我是解放军序列第四代隐身重型战斗机J20\");\n    }\n}\n{% endcodeblock %}\n  + 创建飞行员类\n{% codeblock lang:java %}\npublic class Pilot {\n    private MilitaryAircraft militaryAircraft;\n\n    public Pilot() {\n    }\n\n    public Pilot(MilitaryAircraft militaryAircraft) {\n        this.militaryAircraft = militaryAircraft;\n    }\n\n    public MilitaryAircraft getMilitaryAircraft() {\n        return militaryAircraft;\n    }\n\n    public void setMilitaryAircraft(MilitaryAircraft militaryAircraft) {\n        this.militaryAircraft = militaryAircraft;\n    }\n\n    public void fighting(){\n        System.out.println(\"飞行员驾驶\"+militaryAircraft.type()+\"开始战斗\");\n        militaryAircraft.attack();\n    }\n}\n{% endcodeblock %}\n+ 测试\n{% codeblock lang:java %}\npublic class Test {\n    public static void main(String[] args) {\n        //创建一个飞行员\n        Pilot pilot = new Pilot();\n        //为他分配一架飞机\n        pilot.setMilitaryAircraft(new J20());\n\n        pilot.fighting();\n    }\n}\n{% endcodeblock %}\n  + 测试结果\n  \n{% codeblock lang:java %}\n飞行员驾驶第四代隐身重型战斗机J20开始战斗\n战斗机攻击\n{% endcodeblock %}\n###### 如果子类没有完全实现父类的抽象方法(举例可能有失偏颇)\n  + 再创建子类(运输机不能攻击，如果这个子类直接继承父类，会出现问题)\n{% codeblock lang:java %}\n/**\n * C130大力神运输机\n */\npublic class C130 extends MilitaryAircraft {\n    @Override\n    public String type() {\n        return \"军用运输机C130\";\n    }\n\n    /**\n     * 运输机不能攻击,那就虚构一个攻击方法\n     */\n    @Override\n    public void attack() {\n\n    }\n\n    @Override\n    public void intro() {\n        System.out.println(\"我是美军序列军用运输机大力神C130\");\n    }\n}\n{% endcodeblock %}\n  + 测试\n  C130是运输机，是执行运输任务的飞机，并不是战斗单位，因此，不能继承父类的attack方法。\n{% codeblock lang:java %}\npublic class Test {\n    public static void main(String[] args) {\n        //创建一个飞行员\n        Pilot pilot = new Pilot();\n        //为他分配一架飞机\n        pilot.setMilitaryAircraft(new C130());\n\n        pilot.fighting();\n    }\n}\n{% endcodeblock %}\n  + 测试结果\n  上面的虚构一个攻击方法使得运输机也上了战场，但是没有战斗力，那只有被击落的份。\n{% codeblock lang:java %}\n飞行员驾驶军用运输机C130开始战斗\n{% endcodeblock %}\n  + 为了解决这个问题，我们必须将运输机这个子类与父类断开继承关系，再创建一个运输机父类，让C130继承这个。这使得C130运输机脱离战斗序列\n{% codeblock lang:java %}\npublic abstract class Transport {\n    private MilitaryAircraft militaryAircraft ;\n\n    public Transport() {\n    }\n\n    public Transport(MilitaryAircraft militaryAircraft) {\n        this.militaryAircraft = militaryAircraft;\n    }\n\n    /**\n     * 将飞机的主要功能委托给militaryAircraft处理，transport只需要处理运输机特有的就行了\n     */\n\n    public void fly(){\n        militaryAircraft.fly();\n    }\n    /**\n     * 飞机型号\n     */\n    public abstract String type();\n\n    /**\n     * 类介绍\n     */\n    public abstract void intro();\n\n    public abstract void transport();\n}\n\n{% endcodeblock %}\n  + 并改一下飞行员类\n{% codeblock lang:java %}\npublic class Pilot {\n    /**\n     * 这里使用的是委托机制\n     */\n    private MilitaryAircraft militaryAircraft;\n    private Transport transport ;\n\n    public Pilot() {\n    }\n\n    public Pilot(MilitaryAircraft militaryAircraft) {\n        this.militaryAircraft = militaryAircraft;\n    }\n\n    public Pilot(MilitaryAircraft militaryAircraft, Transport transport) {\n        this.militaryAircraft = militaryAircraft;\n        this.transport = transport;\n    }\n\n    public MilitaryAircraft getMilitaryAircraft() {\n        return militaryAircraft;\n    }\n\n    public void setMilitaryAircraft(MilitaryAircraft militaryAircraft) {\n        this.militaryAircraft = militaryAircraft;\n    }\n\n    public Transport getTransport() {\n        return transport;\n    }\n\n    public void setTransport(Transport transport) {\n        this.transport = transport;\n    }\n\n    public void transport(){\n        System.out.println(\"飞行员驾驶\"+transport.type());\n        transport.transport();\n    }\n\n    public void fighting(){\n        System.out.println(\"飞行员驾驶\"+militaryAircraft.type()+\"开始战斗\");\n        militaryAircraft.attack();\n    }\n}\n\n{% endcodeblock %}\n  + 测试\n{% codeblock lang:java %}\npublic class Test {\n    public static void main(String[] args) {\n        //创建一个飞行员\n        Pilot pilot = new Pilot();\n        //为他分配一架飞机\n        pilot.setTransport(new C130());\n        pilot.transport();\n    }\n}\n{% endcodeblock %}\n  + 测试结果\n{% codeblock lang:java %}\n飞行员驾驶军用运输机C130\n运输战略物资\n{% endcodeblock %}\n###### 子类不能重写父类已实现的方法\n  + 创建抽象父类\n{% codeblock lang:java %}\n/**\n * 父类有一个实现的方法\n */\npublic class Parent {\n    public int add(int a , int b){\n        return a+b ;\n    }\n}\n{% endcodeblock %}\n  + 创建子类\n{% codeblock lang:java %}\n/**\n * 子类继承父类，并且重写父类已经实现的方法\n */\npublic class Child extends Parent{\n    public int add(int a , int b){\n        return a+(-b) ;\n    }\n}\n{% endcodeblock %}\n  + 测试\n{% codeblock lang:java %}\npublic class Test {\n    public static void main(String[] args) {\n        /**\n         * 创建一个父类对象，父类对象调用父类的方法执行\n         */\n        Parent parent = new Parent();\n        System.out.println(\"执行父类\");\n        int add = parent.add(1, 4);\n        System.out.println(\"父类执行结果:\"+add);\n\n        /**\n         * 创建一个指向子类对象的父类引用\n         * 子类代替父类执行,最终执行的却是子类重写的方法\n         * 这并不是我们想要的结果，也就是这个程序中的子类不能代替父类执行\n         * 这违反了里式替换原则\n         */\n        Parent child = new Child();\n        System.out.println(\"执行子类\");\n        int add1 = child.add(1, 4);\n        System.out.println(\"之类执行结果:\"+add1);\n    }\n}\n{% endcodeblock %}\n  + 测试结果\n  父类执行的结果与子类代替父类执行的结果不同，这违反了里式替换原则\n{% codeblock lang:java %}\n执行父类\n父类执行结果:5\n执行子类\n之类执行结果:-3\n{% endcodeblock %}\n<h5 id=\"2\">应用场景2</h5>\n###### 子类可以有自己的个性\n  + 创建父类\n{% codeblock lang:java %}\npublic class Parrent {\n    public int max(int a , int b){\n        if(a == b){\n            System.out.println(a+\"==\"+b);\n            return 0 ;\n        }\n        return a>b?a:b;\n    }\n}\n{% endcodeblock %}\n  + 创建子类\n{% codeblock lang:java %}\npublic class Child extends Parrent{\n    public void intro(){\n        System.out.println(\"我是子类，我为我自己代言!\");\n    }\n}\n{% endcodeblock %}\n  + 创建测试类\n{% codeblock lang:java %}\npublic class Test {\n    public static void main(String[] args) {\n        /**\n         * 创建父类对象，调用父类的max方法\n         */\n        System.out.println(\"父类开始执行\");\n        Parrent parrent = new Parrent();\n        int max = parrent.max(3, 4);\n        System.out.println(\"最大值为：\"+max);\n\n        /**\n         * 创建子类对象，调用子类自己的方法\n         */\n        System.out.println(\"子类开始执行\");\n        Child child = new Child();\n        child.intro();\n    }\n}\n{% endcodeblock %}\n  + 测试结果\n  子类继承父类，但子类也可以有自己的方法，也就是个性。如果用父类的引用指向子类对象，使用的是父类方法，不能使用子类方法。如果子类引用指向子类对象，能调用子类方法和父类方法。\n{% codeblock lang:java %}\n父类开始执行\n最大值为：4\n子类开始执行\n我是子类，我为我自己代言!\n{% endcodeblock %}\n<h5 id=\"3\">应用场景3</h5>\n###### 覆盖或实现父类的方法时输入(**输入参数被称为前置条件**)可以被放大\n  + 创建父类\n{% codeblock lang:java %}\nimport java.util.HashMap;\n\npublic class Parrent {\n    public void function(HashMap map){\n        System.out.println(\"父类方法被执行\");\n    }\n}\n{% endcodeblock %}\n  + 创建子类\n{% codeblock lang:java %}\nimport java.util.Map;\n\npublic class Child extends Parrent{\n    public void function(Map map){\n        System.out.println(\"子类被执行\");\n    }\n}\n{% endcodeblock %}\n  + 创建测试类\n{% codeblock lang:java %}\nimport java.util.HashMap;\n\npublic class Test {\n    public static void main(String[] args) {\n        HashMap<Object, Object> map = new HashMap<>();\n        Parrent parrent = new Parrent();\n        Child child = new Child();\n        parrent.function(map);\n        child.function(map);\n    }\n}\n{% endcodeblock %}\n  + 测试结果\n{% codeblock lang:java %}\n父类方法被执行\n父类方法被执行\n{% endcodeblock %}\n###### 反例\n  + 创建父类\n{% codeblock lang:java %}\nimport java.util.Map;\n\npublic class Parrent {\n    public void function(Map map){\n        System.out.println(\"父类方法被执行\");\n    }\n}\n{% endcodeblock %}\n  + 创建子类\n{% codeblock lang:java %}\nimport java.util.HashMap;\n\npublic class Child extends Parrent{\n    public void function(HashMap map){\n        System.out.println(\"子类被执行\");\n    }\n}\n{% endcodeblock %}\n  + 创建测试类\n{% codeblock lang:java %}\nimport java.util.HashMap;\n\npublic class Test {\n    public static void main(String[] args) {\n        HashMap<Object, Object> map = new HashMap<>();\n        Parrent parrent = new Parrent();\n        Child child = new Child();\n        parrent.function(map);\n        child.function(map);\n    }\n}\n{% endcodeblock %}\n  + 测试结果\n{% codeblock lang:java %}\n父类方法被执行\n子类被执行\n{% endcodeblock %}\n<h5 id=\"4\">应用场景4</h5>\n###### 覆写或实现父类的方法时输出结果(**返回结果被称为后置条件**)可以被缩小\n  + 创建父类\n{% codeblock lang:java %}\nimport java.util.Map;\n\npublic abstract class Parrent {\n    public abstract Map function();\n}\n{% endcodeblock %}\n  + 创建子类\n{% codeblock lang:java %}\nimport java.util.HashMap;\n\npublic class Child extends Parrent{\n    /**\n     * 父类返回值类型可以比子类返回值类型范围大，这也是重写\n     * 父类返回值比子类返回值小，那就是重载了\n     * @return\n     */\n    @Override\n    public HashMap<Integer,String> function() {\n        HashMap<Integer, String> map = new HashMap<>();\n        map.put(1,\"Linux\");\n        map.put(2,\"Windows\");\n        map.put(3,\"mac\");\n        return map;\n    }\n}\n{% endcodeblock %}\n  + 创建测试类\n{% codeblock lang:java %}\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Test {\n    public static void main(String[] args) {\n        Child child = new Child();\n        HashMap<Integer,String> map = child.function();\n        Set<Map.Entry<Integer, String>> entrySet = map.entrySet();\n        for (Map.Entry<Integer,String> entry : entrySet){\n            Integer key = entry.getKey();\n            String value = entry.getValue();\n            System.out.println(key+\"-----\"+value);\n        }\n    }\n}\n{% endcodeblock %}\n  + 测试结果\n{% codeblock lang:java %}\n1-----Linux\n2-----Windows\n3-----mac\n{% endcodeblock %}\n","tags":["设计原则"],"categories":["设计原则"]},{"title":"开闭原则","url":"%2F2019%2F05%2F19%2FJava%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%2F","content":"\n### 开闭原则\n\n","tags":["Java"],"categories":["Java"]},{"title":"Spring框架","url":"%2F2019%2F05%2F19%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FSSM%2FSpring%E6%A1%86%E6%9E%B6%2F","content":"\n### Spring框架\n\n","tags":["Spring"],"categories":["Spring"]},{"title":"Java设计模式","url":"%2F2019%2F05%2F19%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F","content":"\n### 引言\n> “每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”\n>  -- Christopher Alexander\n设计模式是一组通用的模板，可以在任何一种面向对象的语言中实现，而已知的设计模式有23种。想要学好编程，就应该学会这些设计模式，让你的代码更鲁棒。那么，现在就开始我们的设计模式的学习...\n<!-- more -->\n### 什么是设计模式?\n#### 定义\n设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。可以说，设计模式大牛总结的编写代码的模板。\n#### 目的\n为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。\n\n### 设计要素[^1]\n#### 模式名称(pattern name)\n一个助记名，有见名知意的效果，通常用一两个词描述模式的问题、解决方案和效果。\n#### 问题(problem)\n应该在何时使用设计模式(设计模式对应的需要解决的现实工程问题)，也就是应用场景。\n#### 解决方案(solution)\n一套解决对应工程问题的解决流程。设计模式就是一个模板，可以应用于一类问题，它是从具体工程问题中抽象出来的对问题的描述和怎样将类与对象相互组合来解决问题。\n#### 效果(consequences)\n设计模式应用后能产生的效果及使用模式应权衡的问题。\n\n### 设计原则[^2]\n> 设计模式需要遵循设计原则，才能是一个通用的设计模式。\n  1. [开闭原则(Open Close Principle)](http://rack-leen.github.io/2019/05/19/Java/设计原则/开闭原则/)\n　　对扩展开放，对修改关闭。可以向外扩展，不能修改已存在的。\n  2. [里氏代换原则(Liskov Substitution Principle)](http://rack-leen.github.io/2019/05/19/Java/设计原则/里氏代换原则)\n　　只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。\n  3. [依赖倒转原则(Dependence Inversion Principle)](http://rack-leen.github.io/2019/05/19/Java/设计原则/开闭原则/依赖倒转原则)\n　　这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。\n  4. [接口隔离原则(Interface Segregation Principle)](http://rack-leen.github.io/2019/05/19/Java/设计原则/开闭原则/接口隔离原则)\n　　使用多个隔离的接口来降低耦合度。\n  5. [迪米特法则(最少知道原则)(Demeter Principle)](http://rack-leen.github.io/2019/05/19/Java/设计原则/开闭原则/迪米特法则)\n　　一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。\n  6. [合成复用原则(Composite Reuse Principle)](http://rack-leen.github.io/2019/05/19/Java/设计原则/开闭原则/合成复用原则)\n　　原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。\n  7. [单一职责原则 (Single responsibility principle)](http://rack-leen.github.io/2019/05/19/Java/设计原则/开闭原则/单一职责原则)\n    一个类应该只有一个发生变化的原因(职责)\n\n### 设计模式分类\n#### 以目的准则分类\n> 模式的用途(模式是用来干什么的)\n  1. 创建型模式\n    与对象的创建有关。包括5中设计模式，分别为: 工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。\n  2. 结构型模式\n    用于处理类和对象的组合。包括7中设计模式，分别为: 适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。\n  3. 行为型模式\n    描述类和对象的交互和分配职责。包括11中设计模式，分别为: 策略模式，模板方法模式，观察者模式，迭代子模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式。解释器模式。\n#### 以范围准则分类\n> 模式是用于类还是用于对象(对象<类)\n  1. 类模式\n    处理类和子类之间的关系，这些关系通过继承建立，是静态的，编译时就已经定下了。类模式的设计模式有创建型模式中的工厂方法模式，结构型中的适配器模式以及行为型中的模板方法模式和解释器模式。\n  2. 对象模式\n    处理对象间的关系，这些关系在运行时是变化的，是动态的。\n\n### 设计模式之间的关系\n  1. 创建型类模式将对象的创建工作延迟到子类。\n  2. 创建型对象模式将对象的创建工作延迟到另一个对象中。\n  3. 结构型类模式使用继承机制组合类。\n  4. 结构型对象模式描述对象的组装方式。\n  5. 行为型模式使用继承描述算法和控制流。\n  6. 行为型对象模式描述一组对象怎样协作完成单个对象无法完成的任务。\n\n### 所有设计模式\n#### 创建型模式\n##### 特点\n> 主要关注怎么创建对象。创建对象的工作由相关创建者进行创建。\n> 创建型模式包括类创建模式(工厂方法模式)和对象创建模式(其他模式)\n\n##### 创建型的设计模式\n  1. 单例模式\n  2. 原型模式\n  3. 工厂方法模式\n  4. 抽象工厂模式\n  5. 建造者模式\n#### 结构型模式\n#### 行为型模式\n\n### 自言自语\n  刚开始学设计模式，也不知道如何学，只有先找网上资源看看，自己再总结一下。这里只是列出了设计模式的概览，还没有深入了解。等之后再具体看看这些设计模式，争取吃透。\n\n### 参考文献\n\n[^1]: https://www.cnblogs.com/xdyixia/p/8177786.html\n[^2]: https://www.cnblogs.com/zhaojinyan/p/9401010.html\n","tags":["Java"],"categories":["Java"]},{"title":"原型模式","url":"%2F2019%2F05%2F19%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F","content":"\n## 原型模式\n\n### 定义\n> Specify the kinds of objects to create using a prototypical instance , and create new objects by copying this prototye.\n> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建对象。\n\n### 原型模式示意图\n![原型模式](原型模式.png)\n### 流程\n  1. 首先创建一个实体类，这个实体类需要实现Cloneable接口的clone()方法，这样能拥有克隆能力。\n  2. 然后创建一个对象，根据客户端需要，以创建的这个对象作为原型，克隆多个需要的对象，然后通过set方法将这些克隆的对象改为自己需要的对象。\n\n### 需求\n我们为幼儿园小朋友发成绩表，他们的年龄和成绩都一样，我们只需要改成绩表的名字就行了。\n### 代码实现\n  1. 创建一个学生类,作为拷贝原型\n```Java\n/**\n * 原型模式需要实现Cloneable接口\n */\n@Data\n@ToString\npublic class Student implements Cloneable {\n    private String name ;\n    private String age ;\n    private String score ;\n    private ArrayList<Student> students = new ArrayList<>();\n    private final ArrayList<Student> finalStudent = new ArrayList<>();\n\n    public Student(String name, String age, String score) {\n        this.name = name;\n        this.age = age;\n        this.score = score;\n        System.out.println(name + \"创建成功\");\n    }\n\n    /**\n     * 这个方法是原型模式的基础\n     * @return\n     * @throws CloneNotSupportedException\n     */\n    public Student clone()  {\n        System.out.println(\"学生拷贝成功\");\n        Student student = null ;\n        try {\n            // 这是一种浅拷贝，只能拷贝基本类型(包括string)，其他的数组这些引用类型就与原型对象共享。\n            student =  (Student) super.clone() ;\n            // 这个是深拷贝，将数组和引用一起拷贝，每个拷贝的对象有自己的数组和引用\n            this.students = (ArrayList<Student>) this.students.clone();\n\n            // 这个finalStudent是由final修饰，，不能重新赋值，不能拷贝\n            // this.finalStudent = (ArrayList<Student>) this.finalStudent.clone() ;\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n\n        return student ;\n    }\n}\n\n```\n  2. 开始发成绩表了\n```Java\npublic class Test {\n    public static void main(String[] args) {\n        Student rack = new Student(\"rack\", \"12\", \"16\");\n        Student clone = (Student) rack.clone();\n        clone.setName(\"leen\");\n\n        System.out.println(rack);\n        System.out.println(clone);\n    }\n}\n```\n### 原型模式扩展\n> 为原型模式增加一个原型管理器，用来管理原型的创建。\n#### 需求\n现在我们要创建一个学校，学校里面有教师，学生等实体，我们需要以一个教师和学生作为原型，创建出多个教师和学生。\n#### 代码实现\n  1. 创建一个学校接口，里面放入clone方法，使得所有实现它的实体都需要重写clone,拥有复制的能力。\n```Java\npublic interface School extends Cloneable {\n    public School clone();\n}\n```\n  2. 创建一个学生类,实现学校接口。\n```Java\n@Data\n@ToString\npublic class Student implements School {\n    private String name ;\n    private String age ;\n    private String score ;\n    private ArrayList<Student> students = new ArrayList<>();\n    private final ArrayList<Student> finalStudent = new ArrayList<>();\n\n    public Student(String name, String age, String score) {\n        this.name = name;\n        this.age = age;\n        this.score = score;\n        System.out.println(name + \"创建成功\");\n    }\n\n    /**\n     * 这个方法是原型模式的基础\n     * @return\n     * @throws CloneNotSupportedException\n     */\n    public Student clone()  {\n        System.out.println(\"学生拷贝成功\");\n        Student student = null ;\n        try {\n            // 这是一种浅拷贝，只能拷贝基本类型(包括string)，其他的数组这些引用类型就与原型对象共享。\n            student =  (Student) super.clone() ;\n            // 这个是深拷贝，将数组和引用一起拷贝，每个拷贝的对象有自己的数组和引用\n            this.students = (ArrayList<Student>) this.students.clone();\n\n            // 这个finalStudent是由final修饰，，不能重新赋值，不能拷贝\n            // this.finalStudent = (ArrayList<Student>) this.finalStudent.clone() ;\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n\n        return student ;\n    }\n}\n\n```\n  3. 创建一个教师类\n```Java\n@Data\n@ToString\npublic class Teacher implements School {\n    private String name ;\n    private String age ;\n    private String subject ;\n\n    public Teacher(String name, String age, String subject) {\n        this.name = name;\n        this.age = age;\n        this.subject = subject;\n    }\n\n    public Teacher clone(){\n        Teacher teacher = null ;\n        try {\n            teacher = (Teacher) super.clone();\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n\n        return teacher ;\n    }\n}\n\n```\n  5. 创建一个原型管理器，我们如果需要更多的职位，比如校长等，我们直接通过原型管理器将原型对象加入进去，使其能拥有复制能力。\n```Java\npublic class PrototypeManager {\n    public Map<String , School> map = new HashMap<>();\n\n    /**\n     * 增加除了教师学生之外的学校职位\n     * @param key\n     * @param value\n     */\n    public void add(String key , School value){\n        this.map.put(key , value);\n    }\n\n    /**\n     * 从原型池中获取原型，如果原型不存在，抛异常\n     * @param key\n     * @return\n     */\n    public School get(String key){\n        School school = null;\n        try {\n            school = this.map.get(key);\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        return school ;\n    }\n}\n```\n\n  4. 场景实现\n```Java\npublic class Test {\n    public static void main(String[] args) {\n        PrototypeManager prototypeManager = new PrototypeManager();\n        prototypeManager.add(\"teacher\" , new Teacher(\"teacher1\" , \"21\" , \"数学\"));\n        Teacher teacher1 = (Teacher)prototypeManager.get(\"teacher\");\n        Teacher teacher2 = teacher1.clone();\n        teacher2.setName(\"teacher2\");\n\n        prototypeManager.add(\"student\" , new Student(\"student1\" , \"12\" , \"45\"));\n        Student student1 = (Student)prototypeManager.get(\"student\");\n        Student student2 = student1.clone();\n        student2.setName(\"student2\");\n\n        System.out.println(teacher1);\n        System.out.println(teacher2);\n        System.out.println(student1);\n        System.out.println(student2);\n    }\n}\n```\n### 应用场景\n  1. 一个对象有多个修改者。\n  2. 类初始化需要很多资源，我们要优化的话，就直接克隆一个对象，不需要再创建。\n  3. 通过new产生一个对象很繁琐，为了简化，我们直接copy就行了。\n原型模式就像我们复制粘贴一样，文章大体不变，只变一些细节。\n原型模式一般与工厂模式一起用；原型模式已经和java融为一体，随手就能用。\n\n### 原型模式的优点和注意事项\n\n#### 优点\n  1. 原型模式是在内存二进制流的拷贝，比直接new一个对象消耗性能少。\n  2. 在内存中拷贝，构造函数不会被执行，这就逃避构造函数的约束。\n#### 注意事项\n  1. 如果实体类中只有基本数据类型和string，就用浅拷贝进行克隆。\n  2. 如果实体类中还有数组和引用，就需要单独为它们进行深拷贝。\n  3. 使用clone后，克隆一个对象是直接拷贝二进制流，不会执行构造函数。如果需要使用构造函数，就不能使用原型模式。\n  4. 变量前加了final关键字，就不能使用clone进行拷贝。\n","tags":["创建型模式"],"categories":["创建型模式"]},{"title":"单例模式","url":"%2F2019%2F05%2F19%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F","content":"## 单例模式\n\n### 定义\n> Ensure a class has only one instance , and provide a global point of access to it.\n> 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。\n\n### 单例模式示意图\n![单例模式](单例模式.png)\n\n### 流程\n  1. 客户向单例提供者请求实例\n  2. 单例提供者使用类名.getInstance()从单例类中获取唯一实例\n  3. 这个唯一实例在单例类中先被创建(单例类只能创建一个实例)。单例类通过暴露getInstance()这个静态方法，让外界可以获取这个单个实例。\n \n### 代码实现\n  1. 普通单例模式(饿汉式)\n```Java\n/**\n * 普通单例模式(饿汉式)\n * 一开始就初始化，线程安全，比较常用，但容易产生垃圾\n *\n * 为什么线程安全？\n * 类加载的方式是按需加载，且只加载一次。当单例类加载完成后，单例实例就被创建供系统使用，线程每次只能获取这一个实例。\n */\npublic class SingleTonCommon {\n    private static final SingleTonCommon singleTon = new SingleTonCommon();\n\n    /* 不让外界调用创建对象，只能让singleTon成员变量创建对象 */\n    private SingleTonCommon(){\n\n    }\n\n    public static SingleTonCommon getInstance(){\n        return singleTon ;\n    }\n\n    /* 单例类里面的类方法不能被外界访问 */\n    public static void test(){\n        System.out.println(\"普通单例模式(饿汉式)\");\n    }\n\n    /* 可以被外界访问的方法 */\n    public void getTest(){\n        test();\n    }\n}\n\n```\n  2. 普通单例模式(懒汉式)\n```Java\n/**\n * 普通单例模式(懒汉式)\n * 线程不安全，延迟初始化。\n *\n * 为什么线程不安全？\n * 当两个线程同时创建单例对象，线程1到达singleTon == null , 线程1判断完后，还没有创建对象，线程2就抢占cpu资源，开始运行。\n * 这时线程2也到达singleTon == null,并且判断为空，创建一个对象。之后释放cpu资源，线程1再次抢占cpu资源。\n * 这时线程1还是原来的状态singleTon == null,判断为空，线程1再次创建一个对象，这就产生两个对象。\n */\npublic class SingleTonCommon2 {\n    private static SingleTonCommon2 singleTon ;\n\n    private SingleTonCommon2(){\n\n    }\n\n    public static SingleTonCommon2 getInstance(){\n        if (singleTon == null){\n            singleTon = new SingleTonCommon2();\n        }\n        return singleTon ;\n    }\n\n    /* 单例类里面的类方法不能被外界访问 */\n    public static void test(){\n        System.out.println(\"普通单例模式(懒汉式)\");\n    }\n\n    /* 可以被外界访问的方法 */\n    public void getTest(){\n        test();\n    }\n}\n```\n  3. synchronized单例模式(懒汉式线程安全版)\n```Java\n/**\n * synchronized单例模式单例模式\n *\n * 线程安全，延迟初始化\n *\n * 为什么线程安全？\n * 双重锁单例模式就是懒汉式的升级版，懒汉式在singleTon == null判断时可能会有其他线程能创建多的对象。\n * 但是这里使用synchronized同步锁，使得每次判断只能进一个，就只能创建一个对象。\n */\npublic class SingleSynchronized {\n    private static SingleSynchronized singleTon ;\n\n    private SingleSynchronized(){\n\n    }\n\n    public static SingleSynchronized getInstance(){\n        // 第一次判断singleTon == null是在synchronized代码块之外判断，为了避免已经创建了对象还要进入同步代码块的情况，提高效率。\n        if (singleTon == null){\n            // 与懒汉式情况不同，当线程1到singleTon == null,并进入判断，但是还没创建线程就被线程2抢占cpu资源，然后线程2先一步创建对象\n            // 这时虽然线程1已经进入判断，但是因为加入了synchronized线程同步锁，synchronized保证两个线程都是为了创建同一个对象，线程2已经创建线程1就不需要再创建了。\n            synchronized (SingleSynchronized.class){\n                if (singleTon == null){\n                    singleTon = new SingleSynchronized();\n                }\n            }\n        }\n        return singleTon ;\n    }\n\n    /* 单例类里面的类方法不能被外界访问 */\n    public static void test(){\n        System.out.println(\"synchronized单例模式\");\n    }\n\n    /* 可以被外界访问的方法 */\n    public void getTest(){\n        test();\n    }\n}\n\n```\n  4. volatile单例模式(懒汉式线程安全版)\n```Java\n/** volatile可以保证可见性,同时保证JVM指令不会进行重排序。\n * 创建对象是需要有几个步骤，通过jvm指令来创建的\n * 创建对象步骤：获取1.singleTon对象需要的内存地址-->2.初始化singleTon对象-->3.将引用变量singleTon指向获取的内存地址\n * volatile禁止jvm对指令进行重排序，因此指令顺序总是1-->2-->3\n */\npublic class SingleTonVolatitle {\n    private volatile static SingleTonVolatitle singleTon ;\n\n    private SingleTonVolatitle(){\n\n    }\n\n    /**\n     * 虽然volatile不能保证原子性，但是singleTon赋值堆中的引用是原子操作\n     * 如果被两个线程执行， new SingleTonVolatitle()会执行两次，但是赋值操作只进行一次。\n     * @return\n     */\n    public SingleTonVolatitle getInstance(){\n        if (singleTon == null) {\n            singleTon = new SingleTonVolatitle();\n        }\n        return singleTon ;\n    }\n\n    /* 单例类里面的类方法不能被外界访问 */\n    public static void test(){\n        System.out.println(\"volatile单例模式\");\n    }\n\n    /* 可以被外界访问的方法 */\n    public void getTest(){\n        test();\n    }\n}\n\n```\n  5. 静态内部类单例模式\n```Java\n/**\n * 静态内部类单例模式\n *\n * 只有第一次调用getInstance方法时，虚拟机才加载静态内部类并初始化，只有一个线程获得对象的初始化锁，其他线程无法进行初始化。\n */\npublic class SingleTonStaticInner {\n    private SingleTonStaticInner(){\n\n    }\n\n    public SingleTonStaticInner getInstance(){\n        return Inner.singleTon ;\n    }\n\n    /**\n     * 静态内部类只有在被加载的时候才会被初始化，并且其生命周期直到系统结束才会结束。\n     * 这样就保证有且只有一个对象，不管有多少为线程调用getInstance,都是取的同一个对象\n     * 因此，静态内部类能保证单例唯一性，延迟单例实例化以及保证线程安全\n     *\n     * 但是静态内部类无法传递参数\n     */\n    private static class Inner{\n        private static final SingleTonStaticInner singleTon = new SingleTonStaticInner();\n    }\n}\n```\n  6. 枚举单例模式\n```Java\n/**\n * 枚举单例模式\n * 枚举和普通类一样，都拥有字段和方法\n * 枚举的构造方法只能被声明为私有构造方法\n * 枚举是线程安全的，并且在任何情况下，它都是一个单例(我们通过枚举类.INSTANCE就能获得枚举对象)\n */\npublic enum  SingleTonEnum {\n    INSTANCE;\n    \n    public static SingleTonEnum Instance(){\n        return SingleTonEnum.INSTANCE ;\n    }\n}\n```\n  7. 静态代码块单例模式\n```Java\n/**\n * 静态代码块单例模式\n * 静态代码块是在单例类在虚拟机中一加载就被调用，并且只调用一次\n * 因此静态代码块单例也是线程安全的\n */\npublic class SingleTonStatic {\n    private static SingleTonStatic singleTon ;\n    private SingleTonStatic(){\n\n    }\n\n    static {\n        singleTon = new SingleTonStatic();\n    }\n}\n```\n### 应用场景\n  1. 要求生成唯一序列号的环境。\n  2. 在整个项目中需要一个共享访问点或共享数据，例如一个web页面的计数器，不用把每次刷新都记录到数据库，使用单例模式保持计数器的值，并确保线程安全。\n  3. 创建一个对象需要消耗的资源很多，如要访问IO或数据库。\n  4. 需要定义大量的静态常量或静态方法。\n\n### 单例模式优缺点\n\n#### 优点\n  1. 对象的创建会占用内存，只有一个实例对象，这样减少内存开支。\n  2. 对象会占用系统资源，只有一个实例对象，会减少系统性能开销。\n  3. 多个实例在内存中可能会产生对多重占用问题，单例模式可以避免这种情况发生。\n  4. 单例模式可以在全局设置一个访问点，这样可以优化和共享资源访问。\n\n#### 缺点\n  1. 没有接口，扩展困难。\n  2. 在并发环境下，单例模式没有完成是不能进行测试的，也不能使用mock虚拟一个对象。\n  3. 单例模式与单一职责原则有冲突。\n \n### 单例的扩展\n> 能产生固定数量对象的模式叫有上限的多例模式。\n```Java\nimport java.util.ArrayList;\n\n/**\n * 单例的扩展\n * 有上限的多例\n */\npublic class SingleTonExtension {\n    /* 定义需要产生的对象数量 */\n    private static int maxNumSingleTon = 2 ;\n\n    /* 将所有产生的对象放入这个容器，ArrayList是线程不安全的，可以使用线程安全的容器 */\n    private static ArrayList<SingleTonExtension> singleTons = new ArrayList<>();\n\n    private SingleTonExtension(){\n\n    }\n\n    /* 使用静态代码块实现单例 */\n    static {\n        for (int i=0 ; i<maxNumSingleTon ; i++) {\n            singleTons.add(new SingleTonExtension());\n        }\n    }\n}\n```\n### 文献引用\n  1. [Java双重校验锁实现单例模式](https://blog.csdn.net/May_3/article/details/82180961)\n  2. [设计模式之单例模式](https://jianshu.com/p/3bfd916f2bb2)\n  3. [volatile](https://www.jianshu.com/p/638ac7c82110)\n  4. [Java 枚举](https://www.cnblogs.com/jingmoxukong/p/6098351.html)\n  5. [Java之static静态代码块](https://www.cnblogs.com/Heliner/p/10524699.html)\n  6. [深入理解单例模式：静态内部类单例原理](https://blog.csdn.net/mnb65482/article/details/80458571)\n  \n","tags":["创建型模式"],"categories":["创建型模式"]},{"title":"建造者模式","url":"%2F2019%2F05%2F19%2FJava%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F","content":"\n## 建造者模式\n\n### 定义\n> Separate the construction of a complex object from its representation so that the same construction process can create different representations.\n> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n### 建造者模式示意图\n![建造者模式](建造者模式.png)\n\n### 流程\n  1. 客户想要对象实例，需要知会指挥者，给指挥者提需求。\n  2. 指挥者获取到客户需求（需要创建对象实例）,将需求解构，分配给相应的建造者进行建造。\n  3. 建造者之间相互独立，建造各自的需求，最终组装成具体的产品。\n  4. 产品就是最终的对象实例，返回给客户。\n \n### 需求\n现在客户需要订购东风，奔驰，宝马三种汽车各100辆。四种车的生产顺序是一样的。\n客户的需求给指挥者，指挥者将这四种车分别分配给四个建造者建造。\n\n### 代码实现\n  1. 先通过模板方法模式创建出三种汽车实例,这里先创建汽车模板\n```Java\n/**\n * 建造者模式的这个抽象类有模板方法模式的影子\n */\npublic abstract class Car {\n    private ArrayList<String> sequence = new ArrayList<>();\n    protected abstract void start();\n    protected abstract void stop();\n    protected abstract void alarm();\n    protected abstract void engineBoom();\n\n    /**\n     * 加了final关键字表示run方法和setSequense方法都不能被继承或重写\n     *\n     * run方法就是模板方法模式中的功能一样，这个更灵活，能自定义执行顺序\n     */\n    final public void run(){\n        for (int i=0 ; i<sequence.size() ; i++){\n            String name = this.sequence.get(i);\n            if (\"start\".equals(name)){\n                this.start();\n            }else if (\"stop\".equalsIgnoreCase(name)){\n                this.stop();\n            }else if (\"alarm\".equalsIgnoreCase(name)){\n                this.alarm();\n            }else if (\"engineBoom\".equalsIgnoreCase(name)){\n                this.engineBoom();\n            }\n        }\n    }\n\n    /**\n     * 从外界传进入执行顺序\n     * @param sequence\n     */\n    final public void setSequence(ArrayList<String> sequence){\n        this.sequence = sequence ;\n    }\n}\n```\n  2. 然后通过汽车模板创建出三个以这个模板构建的功能相同的不同种类的汽车类\n奔驰汽车\n```Java\npublic class Benz extends Car {\n    @Override\n    protected void start() {\n        System.out.println(\"奔驰是这样启动的\");\n    }\n\n    @Override\n    protected void stop() {\n        System.out.println(\"奔驰是这样停下来的\");\n    }\n\n    @Override\n    protected void alarm() {\n        System.out.println(\"奔驰的喇叭声音是这样的\");\n    }\n\n    @Override\n    protected void engineBoom() {\n        System.out.println(\"奔驰的引擎声音是这样的\");\n    }\n}\n```\n宝马汽车\n```Java\npublic class BMW extends Car {\n    @Override\n    protected void start() {\n        System.out.println(\"宝马是这样启动的\");\n    }\n\n    @Override\n    protected void stop() {\n        System.out.println(\"宝马是这样停下来的\");\n    }\n\n    @Override\n    protected void alarm() {\n        System.out.println(\"宝马的喇叭声音是这样的\");\n    }\n\n    @Override\n    protected void engineBoom() {\n        System.out.println(\"宝马的引擎声音是这样的\");\n    }\n}\n```\n东风汽车\n```Java\npublic class Dongfeng extends Car{\n    @Override\n    protected void start() {\n        System.out.println(\"东风是这样启动的\");\n    }\n\n    @Override\n    protected void stop() {\n        System.out.println(\"东风是这样停下来的\");\n    }\n\n    @Override\n    protected void alarm() {\n        System.out.println(\"东风的喇叭声音是这样的\");\n    }\n\n    @Override\n    protected void engineBoom() {\n        System.out.println(\"东风的引擎声音是这样的\");\n    }\n}\n```\n  3. 根据不同的汽车类，为它们分配不同的建造者\n奔驰汽车的建造者\n```Java\npublic class BenzBuilder extends CarBuilder {\n    /* 这里先创建一个产品 */\n    private Benz benz = new Benz();\n\n    /*然后为产品设置制造顺序*/\n    @Override\n    public void setSequense(ArrayList<String> sequense) {\n        this.benz.setSequence(sequense);\n    }\n\n    /* 产品创建完成就返回这个产品 */\n    @Override\n    public Car getCar() {\n        return this.benz;\n    }\n}\n```\n宝马汽车的建造者\n```Java\npublic class BMWBuilder extends CarBuilder {\n    private BMW bmw = new BMW();\n    @Override\n    public void setSequense(ArrayList<String> sequense) {\n        this.bmw.setSequence(sequense);\n    }\n\n    @Override\n    public Car getCar() {\n        return this.bmw;\n    }\n}\n```\n东风汽车的建造者\n```Java\npublic class DongFengBuilder extends CarBuilder {\n    private Dongfeng dongfeng = new Dongfeng();\n    @Override\n    public void setSequense(ArrayList<String> sequense) {\n        this.dongfeng.setSequence(sequense);\n    }\n\n    @Override\n    public Car getCar() {\n        return this.dongfeng;\n    }\n}\n```\n  4. 建造者要建造汽车，需要有总指挥分配需求，进行调度，这里需要有一个总指挥\n```Java\n/**\n * 这是所有建造者的指挥者，它来只会建造者建造产品\n */\npublic class Director {\n    private ArrayList<String> sequense = new ArrayList<>();\n    private BenzBuilder benzBuilder = new BenzBuilder();\n    private BMWBuilder bmwBuilder = new BMWBuilder();\n    private DongFengBuilder dongFengBuilder = new DongFengBuilder();\n\n    /**\n     * 宝马模型\n     */\n    public BMW getBMW(){\n        this.sequense.clear();\n        this.sequense.add(\"start\");\n        this.sequense.add(\"stop\");\n\n        this.bmwBuilder.setSequense(this.sequense);\n        return (BMW) this.bmwBuilder.getCar();\n    }\n    /**\n     * 奔驰模型\n     */\n    public Benz getBenz(){\n        this.sequense.clear();\n        this.sequense.add(\"start\");\n        this.sequense.add(\"alarm\");\n        this.sequense.add(\"stop\");\n\n        this.benzBuilder.setSequense(this.sequense);\n        return (Benz) this.benzBuilder.getCar();\n    }\n    /**\n     * 东风模型\n     */\n    public Dongfeng getDongFeng(){\n        this.sequense.clear();\n        this.sequense.add(\"start\");\n        this.sequense.add(\"engineBoom\");\n        this.sequense.add(\"stop\");\n\n        this.dongFengBuilder.setSequense(this.sequense);\n        return (Dongfeng) this.dongFengBuilder.getCar();\n    }\n\n}\n```\n  5. 最后，任务分配成功，开始为我们的客户建造需要的产品，场景实现\n```Java\npublic class Test {\n\n    public static void main(String[] args) {\n        Director director = new Director();\n        /**\n         * 我们这里是通过指挥者操作建造者建造的产品实例\n         */\n        /* 奔驰建造 */\n        for (int i=0 ; i<100 ; i++){\n            director.getBenz().run();\n        }\n        /* 宝马建造 */\n        for (int i=0 ; i<100 ; i++){\n            director.getBMW().run();\n        }\n        /* 东风建造 */\n        for (int i=0 ; i<100 ; i++){\n            director.getDongFeng().run();\n        }\n    }\n\n}\n```\n### 应用场景\n  1. 相同的功能，不同的执行顺序，产生不同结果。\n  2. 多个部件或零件，可以装配到一个对象，但产生结果又不相同。\n  3. 产品类非常复杂，调用其顺序不同会产生不同结果。\n  4. 在创建对象时会使用系统的其他对象，这些对象在产品创建过程中不易得到。\n\n### 建造者模式的优点和注意事项\n\n#### 优点\n  1. 建造者模式可以使客户不需要知道生产产品的细节，只需要将需求给指挥者就行了，指挥者会让建造者根据产品模型进行建造。这就使得封装性很好。\n  2. 一个建造者对应一个产品类型，建造者之间是互相独立的，如果需要新增一个产品类型，只需要新增一个建造者就能扩展。这使得其扩展性很好。\n  3. 由于产品对象实例是由建造者建造，我们可以对建造过程进行细化，而不对其他模块产生影响。\n#### 注意事项\n  1. 建造者注重工艺顺序，与工厂模式的注重点不同。\n","tags":["创建型模式"],"categories":["创建型模式"]},{"title":"Spring框架(一)","url":"%2F2019%2F05%2F14%2FJava%2FJava%E6%A1%86%E6%9E%B6%2FSSM%2FSpring%E6%A1%86%E6%9E%B6%2FSpring%E6%A1%86%E6%9E%B6-%E4%B8%80%2F","content":"\n### Spring简介\nSpring 是一个开放源代码的设计层面框架，解决的是业务逻辑层和其他各层的松耦合\n","tags":["Spring"],"categories":["Spring"]},{"title":"APUE学习笔记-进程控制","url":"%2F2019%2F05%2F10%2FAPUE%2FAPUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FAPUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%2F","content":"\n### 进程控制\n\n#### 进程标识\n  + 定义\n    每个进程都有一个非负整型的唯一进程ID。\n  + 专用进程\n    **ID 0进程**，是调度进程，通常被称为交换进程（并不执行硬盘上的程序）。它是内核的一部分，因此被称为系统进程。\n    **ID 1进程**，通常是init进程，在系统自举过程（系统自己启动自己）结束后 **由内核调用** 。init通常读与系统有关的初始化文件，并将系统引导至一个状态（多用户），init进程决不会终止。它是一个 **普通的用户进程** ，但是以 **超级用户特权** 运行。它是所有 **孤儿进程的父进程**。\n    **ID 2进程**，是页守护进程(pagedaemon)，也是内核进程(系统进程)。负责支持虚存系统的请页操作。\n  + 获取pid的函数\n{% codeblock lang:C %}\n#include <sys/types.h>\n#include <unistd.h>\n\npid_t getpid(void); //返回调用进程的进程id\npid_t getppid(void); //返回调用进程的父进程id\npid_t getuid(void); //返回调用进程的实际用户id\npid_t geteuid(void); //返回调用进程的有效用户id\ngid_t getgid(void); //返回调用进程的实际组id\ngid_t getegid(void); //返回调用进程的有效组id\n{% endcodeblock %}\n","tags":["APUE"],"categories":["APUE学习笔记"]},{"title":"APUE学习笔记-UNIX进程的环境","url":"%2F2019%2F05%2F05%2FAPUE%2FAPUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FAPUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-UNIX%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8E%AF%E5%A2%83%2F","content":"\n### UNIX进程的环境\n\n#### 了解main函数\n + main函数原型\n{% codeblock lang:C %}\n\n/*******************************************\n  int argc     : 命令行参数个数\n  char *argv[] : 命令行输入的所有参数依次放入数组中,argv[0]是命令本身\n  char *envp[] : 存储的是系统环境变量\n  notice       : POSIX规定使用extern **environ而不使用envp参数\n                 通常使用getenv函数和putenv函数来存储特定的环境变量而不是environ\n                 如果要查看整个环境，只能使用environ指针\n********************************************/\nint main(int argc , char *argv[] , char *envp[]);\n\n/*\n   应用extern\n */\n#include <stdio.h>\nextern char **environ ; \nint main(void)\n{\n  while(*environ)\n  {\n    printf(\"%s\\n\",*environ); /* 打印一行字符串 */\n    *environ++ ; /* 一行行的增加 */\n  }\n  return 0 ;\n}\n{% endcodeblock %}\n<!-- more -->\n + main启动过程\n  内核启动C程序时(使用exec启动,内核使程序执行的唯一方法是调用一个exec函数)，在调用main前先调用一个特殊的起动例程(这个起动例程被指定为程序的起始地址)，起动例程从内核取得命令行参数(argc , argv)和环境变量值(envp)，然后为调用main函数作安排  \n程序结束时，起动例程将调用main函数返回。调用形式:\n{% codeblock lang:C %}\nexit(main(argc , argv));\n{% endcodeblock %}\n一个C程序的起动和终止  \n\n![一个C程序的起动和终止](APUE学习笔记-UNIX进程的环境/一个C程序的起动和终止.png)\n\n#### 进程终止\n##### 终止方式\n###### 正常终止\n  + 从main返回\n  + 调用exit(需要先执行一些标准IO库的清除处理，然后进入内核)\n  + 调用_exit(立即进入内核)\n###### 异常终止\n  + 调用abort\n  + 由信号终止\n\nexit和_exit\n{% codeblock lang:C %}\n/*\n注意：main调用exit函数时带终止状态，则能识别主进程是终止状态，从而函数停止；如果不带终止状态，有些没有返回值的main函数的终止状态则未定义\n      使用exit或者_exit代替return,可以使得main返回void而不是int时，然后仍旧调用exit,可以避免不必要的警告\n */\n#include <stdlib.h>\n/*******************************************\n  int status : 终止状态\n  return     : 无返回值\n  notice     : 调用时，需要先清除标准IO库的调用(exit是ANIC C标准函数),再进入内核\n********************************************/\nvoid exit(int status);\n\n#include <unistd.h>\n/*******************************************\n  int status : 终止状态\n  return     : 无返回值\n  notice     : 调用时，立即进入内核\n********************************************/\nvoid _exit(int status);\n{% endcodeblock %}\n\natexit函数用来登记终止处理程序(一个进程可以登记多至32个函数，这些函数由exit自动调用)\n{% codeblock lang:C %}\n#include <stdlib.h>\n/*******************************************\n  void (*func)(void) : 一个函数指针，指向需要被登记的函数\n  return             : 成功返回0,出错返回非0\n  function           : 通过函数指针，登记函数指针指向的函数，登记后返回状态码\n  notice             : exit以登记这些函数的相反顺序调用它们。同一函数登记多次，则也被调用多次\n********************************************/\nint atexit(void (*func)(void));\n{% endcodeblock %}\natexit应用\n{% codeblock lang:C %}\n#include \"../../include/apue.h\"\n#include \"../../include/standard_error.h\"\nstatic void my_exit1(void) , my_exit2(void) ;\n/***********************************************\n  程序首先打印main is done , 之后调用atexit来注册函数，\n  并将这些函数压栈，依次从前往后压栈。\n  最终，main函数调用exit函数返回值,exit函数依次从栈中\n  取出被注册的函数，依次销毁，最终返回状态码\n  因此，程序运行为：\n    main is done\n    can't register my_exit2\n    can't register my_exit2\n    can't register my_exit1\n************************************************/\nint main(void)\n{\n  if(atexit(my_exit1) != 0)\n  {\n    err_sys(\"can't register my_exit1\");\n  }\n\n  if(atexit(my_exit2) != 0)\n  {\n    err_sys(\"can't register my_exit2\");\n  }\n  if(atexit(my_exit2) != 0)\n  {\n    err_sys(\"can't register my_exit2\");\n  }\n  printf(\"main is done\\n\");\n  return 0 ;\n}\nstatic void my_exit1(void)\n{\n  printf(\"first exit handler\\n\");\n}\nstatic void my_exit2(void)\n{\n  printf(\"second exit handler\\n\");\n}\n{% endcodeblock %}\n\n#### C程序的存储空间布局\nC程序由下面几部分组成\n  + .text\n    文本段，保存的是代码(程序代码在存储器中的副本)，只读,通常可以共享\n  + .data\n    初始化数据段，包含了程序中需要赋值的变量，为它们开辟空间存放，初始化后的全局变量和静态局部变量都放在这里，属于静态内存分配\n  + .bss\n    未初始化数据段，在程序开始执行之前，内核将此段初始化为0,未初始化的全局变量和静态局部变量都放在这里(也可以放在data中，但是会增加文件大小),属于静态内存分配\n  + .rodata\n    存放C中的字符串和#define定义的常量\n  + heap\n    堆用来存放进程运行中被动态分配的内存段，可以动态扩张和缩减，我们使用malloc函数就是在堆中取空间，使用free函数释放这些分配的空间\n    在32位下，堆最大可分配2.9G(程序逻辑地址大小，是虚拟的内存空间大小)\n  + stack\n    自动变量(用户创建的临时变量)以及每次函数调用时所需保存的信息都放在此段中\n    函数在被调用时，其参数会被压入栈中，调用结束后，函数返回值也会被存放到栈中\n    可以把栈看做寄存交换临时变量的内存区\n  + comment\n    存放编译器版本信息\n  + 其他的\n    .ELF header: 它描述整个文件的基本属性，比如ELF文件版本，目标机器型号，程序入口地址等。\n    .debug段: 包含调试信息。\n    .line段：调试时的行号，即源代码行号与编译后指令的对应表。\n    .hash段：符号哈希表。\n    .strtab段：String Table :字符串表，用于存储ELF文件中用到的各种字符串。\n下图显示了段的典型安排(正文段从0开始，栈顶从0x7fffffff开始)\n![典型的存储器安排](APUE学习笔记-UNIX进程的环境/典型的存储器安排.png)\n    \n\n#### 静态库\n静态库在linux上以.a结尾,在windows上以.lib结尾\n静态库的代码在编译时就拷贝到应用程序中，成为程序的一部分。这样可以节省编译时间，并且程序不需要依赖就能使用。但是这使得程序体积很庞大。\n创建静态库\nmy_lib.h\n{% codeblock lang:C %}\n#ifndef _my_lib_h_\n#define _my_lib_h_\nvoid welcome(void);\nvoid outstring(const char *str);\n#endif\n{% endcodeblock %}\nmy_lib.c\n{% codeblock lang:C %}\n#include \"my_lib.h\"\n#include <stdio.h>\nvoid welcome(void)\n{\n  printf(\"Welcome to libmylib\\n\");\n}\nvoid outstring(const char *str)\n{\n  if(str != NULL)\n  {\n    printf(\"%s\\n\",str);\n  }\n}\n{% endcodeblock %}\n编译成静态库\n{% codeblock lang:C %}\ngcc -o my_lib.o -c my_lib.c /* 将c文件编译为obj文件 */\n/**************************************\nr :表示将.o目标文件加入到静态库中(在已经存在的前面增加)；\nb :同r一样，但是在已经存在的后面增加\nc :表示创建静态库;\ns :表示生产索引；\nd :从库中删除成员文件\nm :在库中移动成员文件\np :在终端打印库中指定的成员\nq :增加新文件到库的结尾而不检查是否有相同文件\nt :显示库中成员清单\nx :从苦衷提取一个成员文件\ni :类似b选项\ns :强制重新生成库符号表\n***************************************/\nar rcs libmylib.a mylib.o /* 可以把多个.o文件封装为.a静态库 */\n{% endcodeblock %}\n测试函数test.c\n{% codeblock lang:C %}\n#include \"my_lib.h\"\n#include <stdio.h>\nint main(void)\n{\n  printf(\"create and use library\\n\");\n  welcome();\n  outstring(\"It's successful.\\n\");\n}\n{% endcodeblock %}\n使用静态库\n{% codeblock lang:C %}\n/**************************************\n-Ldir：表示指定库文件所在的路径中，默认在库路径在/usr/lib目录下；\n-lname：表示库目录的库文件libname.a或libname.so。如果库文件不是以lib开头，如hello.a，只能用用hello.a，不能用-lhello。\n删除静态库文件不会影响到可执行文件的运行。\n***************************************/\ngcc -o test test.c -lmylib /* -l为选项,mylib为静态库名中间部分，linux上约定库以前缀lib开始,静态库以.a结尾,动态库以.so结尾 */\n{% endcodeblock %}\n\n#### 共享库\n共享库和动态库就是一个东西(在linux上叫共享对象库，如：libglibc.so.6;在windows上叫动态加载函数库，以.dll结尾)\n用动态连接方法将程序和共享库连接，减少了文件大小，但增加了运行时开销\n共享库的另一个优点是可以用库函数的新版代替旧版而不需要程序重新编辑连接\n\n![共享库命名规则](APUE学习笔记-UNIX进程的环境/共享库命名规则.png)\n创建共享库\n{% codeblock lang:C %}\ngcc -fPIC -o mylib.o -c my_lib.c\ngcc -shared -o libttt.so mylib.o\n/*\n   两条命令可以合二为一\n */\ngcc -fPIC -shared -o libttt.so my_lib.c\n{% endcodeblock %}\n\n使用动态库\n{% codeblock lang:C %}\n/*\n   两种方法之一\n */\ngcc -o main test.c ./libttt.so\n\n/*\n   两种方法之二\n */\ncp libttt.so /usr/lib/libttt.so\ngcc -o main test.c /usr/lib/libttt.so\n{% endcodeblock %}\n\n#### 存储器分配\n##### 存储空间动态分配函数\n{% codeblock lang:C %}\n#include <stdlib.h>\n/*\n   realloc malloc free通过sbrk系统调用实现\n   大多数实现所分配的存储空间比所要求的要大一点，额外的空间用来记录管理信息（分配块的长度、指向下一个分配块的指针）\n   注意错误：\n    如果写过一个已分配区的尾端，会改写后一块的管理信息\n    释放一个已经释放了的块\n    调用free时所用的指针不是三个alloc函数的返回值\n\n  alloca函数\n    介绍：\n      其调用序列与malloc相同，在当前函数的栈帧上分配存储空间\n    优点：\n      当函数返回时，自动释放它所使用的栈帧，所以不必为释放空间而费心\n    缺点：\n      某些系统在函数调用后不能增加栈帧长度，因此不支持alloca函数\n */\n\n/*******************************************\n  size_t size : 需要分配的内存大小(字节数)\n  return      : 若成功则为非空指针,若出错则为NULL\n  function    : 分配size个字节，最终返回一个指向被分配的内存空间的指针\n  notice      : 如果size=0,malloc函数会返回NULL，或者一个能成功被free函数释放的非空指针值\n********************************************/\nvoid *malloc(size_t size);\n/*******************************************\n  size_t nobj : 内存空间个数\n  size_t size : 需要分配的内存大小(字节数)\n  return      : 若成功则为非空指针,若出错则为NULL\n  function    : 在内存动态存储区中分配nobj个长度为size的连续空间\n  notice      : 如果size或者nobj=0,malloc函数会返回NULL，或者一个能成功被free函数释放的非空指针值\n                如果nobj和size的乘法运算最终结果在int类型中溢出，那么calloc返回error\n                通过对比，整型溢出在之后调用malloc后不会被检测到,最终一个不正确的内存块将被分配\n********************************************/\nvoid *calloc(size_t nobj , size_t size);\n/******************************************\n  void *ptr   : 一个无类型的指针\n  size_t size : 需要分配的内存大小(字节数)\n  return      : 若成功则为非空指针,若出错则为NULL\n  function    : 为ptr指向的内存空间重新分配size内存大小(增、减以前分配的长度)\n  notice      : 如果新增加的内存空间比以前的大，则新增内存不会被初始化\n                如果ptr=NULL,则等价于调用malloc(size)\n                如果size=0,ptr不为空,那么等价于free(ptr)\n                这个函数必须在之前就要调用malloc,calloc或者realloc函数来返回,除非ptr不为空\n********************************************/\nvoid *realloc(void *ptr , size_t size);\n/*******************************************\n  void *ptr   : 一个无类型的指针\n  return      : 若成功则为非空指针,若出错则为NULL\n  function    : 释放ptr指向的内存空间\n  notice      : 如果ptr=NULL,不需要进行释放\n********************************************/\nvoid free(void *ptr);\n{% endcodeblock %}\n\n\n#### 环境变量\n环境变量的形式是键值对\n环境变量(char)=环境变量值(char)\n\n##### 环境变量函数\n{% codeblock lang:C %}\n#include <stdlib.h>\n\n/*******************************************\n  const char *name : 环境变量名\n  return           : 返回对应的环境变量值\n  function         : 通过环境变量名获取环境变量值\n********************************************/\nchar *getenv(const char *name);\n\n/*******************************************\n  const char *str : 环境变量键值对字符串\n  return           : 成功返回0,失败返回非0\n  function         : 取形式为name=value的字符串，将其放到环境表中，如果name已存在，则删除其原来的定义\n********************************************/\nint putenv(const char *str);\n\n/*******************************************\n  const char *name  : 环境变量名\n  const char *value : 环境变量值\n  int rewrite       : 标志，非0表示删除现存定义,0表示不删除现存定义\n  return            : 成功返回0,失败返回非0\n  function          : 将name设置为value,如果已经存在，按rewrite执行\n********************************************/\nint setenv(const char *name , const char *value , int rewrite);\n/*******************************************\n  const char *name : 环境变量名\n  return           : 无返回值\n  function         : 删除指定环境变量名的环境变量定义\n********************************************/\nvoid unsetenv(const char *name);\n{% endcodeblock %}\n\n##### 函数修改环境变量的过程\n环境变量表在程序运行后就被加载到程序中。\n###### 位置\n  在进程存储空间的顶部，也就是栈之上。\n###### 删除字符串\n  找到指向该字符串的指针，然后将所有后续指针都向下移一个位置(向下移表示最上面的被抛弃)\n###### 增加字符串(由于栈以上空间已在进程存储空间顶部，无法扩充)\n  + 修改现存name\n    新value<=旧value , 只需要在原字符串空间写入新字符串\n    新value>旧value , 需要调用malloc函数为新字符串分配空间\n  + 增加一个name(需要调用malloc为name=value分配空间)\n    第一次增加一个新name,需要调用malloc为新的指针表分配空间，将原来的环境表复制到新分配区，并将新name=value的指针存在该指针表的表尾，然后将一个空指针存在气候，最后使environ指向新指针表。\n    如果不是第一次增加，则只需要调用realloc，重新分配原空间，将name=value存入表尾，后面跟一个空指针。\n\n\n\n#### setjmp和longjmp函数\n  + 缘由\n    在c中，不允许使用跳跃函数的goto语句。使用这两个函数来代替。\n\n  + 使用\n    **setjmp和longjmp实例**\n{% codeblock lang:C %}\n#include \"../../include/apue.h\"\n#include <setjmp.h>\n#define TOK_ADD 5\nvoid do_line(char *);\nvoid cmd_add(void);\nint get_token(void);\n/* 这个程序有三个函数\n   主函数main首先入栈，之后调用do_line函数，do_line函数再入栈\n   之后do_line函数调用cmd_add函数，cmd_add入栈\n   之后cmd_add函数调用get_token函数,get_token函数入栈\n   如果在cmd_add函数中出现错误,返回main函数，我们需要检查返回值而逐层返回\n   解决这个问题可以用非局部跳转函数，类似goto语句，可以从cmd_add处直接跳到main函数处\n */\njmp_buf jmpbuffer ;\n\nint main(void)\n{\n  char line[MAXLINE];\n \n  /*******************************************\n  #include <setjmp.h>\n  int setjmp(jmp_buf env);\n  env     :   一个数组，保存调用longjmp时能用来恢复栈状态的所有信息\n  function:　返回的是longjmp中的第二个参数值,用来判断是哪个跳跃点\n  notice  :  如果返回0，表示没有错误出现\n  ********************************************/\n  if(setjmp(jmpbuffer) != 0)\n    perror(\"error\");\n  while(fgets(line , MAXLINE , stdin) != NULL)\n    do_line(line); /* 将数组中的命令提取出来进行解析 */\n\n  exit(0);\n}\nchar *tok_ptr ; /* 针对get_token()的全局指针 */\nvoid do_line(char *ptr)/* 处理一个输入行 */\n{\n  int cmd ;\n  tok_ptr = ptr ;\n  while((cmd = get_token()) > 0) /* 传入分解后的命令 */\n  {\n    switch(cmd)\n    {\n      case TOK_ADD :\n        cmd_add();\n        break;\n    }\n  }\n}\nvoid cmd_add(void)\n{\n  int token ;\n  token = get_token();\n  /* 处理命令的其余部分 */\n  if(token < 0)\n  {\n    /********************************************\n    #include <setjmp.h>\n    void longjmp(jmp_buf env , int val);\n    env :用来保存当前栈状态信息，给setjmp函数使用\n    val :可以看做是标记，因为一个程序中可能有对个跳跃点，这可以为每个跳跃点标示，使得使用setjmp函数时，可以知道是哪个跳跃点\n    ********************************************/\n    longjmp(jmpbuffer , 1);\n  }\n}\n/* 从tok_ptr指向的line中获取下一个标记 */\nint get_token(void)\n{\n\n}\n\n/*\n   注意：\n    longjmp函数被调用，返回main函数，自动变量和寄存器变量不会回滚到第一次调用setjmp时的值(也就是未出现错误时的值),这时它们的值不确定\n */\n{% endcodeblock %}\n    **longjmp对自动,寄存器和易失变量的影响**\n{% codeblock lang:C %}\n#include <setjmp.h>\n#include \"../../include/apue.h\"\n\n/* 使用static是为了使在执行longjmp时其值保存不变*/\nstatic void f1(int , int , int) ;\nstatic void f2(void);\n\nstatic jmp_buf jmpbuffer ;\n\n/*\n   在进行跳转后，volatile(存储器)中的值不会回滚\n   而register(寄存器中的值会回滚\n   int类型中的值不稳定，优化之前不会回滚，优化之后，将int放入寄存器中，会回滚\n */\n\nint main(void)\n{\n  int count ; /* 存放到寄存器中 */\n  register int val ; /* 寄存器变量，存储到寄存器中 */\n  volatile int sum ; /* 存放到存储器中  */\n  count = 2 ;\n  val = 3 ;\n  sum = 4 ;\n  if(setjmp(jmpbuffer) != NULL)\n  {\n    printf(\"after longjmp : count=%d,val=%d,sum=%d\\n\",count , val , sum);\n    exit(0);\n  }\n\n  /* 在longjmp调用之前，setjmp调用之后改变变量值 */\n\n  count = 97;\n  val = 98 ;\n  sum = 99 ;\n  f1(count , val , sum); /* 没有返回值，使用longjmp跳转 */\n}\n\nstatic void\nf1(int i , int j , int k)\n{\n  printf(\"in f1(): counf=%d , val=%d , sum=%d\\n\",i,j,k);\n  f2();\n}\n\nstatic void\nf2(void)\n{\n  longjmp(jmpbuffer , 1);\n}\n{% endcodeblock %}\n\n#### 自动变量问题\n示例\n{% codeblock lang:C %}\n#include <stdio.h>\n#define DATAFILE \"datafile\"\n\n/* open_data函数已经返回,他所在的栈帧会被其他函数使用 \n   而标准库仍然使用在栈上被分配的流缓存，这回产生冲突\n   因此我们不能使用自动变量，在这里需要将其设置为静态全局\n   这样databuf变量存在全局静态区，在整个程序周期都存在，不会产生冲突\n */\nstatic char databuf[BUFSIZ]; /* 自动变量，存储io流缓存 */\nFILE *\nopen_data(void)\n{\n  FILE *fp ;\n\n  if((fp = fopen(DATAFILE , \"r\")) == NULL) /* 用只读方式打开文件 */\n  {\n    return NULL ;\n  }\n\n  if(setvbuf(fp , databuf , _IOLBF , BUFSIZ) != 0) /* 设置行缓存 */\n  {\n    return NULL ;\n  }\n\n  return fp ;\n}\n{% endcodeblock %}\n\n#### getrlimit和setrlimit函数\n + 作用\n  用于查询和更改进程资源限制(在linux中以ulimit命令显现)\n + 函数\n{% codeblock lang:C %}\n#include <sys/time.h>\n#include <sys/resource.h>\n\n/*******************************************\n  int resource         : 资源类型\n  struct rlimit *rlptr : 资源信息结构指针\n  function             : 为指定资源设置一个指定的资源信息\n  notice               :\n  rlimit结构体:\n    struct rlimit {\n      rlim_t rlim_cur ; //当前限制\n      rlim_t rlim_max ; //当前限制的最大值\n    }\n  资源类型：\n    RLIMIT_CORE : core文件最大字节数\n    RLIMIT_CPU  : CPU时间的最大量值 \n    RLIMIT_DATA  : 数据段的最大字节长度\n    RLIMIT_MEMLOCK  : 锁定在存储地址空间\n    RLIMIT_NOFILE  : 每个进程能打开的最多文件数\n    RLIMIT_NPROC  : 每个实际用户id所拥有的最大子进程数\n    RLIMIT_OFILE  : 与RLIMIT_NOFILE相同\n    RLIMIT_FSIZE  : 可以创建的文件的最大字节长度\n    RLIMIT_RSS  : 最大驻内存集字节长度\n    RLIMIT_STACK  : 栈的最大字节长度\n    RLIMIT_VMEN  : 可映照地址空间的最大字节长度\n********************************************/\nint getrlimit(int resource , struct rlimit *rlptr);\nint setrlimit(int resource , const struct rlimit *rlptr);\n{% endcodeblock %}\n  + 使用\n{% codeblock lang:C %}\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include \"../../include/apue.h\"\n\n\n/* 这里将pr_limits函数作为常量来使用 */\n#define doit(name) pr_limits(#name,name)\n\nstatic void \npr_limits(char * , int);\n\nint \nmain(void)\n{\n  doit(RLIMIT_CORE);\n  doit(RLIMIT_CPU);\n  doit(RLIMIT_DATA);\n  doit(RLIMIT_FSIZE);\n\n#ifdef RLIMIT_MEMLOCK\n  doit(RLIMIT_MEMLOCK);\n#endif\n\n#ifdef RLIMIT_OFILE\n  doit(RLIMIT_OFILE);\n#endif\n\n#ifdef RLIMIT_NPROC\n  doit(RLIMIT_NPROC);\n#endif\n\n#ifdef RLIMIT_RSS\n  doit(RLIMIT_RSS);\n#endif\n\n#ifdef RLIMIT_STACK\n  doit(RLIMIT_STACK);\n#endif\n\n#ifdef RLIMIT_VMEM\n  doit(RLIMIT_VMEM);\n#endif\n\n  exit(0);\n}\n\nstatic void\npr_limits(char *name , int resource)\n{\n  struct rlimit limit ; /* 进程限制结构体 */\n  if(getrlimit(resource , &limit) < 0) /* 从指定资源中获取其中的limit中的信息 */\n  {\n    err_sys(\"getrlimit error for %s\",name);\n  }\n  printf(\"%-14s\",name); /* 打印资源名称 */\n  if(limit.rlim_cur == RLIM_INFINITY) /* RLIM_INFINITY表示不对资源做限制 */\n  {\n    printf(\"(infinity) \");\n  }else\n  {\n    printf(\"%10ld \",limit.rlim_cur); /* 当前资源限制 */\n  }\n\n  if(limit.rlim_max == RLIM_INFINITY)\n  {\n    printf(\"(infinity) \");\n  }else\n  {\n    printf(\"%10ld \",limit.rlim_max);\n  }\n}\n{% endcodeblock %}\n\n#### 自言自语\n  暂时了解了在Unix下的一些关于进程的基础知识。\n","tags":["APUE"],"categories":["APUE学习笔记"]},{"title":"APUE学习笔记-系统数据文件和信息","url":"%2F2019%2F05%2F04%2FAPUE%2FAPUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FAPUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF%2F"},{"title":"APUE学习笔记-文件IO","url":"%2F2019%2F05%2F03%2FAPUE%2FAPUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FAPUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6IO%2F"},{"title":"APUE学习笔记-文件和目录","url":"%2F2019%2F05%2F03%2FAPUE%2FAPUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FAPUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%2F"},{"title":"使用解释器","url":"%2F2019%2F05%2F03%2FPython%2Fpython-tutorial-notes%2Fchapter2_using_python_interpreter%2FUsing_the_python_interpreter%2F","content":"\n\n\n### 调用解释器\npython -c command arg ... \npyathon -m module arg .. \n### 参数传递\n### 交互模式\n<!-- more -->\n\n### 解释器和它的环境\n#### 源代码的编码\n  + 源代码示例[点击下载](/download/Python/python-tutorial-notes/chapter2/the_world_is_beautiful.py)\n    所有的python源文件编写都需要声明编码方式（linux/unix系统下）\n{% codeblock lang:python %}\n#! /usr/bin/python #源文件需要的编译环境\n#-*-coding:utf-8-*-#编码方式，在这里编码为utf-8\nthe_word_is_beautiful = TRUE\nif the_word_is_beautiful:   //if语句\n  print \"that's right!\"\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\ninput : python the_word_is_beautiful.py\noutput :that's right!\n{% endcodeblock %}\n\n\n\n\n\n","tags":["Python"],"categories":["python-tutorial-notes"]},{"title":"python的标准库(第一部分)","url":"%2F2019%2F05%2F03%2FPython%2Fpython-tutorial-notes%2Fchapter10_brief_tour_of_the_standard_library%2Fbrief_tour_of_the_standard_library%2F","content":"\n\n\n# brief tour 0f the standard library 标准库的简单介绍\n\n\n\n## operation system interface 操作系统接口\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n'''\n操作系统接口\n'''\nimport os\n\nprint(os.getcwd()) #返回现在的工作目录\n#指定工作目录，在工作目录下创建文件夹\nprint(os.chdir('/home/rack/')) #改变现在的工作目录\nprint(os.system('mkdir day')) #在操作系统shell中运行命令\n\nprint(dir(os)) #显示os下的属性和方法\nprint(help(os)) #返回os的帮助页面\n\n#shutil模块\nimport shutil\nshutil.copyfile('1','archive') #将1文件复制为archive文件\nshutil.move('/home/rack/moo/','installer') #将moo移动到installer(相当于重命名)\n```\n\n## file wildcards 文件通配符\n+ glob模块提供了从目录通配符中搜索中制作文件列表的功能\n```\nimport glob\nglob.glob(\"*.py\")\n```\n## command line argument 命令行参数\n+ 命令行参数存储在sys的argv属性的列表中\n```\nimport sys\nprint(sys.argv)\n```\n\n## error output redirection and program temination\n+ 打印输出错误提示\n```\nimport sys\nsys.stderr.write(\"warning,log file not found!\") \n```\n+ sys.exit()提供程序中断功能\n\n## string pattern matching 字符串模式匹配\n```\nimport re\nre.findall(r'\\bf[a-z]*','which foot or hand fell fastest') #用f匹配foot与hand， '*'为匹配[a-z]中所有字符 'r'表示字符串,'\\b'表示退格\nre.sub(r'(\\b[a-z]*) \\l',r'\\l','cat in the hat') #\n'tea for too'.replase('too','two') #用two代替too\n```\n\n## mathematics 数学运算\n```\nimport math\nmath.cos(math.pi/4) \nmath.log(1024,2) \n\nimport random\nrandom.choice(['apple','pear','banana']) #在其中随机选择\nrandom.sample(range(100),10) #不重复抽样\nrandom.random() #随机浮点数\nrandom.randrange(6) #在range(6)中随机选择整数\n\nimport statistics #计算数字数据中的基本统计属性(mean(平均值)，median(中位数),vanriance(方差))\nstatistics.mean(data) #平均值\nstatistics.median(data) #中位数\nstatistics.variance(data) #方差\n```\n\n## internet access 互联网接入\n\n+ urilib.repuest(从url中检索数据),smtplib(发送邮件)\n\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n\nfrom urllib.request import urlopen\nwith urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl') as response: #将url命名为response\n    for line in response:#在response中检索数据\n        line = line.decode('utf-8') #将二进制文件解码为文本\n        if 'EST' in line or 'EDT' in line: #寻找西方时间\n            print(line) #打印时间\n\n\nimport smtplib #发送邮件\nserver = smtplib.SMTP('localhost') #SMTP是邮件协议\nserver.sendmail('soothsayer@example.org', 'jcaesar@example.org',\n\"\"\"To: jcaesar@example.org\n     From: soothsayer@example.org\n\n    Beware the Ides of March.\n \"\"\") #从第一个地址到第二个地址\nserver.quit() #退出\n```\n\n## dates and times 日期和时间\n```\n#! /usr/bin/python3\n# -*-coding=utf-8-*-\nfrom datetime import date\nnow = date.today()\nprint(now)\n\nnow.strftime(\"%m-%d-%y. %d %b %Y is a %A on the %d day of %B.\") #输出日期格式\n\nbirthday = date(1964,7,31)\nage = now - birthday\nprint(age.days) #输出年龄，以秒输出\n```\n输出\n```\n2017-12-07\n19487\n```\n\n## data compression 数据压缩\n\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\nimport zlib\ns = b'witch which has which witches wrist watch' #字节文件\nlen(s) #查看字节长度\nt = zlib.compress(s) #将s压缩\nlen(t) #再次查看长度\nzlib.decompress(t) #将压缩文件解压\nzlib.crc32(s) #校验文件\n\n```\n\n## performance measurement 性能测量\n\n```\nfrom timeit import Timer\nTimer('t=a;a=b;b=t','a=1;b=2').timeit()\nTimer('a,b=b,a','a=1;b=2').timeit()\n#检测两个语句的消耗时间\n```\n\n## quality control 质量控制\n\n+ 质量测试 doctest\n```\ndef average(values):\n    \"\"\"Computes the arithmetic mean of a list of numbers.\n\n    >>> print(average([20, 30, 70]))\n    40.0\n    \"\"\"\n    return sum(values) / len(values)\nimport doctest \ndoctest.testmod() $自动验证嵌入测试\n```\n+ unittest 允许在单独文件中维护更全面的测试\n```\nimport unittest\n\nclass TestStatisticalFunctions(unittest.TestCase):\n\n    def test_average(self):\n        self.assertEqual(average([20, 30, 70]), 40.0)\n        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)\n        with self.assertRaises(ZeroDivisionError):\n            average([])\n        with self.assertRaises(TypeError):\n            average(20, 30, 70)\n\nunittest.main()  # Calling from the command line invokes all TestStatisticalFunctions\n```\n\n## batteries included\n\nPython has a “batteries included” philosophy. This is best seen through the sophisticated and robust capabilities of its larger packages. For example:\n\n    The xmlrpc.client and xmlrpc.server modules make implementing remote procedure calls into an almost trivial task. Despite the modules names, no direct knowledge or handling of XML is needed.\n    The email package is a library for managing email messages, including MIME and other RFC 2822-based message documents. Unlike smtplib and poplib which actually send and receive messages, the email package has a complete toolset for building or decoding complex message structures (including attachments) and for implementing internet encoding and header protocols.\n    The json package provides robust support for parsing this popular data interchange format. The csv module supports direct reading and writing of files in Comma-Separated Value format, commonly supported by databases and spreadsheets. XML processing is supported by the xml.etree.ElementTree, xml.dom and xml.sax packages. Together, these modules and packages greatly simplify data interchange between Python applications and other tools.\n    The sqlite3 module is a wrapper for the SQLite database library, providing a persistent database that can be updated and accessed using slightly nonstandard SQL syntax.\n    Internationalization is supported by a number of modules including gettext, locale, and the codecs package.\n","tags":["Python"],"categories":["python-tutorial-notes"]},{"title":"python标准库(第二部分)","url":"%2F2019%2F05%2F03%2FPython%2Fpython-tutorial-notes%2Fchapter11_brief_tour_of_the_standard_library_Part_II%2Fbrief_tour_of_the_standard_library_Part_II%2F","content":"\n# Brief Tour of the Standard Library — Part II 标准库 第二部分\n\n## 输出格式\n+ reprlib模块提供一个定制的repr版本,它是大型的或者深度嵌套容器的缩写\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n'''\nrepr输出格式\n'''\n\nimport reprlib \n\na = reprlib.repr(set('aDsupercalifragilisticexpialidocious'))\nprint(a) #以ascii表顺序输出不重复字母（字符串中出现的）\n\nimport pprint\nt = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta','yellow'], 'blue']]]\nprint(pprint.pprint(t,width=30)) #t以每行３０个字符的方式输出\n\nimport textwrap #格式化文本段落，以适应屏幕宽度\ndoc = \"\"\"he wrap() method is just like fill() except that it returns,a list of strings instead of one big string with newlines to separate,the wrapped lines.\"\"\" \nprint(textwrap.fill(doc,width=40)) #只能用文本方式\n\n#多语言模块\nimport locale\nlocale.setlocale(locale.LC_ALL,'English_United States.1252') #设置语言\nconv = locale.localeconv() #获取约定的映射\nx = 1234567.8\nlocale.format(\"%d\",x,grouping=True) #格式化x为整型\nlocale.format_string(\"%s.%f\",(conv['currency_symbol'],conv['frac_digits'],x),grouping=True) #格式化为字符串(使用组分隔符格式化数字) currency_symbol意思为使用$开头的和发标识为站位符\n```\n\n## 模板\n\n+ string模块包含了template类，template类就是模板\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\nfrom string import Template\n#Template函数用来创建模板，'$'表示输出后面的字符,$$表示输出$\n#t.substitute方法使用的字典模式,Template关键字，t.substitute提供键值\nt = Template('${village}folk send $$10 to ${cause}')\nprint(t.substitute(village='NOttingham',cause='the dicth fund.'))\n\n#如果输入的键值与模板中的关键字数量不匹配，会出现keyerror错误\nt = Template('Return the $item to $owner.')\nd = dict(item='unladen swallow') #用dict函数输入字典\n\nprint(t.safe_substitute(d)) #使用safe_substitute忽略错误\n\n\nimport time,os.path\nphotofiles = ['img_1974,jpg','img_1976.jpg','img_1977.jpg']\nclass BatchReneme(Template):\n    delimiter = '%' #用%代替$分开\nfmt = input('Enter reneme style (%d-date %n-seqnum %f-format):') #输入模板\nt = BatchReneme(fmt) #将输入的模板复制到t\ndate = time.strftime('%d%b%y')#时间格式\nfor i , filename in enumerate(photofiles): #枚举photofiles\n    base , ext = os.path.splitext(filename)# 切割photofiles中的文件名\n    newname = t.substitute(d=date,n=i,f=ext) #d的键值就是date，n的键值为ｉ,f的键值n为ext\n    print('{0} --> {1}'.format(filename,newname))#输出旧名称和新名称\n\n```\n输出\n```\nNOttinghamfolk send $10 to the dicth fund.\nReturn the unladen swallow to $owner.\nEnter reneme style (%d-date %n-seqnum %f-format):Axsle_%n%f\nimg_1974,jpg --> Axsle_0\nimg_1976.jpg --> Axsle_1.jpg\nimg_1977.jpg --> Axsle_2.jpg\n```\n\n## 使用二进制数据记录布局\n+ struct模块提供pack()和unpack()方法用来处理可变长度二进制记录格式。\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n#暂时不懂\n'''\n这个例子显示了怎样在没有用zipfile模块的情况下在一个zip文件中通过循环头部信息\n'''\n\nwith open('myfile.zip','rb') as f : #用open()用只读二进制格式打开,并将open命名为f\n    data = f.read()  #读取数据，并赋值给data\n\nstart = 0  #初始时从０开始\nfor i in range(3): #显示前三个文件头信息\n    start += 14  #由于H表示４字节的无符号数字,I表示２字节的无符号数字，IIIHH则有１４字节,需要每次增加１４字节\n    fields = struct.unpack('<IIIHH',data[start:start+16]) #解压后的数据域增加2字节\n    crc32,comp_size,uncomp_size,filename,extra_size = fields　#数据域包含的信息\n\n    start += 16 　#解压后需要每次增加１６字节\n    filename = data[start:start+filename]　#现在的数据域长度为filename\n    start += filename　# 每次增加filename长度\n    extra = data[start:start+extra_size] \n    print(filename,hex(crc32),comp_size,uncomp_size)\n\n    start += extra_size + comp_size #跳过下一个头部\n```\n\n## 多线程\n\n+ 多线程是一种分离任务的技术，将单一进程的任务分给多个线程完成，不需要依赖。\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n'''\n多线程,显示高级线程模块在后台运行，而主程序继续运行\n'''\n\nimport threading , zipfile\n\nclass AsyncZip(threading.Thread): #继承threading模块的Thread方法\n    def __init__(self,infile,outfile):\n        threading.Thread.__init__(self) #调用threading模块Thread类的__init__()方法\n        self.infile = infile #需要写进zip包的文件\n        self.outfile = outfile　#文件需要输出的zip压缩包\n\n    def run(self):\n        f = zipfile.ZipFile(self.outfile,'w',zipfile.ZIP_DEFLATED)  #将zip包设置为可写状态，以便写进文件,ZIP_DEFLATED应该是压缩比吧，这是一个默认值\n        f.write(self.infile) #将文件写进zip包\n        f.close()　#关闭文件\n        print('Finished background zip of:',self.infile) #后台程序完成\n\nbackground = AsyncZip('nydata.txt','myarchive.zip')#将mydata.txt写入myarchive.zip压缩包，创建一个对象\nbackground.start() #threading.Thread中的方法，用来开起线程\nprint('The main program continues to run in foreground.')\n\nbackground.join() #等待后台程序完成,threading.Thread中的方法，用来加入线程\nprint('Main program waited until background was done.')\n```\n\n## 日志\n\n+ logging模块提供完整的特性和灵活的日志记录系统,日志信息将会发送到一个文件或者sys.stderr\n+ 错误\n１、我在写完这个程序后，命名logging.py　用python3 logging.py运行，出现错误如下\n```\nTraceback (most recent call last):\n  File \"logging.py\", line 3, in <module>\n    import logging \n  File \"/home/rack/python-tutorial-notes/chapter11_brief_tour_of_the_standard_library_Part_II/logging.py\", line 9, in <module>\n    logging.debug('Debugging imformation')#调试信息\nAttributeError: 'module' object has no attribute 'debug'\n\n```\n解决方法：重命名文件名，因为在系统中已经有一个logging.py文件，python查询时查询出错。\n\n２、再次运行python3 logging\\_example.py程序，出现错误如下\n```\nTraceback (most recent call last):\n  File \"logging_example.py\", line 3, in <module>\n    import logging \nImportError: bad magic number in 'logging': b'\\x03\\xf3\\r\\n'\n```\n解决方法：\n```\nls -a \n会发现一个.pyc文件，删除该文件重新运行\n```\n+ logging\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\nimport logging \n#a = logging.basicConfig(level=logging.DEBUG,  \n#                    format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s',  \n#                    datefmt='%a, %d %b %Y %H:%M:%S',  \n#                    filename='/tmp/test.log',  \n#                    filemode='w') \nb = logging.debug('Debugging imformation')#调试信息\nc = logging.info('imformational message') #信息消息\nd = logging.warning('Warning:config %s not found','server.conf') #警告信息\ne = logging.error('Error occurred') #错误信息\nf = logging.critical('Critical error -- shutting down') #关键性误差\n\n#print(a)\nprint(b,c,d,e,f)\n```\n输出\n```\nWARNING:root:Warning:config server.conf not found\nERROR:root:Error occurred\nCRITICAL:root:Critical error -- shutting down\n```\n\n## 弱引用\n\n+ 弱引用模块提供了用于跟踪对象，而不用创建引用。\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n'''\n弱引用\n当对象不再需要，将会从弱引用表中移除\n'''\nimport weakref , gc\nclass A:\n    def __init__(self,value):\n        self.value = value\n\n    def __repr__(self): #用于解释器理解\n        return str(self.value) #用字符串返回\n\na = A(10) #创建引用\nd = weakref.WeakValueDictionary() #创建一个字典，对其中的值进行弱引用,对值没有更多的强引用时, 将丢弃该字典中的对应项。如果提供dict, 则将dict中的各项添加到返回的WeakValueDictionary。WeakValueDictionary的实例有两个返回弱值引用的方法：itervaluerefs()和valuerefs()。\nd['primary'] = a #不创建引用\nprint(d['primary'])#如果引用还在，就取回对象\ndel a #移除引用\nprint(gc.collect()) #立即运行垃圾收集\nprint(d['primary']) #引用已经不存在，输出错误\n```\n输出\n```\n10\n39\nTraceback (most recent call last):\n  File \"weak_reference.py\", line 21, in <module>\n    print(d['primary']) #引用已经不存在，输出错误\n  File \"/usr/lib/python3.5/weakref.py\", line 131, in __getitem__\n    o = self.data[key]()\nKeyError: 'primary'\n```\n\n##使用列表工作的工具\n\n+ array模块提供array()对象\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\nfrom array import array \na = array('H',[4000,10,700,22222]) #‘'H'为类型代码，表示二进制数，后面为生成的是二进制数组\nb = sum(a) #将数组中数据相加\nprint(b)\nc = a[1:2] \nprint(c)\n```\n输出\n```\n26932\narray('H', [10])\n```\n+ collections模块提供deque()对象\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\nfrom collections import deque\nd = deque(['task1','task2','task3']) #创建一个队列\nd.append('task4') #增加队列元素\nprint('insert ',d)\nprint('Handing ',d.popleft()) #从队头删除\n'''\nstarting_node = ['who','i','am','a','bou']\nunsearched = deque([starting_node])\ndef breadth_first_search(unsearched):\n    node = unsearched.popleft()\n    for m in gen_moves(node):\n        if is_goal(m):\n            return m\n        unsearched.append(m)\na = breadth_first_search(unsearched)\nprint(a)\n\nimport bisect\nscores = [(100,'perl'),(200,'tcl'),(400,'lua'),(500,'python')]\nbisect.insort(scores,(300,'ruby')) #将加入的元组在scores中排序\nprint(scores)\n\n#基于规则链表实现的堆功能\nfrom heapq import heapify , heappop , heappush \ndata = [1,3,5,7,9,2,4,6,8,0]\nheapify(data) #将列表重新排列成堆排序\nheappush(data,-5) #在data中插入元素\na = [heappop(data) for i in range(3)] #取三个最小项\nprint(a)\n\n'''\n```\n输出\n```\ninsert  deque(['task1', 'task2', 'task3', 'task4'])\nHanding  task1\n[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]\n[-5, 0, 1]\n```\n\n### 十进制浮点运算\n\n+ 主要是金融和其他需要精确十进制表示的应用\n例子，对７０%的电话收取5%的税率，在小数点和二进制浮点数上有不同结果\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n\n\n#计算税率\nfrom decimal import * #十进制浮点运算\nprint(round(Decimal('0.70')*Decimal('1.05'),2)) #计算后进行约数，再保留２位小数点\nprint(round(.70*1.05,2)) #计算后直接保留２位小数，不进行任何运算\nprint(Decimal('1.00')%Decimal('.10'))\nprint(1.00%0.10)\nprint(sum([Decimal('0.1')]*10)==Decimal('1.0')) #判断结果是否相等\nprint(sum([0.1]*10)==1.0)\ngetcontext().prec=36 #后面小数点数\nprint(Decimal(1)/Decimal(7)) \n```\n输出\n```\n0.74\n0.73\n0.00\n0.09999999999999995\nTrue\nFalse\n0.142857142857142857142857142857142857\n```\n\n","tags":["Python"],"categories":["python-tutorial-notes"]},{"title":"模块","url":"%2F2019%2F05%2F03%2FPython%2Fpython-tutorial-notes%2Fchapter6_moudles%2Fmoudles%2F","content":"\n\n### moudles\n{% codeblock lang:python %}\n_做为全局变量名 _name_的值时，模块是可用的\n{% endcodeblock %}\n  + [fibonacci函数](/download/Python/python-tutorial-notes/chapter6/moudle_fibonacci.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n'''\nfibonacci函数\n'''\ndef fib(n):\n    a,b = 0,1\n    while b < n:\n        print(b,end=' ')\n        a,b=b,a+b\n\n#用result返回\ndef fib2(n):\n    result = []\n    a,b=0,1\n    while b < n:\n        result.append(b)\n        a,b=b,a+b\n    return result\n        \n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\n1 1 2 3 5 8 13 21 34 55 89 None\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]\n1 1 2 3 5 8 13 21 34 55 89 None\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]\n{% endcodeblock %}\n#### more on moudles \n  + 一个moudle中能导入其他moudle\n  + 可以导入模块中选定的函数\n  + 在交互式回话中，如果模块被改变，需要restart解释器\n  + 也可以用importlib.reload(moudlename)重新加载模块\n\n\n  + [from_import_fib](/download/Python/python-tutorial-notes/chapter6/from_import_fib.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n#用这个形式导入模块中的函数，不需要写模块前缀\nfrom moudle_fibonacci import fib,fib2\nprint(fib(100)) #只需要用模块中的函数，与引用在一个文件的中函数一样\nprint(fib2(1000))\n\n#导入模块中所有的函数，这种方法一般来说是不被使用的，只是可以用于交互式解释器\nfrom moudle_fibonacci import *\nprint(fib(800))\nprint(fib2(1000))\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\n1 1 2 3 5 8 13 21 34 55 89 None\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]\n1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 None\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]\n{% endcodeblock %}\n##### moudles用作脚本\n  + 需要在模块文件最后加上_name_语句\n  + if _name_=\"_main_\" 表示用作脚本\n  + if _name_=\"name.py\" 表示用作模块导入\n  \n  + [moudle_fibonacci_script](/download/Python/python-tutorial-notes/chapter6/moudle_fibonacci_script.py) \n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n'''\nfibonacci函数,用作脚本，不能被导入\n'''\ndef fib(n):\n    a,b = 0,1\n    while b < n:\n        print(b,end=' ')\n        a,b=b,a+b\n\n#用result返回\ndef fib2(n):\n    result = []\n    a,b=0,1\n    while b < n:\n        result.append(b)\n        a,b=b,a+b\n    return result\n \n#用name语句,使得模块用作脚本，不能被导入\nif __name__ == \"__main__\":\n    import sys  \n    fib(int(sys.argv[1])) #python3 moudle_fibonacci_script.py arguments\n{% endcodeblock %}\n  + 示例\n{% codeblock lang:python %}\npython3 moudle_fibonacci_script.py 100\n1 1 2 3 5 8 13 21 34 55 89 \n{% endcodeblock %}\n\n##### the moudle search path\n  + 模块搜索路径\n    搜索模块名\n    搜索模块所在文件名\n    使用sys.path搜索\n      1. 程序主目录\n      2. PYTHONPATH环境变量配置目录\n      3. 标准库目录\n      4. .pth文件目录\n\n##### compiled python files\n  + 编译后的python文件\n    pyc文件： .pyc 是一种二进制文件，是由 .py 文件经过编译后，生成一种byte code文件。 .py 文件变成 .pyc 文件后，加载的速度有所提高，而且 .pyc 是一种跨平台的字节码，是由python的虚拟机来执行的，这个类似于JAVA或者.NET的虚拟机的概念。 .pyc 的内容是跟python的版本相关的，不同版本编译后的 .pyc 文件是不同的，2.5编译的 .pyc 文件对于2.4版本的python是无法执行的。\n    pyo文件： .pyo 是优化编译后的程序  python -O 源文件 即可将源程序编译为 .pyo 文件。\n    pyd文件： .pyd 是python的动态链接库。\n\n#### standard moudles 标准库模块\n  + sys模块\n  + 在交互模式中这两个才定义 sys.ps1 sys.ps2\n  + sys.path 文件路径\n  + [import_sys](/download/Python/python-tutorial-notes/chapter6/import_sys.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\nimport sys\nsys.path.append('/usr/bin/vim.basic')\n\nprint(sys.path) #将输入的路径加入sys.path搜索的路径\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\n['/home/rac/python-tutorial-notes/chapter6-moudles', '/usr/lib/python35.zip', '/usr/lib/python3.5', '/usr/lib/python3.5/plat-x86_64-linux-gnu', '/usr/lib/python3.5/lib-dynload', '/usr/local/lib/python3.5/dist-packages', '/usr/local/lib/python3.5/dist-packages/bypy-1.0.3-py3.5.egg', '/usr/lib/python3/dist-packages', '/usr/bin/vim.basic']\n{% endcodeblock %}\n\n#### the dir()function\n  + dir()函数，用来查询python模块中的函数\n  + [moudle_dir](/download/Python/python-tutorial-notes/chapter6/moudle_dir.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\nimport moudle_fibonacci , sys #导入两个模块\n\nprint(\"please output moudle_fibonacci functions:\\n\")\nprint(dir(moudle_fibonacci))\nprint(\"\\n\\n\\n\")\nprint(\"please output sys fuctions:\\n\")\nprint(dir(sys))\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\nplease output moudle_fibonacci functions:\n['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'fib', 'fib2']\n\nplease output sys fuctions:\n\n['__displayhook__', '__doc__', '__excepthook__', '__interactivehook__', '__loader__', '__name__', '__package__', '__spec__', '__stderr__', '__stdin__', '__stdout__', '_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe', '_home', '_mercurial', '_xoptions', 'abiflags', 'api_version', 'argv', 'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder', 'call_tracing', 'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info', 'float_repr_style', 'get_coroutine_wrapper', 'getallocatedblocks', 'getcheckinterval', 'getdefaultencoding', 'getdlopenflags', 'getfilesystemencoding', 'getprofile', 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info', 'intern', 'is_finalizing', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'set_coroutine_wrapper', 'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout', 'thread_info', 'version', 'version_info', 'warnoptions']\n{% endcodeblock %}\n\n  + [moudle_dir1](/download/Python/python-tutorial-notes/chapter6/moudle_dir1.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\na = [1,2,3,4,5] #a做为一个全局变量加入了dir搜索中\nimport moudle_fibonacci\nfib = moudle_fibonacci.fib\nprint(dir())\n#列出的所有类型名有变量，模块，函数\n\n#dir列出内置函数和变量的名称\nimport builtins\nprint(dir(builtins))\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\n['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'fib', 'moudle_fibonacci']\n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']\n{% endcodeblock %}\n\n#### packages 包\n  + 包必须有\\_\\_init\\_\\_.py文件，它用来确定文件目录为包,避免包名被认为是一个字符串.\n  + 例如,有一个包（有\\_\\_init\\_\\_.py文件），包下面有三个子目录（都有\\_\\_init\\_\\_.py文件，是sound包的子包）\n{% codeblock lang:python %}\nsound/                          Top-level package(主包)\n      __init__.py               Initialize the sound package(确定sound目录是python包) \n      formats/                  Subpackage for file format conversions(sound包的子包)\n              __init__.py           确定formats是包\n              wavread.py\n              wavwrite.py\n              aiffread.py\n              aiffwrite.py\n              auread.py\n              auwrite.py\n              ...\n      effects/                  Subpackage for sound effects\n              __init__.py\n              echo.py\n              surround.py\n              reverse.py\n              ...\n      filters/                  Subpackage for filters\n              __init__.py\n              equalizer.py\n              vocoder.py\n              karaoke.py\n{% endcodeblock %}\n##### 导入方法\n  + import sound.effects.echo   隐式导入（导入sound包中的effects子包中的echo模块） \n    sound.effects.echo.function() 加载子模块需要引用全名\n  + from sound.effects import echo 绝对导入（从包中导入模块）\n    echo.function()              只需要引用模块名，不需要引用全名\n  + from sound.effects.echo import function  绝对导入（从包中模块导入函数）\n    function()                只需要引用函数名\n\n#### importing * from a package 从一个包中导入所有模块\n  + \\_\\_init\\_\\_.py中的\\_\\_all\\_\\_函数决定应该导入的模块\n\n    example,引用sound包，其中的sound/effects/\\_\\_init\\_\\_.py文件\n{% codeblock lang:python %}\n__init__.py\n\nif __name__ ='__main__'\n\nall =[\"echo\",\"surround\",\"reverse\"]  \n\nfrom sound,effects import *           只导入__ all__ 中的三个模块,__all__ 只影响这种导入模式\n{% endcodeblock %}\n##### intra-package references \n  + relative import 显示导入\n    from . import moudlename    显示导入（导入同一目录下的模块）\n    from .. import moudlename\n    from ..package import moudlename\n\n  + 用于python程序的主模块的模块必须用绝对导入（主模块中有“\"\\_\\_main\\_\\_\"）\n\n##### packages in multiple directories\n  + 使用不同目录下的包，需要使用sys.path添加包目录到当前路径\n{% codeblock lang:python %}\nimport sys\nsys.path.append(\"引用模块的地址\")\nfrom moudlename import fucntion or import moudlename\n{% endcodeblock %}\n\n\n#### conclusion\n\n##### 模块导入方法\n  + 显示导入\n    from . import moudlename\n  + 隐式导入\n    import moudlename\n  + 绝对导入\n    from moudlename/package path import moudlename/function\n","tags":["Python"],"categories":["python-tutorial-notes"]},{"title":"类对象和实例","url":"%2F2019%2F05%2F03%2FPython%2Fpython-tutorial-notes%2Fchapter9_classes%2Fclass_instance%2F","content":"\n# 类和对象(实例)\n\n+ 类是一个属性和方法的集合\n\n例如，students是一个类，指的是学生这个集合\n\n+ 对象，也称为实例，是一个类的具体实现。类对象就是可以用类名直接表示的对象\n\n例如，student是students这个类的具体实现，一个群体中具体的某一个人。\n首先，定义一个类\n```\nclass Student:\n\tpass\n\nbart = Student() #这是一个实例，将Student看做一个函数。在其中有很多对象，它将返回一个对象，并赋值给bart，bart成为了一个实例，也就是对象。\n```\n+ 实例绑定属性\n\nbart是指向实例的，它就代表了实例本身，bart通过运算符'.'来引用属性。\n```\nclass Student(object):\n\tdef __init__(self,name,score):\n\t\tself.name = name    #为实例对象绑定属性\n\t\tself.score = score #self是代指对象本身，和上面的bart差不多。\n```\n+ 实例的属性和方法\n\n实例的属性也就是对象的变量，与c++需要中的prviate中的变量差不多，能被方法调用。\n实例的方法，实例绑定的函数，也称为公有接口，与c++中public中的公共接口类似。实例能够通过公共接口调用实例变量。但是不能直接修改实例变量。\t\n\n+ conclusion\n\n类(学生群体)是对象(一个学生)的集合，对象拥有属性(学生的成绩和名字等)和方法(运用学生的属性进行操作的函数).类拥有对象和属性，对象是类中的单个实例。类属性是静态变量，类加载的时候就分配了内存被类中的对象共享。\n","tags":["Python"],"categories":["python-tutorial-notes"]},{"title":"错误与异常","url":"%2F2019%2F05%2F03%2FPython%2Fpython-tutorial-notes%2Fchapter8_errors_exceptions%2Ferrors_exceptions%2F","content":"\n\n\n### errors and exceptions\n\n#### syntax errors\n  + 书写不当造成\n    一般显示 SyntaxError错误\n\n#### exceptions\n  + 执行过程中检测到的错误\n  + 只是一些小问题，不影响程序运行的错误\n{% codeblock lang:python %}\n>>> 10 * (1/0)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nZeroDivisionError: division by zero   #除以0的错误\n>>> 4 + spam*3\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'spam' is not defined #名称错误，名称没有被定义\n>>> '2' + 2\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: Can't convert 'int' object to str implicitly #类型错误\n{% endcodeblock %}\n#### handing exceptions\n  + 用try...except语句来捕捉异常错误\n    try后面接需要运行的语句\n    except后面接需要捕捉的异常错误，用自己的语言来描述这个错误\n  + 如果异常没有发生，则运行try后面的语句，如果异常发生，则运行except后面的语句\n\n  + [handle_except](/download/Python/python-tutorial-notes/chapter8/handle_except.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n'''\n通过异常捕捉来捕捉错误\n'''\n#输入数字，则正确运行程序，若输入其他字符，则显示异常\nwhile True:\n    try:  #接需要运行的语句\n       x = int(input(\"Please enter a number :\")) \n       break\n    except ValueError: #接收ValueError错误\n        print(\"Oops! that was no Valid number . try again...\")\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\nPlease enter a number :qw\nOops! that was no Valid number . try again... #输入的不正确则显示自定义的异常语句\nPlease enter a number :qw\nOops! that was no Valid number . try again...\nPlease enter a number :12\n{% endcodeblock %}\n  + 一个except 子句可以将多个异常命名为一个元组\n{% codeblock lang:python %}\nexcept (NameError,TypeError,RuntimeError):\n    pass\n{% endcodeblock %}\n  + 如果有相同类或者基类，一个except子句是与一个异常想适配的[handle_except_class](/download/Python/python-tutorial-notes/chapter8/handle_except_class.py)\n{% codeblock lang:python %}\nclass B(Execption):\n    pass\nclass C(B):\n    pass\nclass D(C):\n    pass\n\nfor cls in [B,C,D]:\n    try:\n        raise cls()\n    except D:\n        print(\"D\")\n    except C:\n        print(\"C\")\n    except B:\n        print(\"B\")\n#\n#如过except子句被颠倒过来，首先B与第一个循环元素匹配，输出，发生异常。输出B,B,B\n{% endcodeblock %}\n  + 捕获详细的异常信息[handle_except_sys](/download/Python/python-tutorial-notes/chapter8/handle_except_sys.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\nimport sys\ntry :\n    f = open('myfile.txt')\n    s = f.readline()\n    i = int(s.strip())\nexcept OSError as err:\n    print(\"OS error:{0}\".format(err)) #OSError错误\nexcept ValueError:\n    print(\"Couldn't convert data to an integer.\") #ValueError错误\nexcept :\n    print(\"Unexcepted error:\",sys.exc_info()[0]) #捕获详细的异常信息\n    raise #引发异常\n\n#try...except语句用else关键字\n\n#用else,避免意外捕获由try语句保护的代码引起的异常\nfor arg in sys.argv[1:]:\n    try:\n        f = open(arg,'r')\n    except OSError:#出现异常\n        print('cannot open',arg) #打印异常信息\n    else:\n        print(arg,'has',len(f.readlines()),'lines') #否则正常运行程序\n        f.close() #关闭文件\n{% endcodeblock %}\n  + 实例化参数[handle_except_raise](/download/Python/python-tutorial-notes/chapter8/handle_except_raise.py)\n{% codeblock lang:python %}\n#实例化参数，在添加到异常中\ntry :\n    raise Execption('spam','rggs')\nexcept Execption as inst: \n    print(type(inst)) #异常实例化\n    print(inst.args) #将参数储存在.args数组中\n    print(inst) \n\n    x,y=inst.args\n    print('x = ',x)\n    print('y = ',y)\n{% endcodeblock %}\n  + 发生在函数里面的异常也可以用try捕获[handle_except_function](/download/Python/python-tutorial-notes/chapter8/handle_except_function.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\ndef this_fails():\n    x = 1/0\n\ntry:\n    this_fails()\nexcept ZeroDivisionError as err:\n    print('Handling run-time error',err)\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\nHandling run-time error division by zero\n{% endcodeblock %}\n\n#### raising exceptions\n\n  + raise 语句允许强制指定异常发生\n{% codeblock lang:python %}\n#有参数\n>>> raise NameError('HiThere')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: HiThere #强制指定NameError错误发生\n#无参数\nraise ValueError  # raise ValueError()的简称\n{% endcodeblock %}\n\n  + 确定一个异常是否被引发，但不处理\n{% codeblock lang:python %}\n>>> try:\n...     raise NameError('HiThere') #引发异常\n... except NameError:\n...     print('An exception flew by!') #输出自定义描述\n...     raise\n...\nAn exception flew by!\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\nNameError: HiThere\n#不处理异常\n{% endcodeblock %}\n\n#### user-defined exceptions\n\n  + 创建异常类来命名自己的异常[usr_defined_exception](/download/Python/python-tutorial-notes/chapter8/usr_defined_exception.py)\n\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\nclass Error(Exception):\n    \"\"\"\n    Base clase for Exceptions in this moudle.\n    \"\"\"\n    pass\n\nclass InputError(Error):\n    \"\"\"\n    Exception raised for errors in the input .\n    Attributes:\n        exception -- input expression in which the error occured\n        message -- explanation of the error\n    \"\"\"\n    def __init__(self,expression,message): #self是指向类的实例（根据类创建出的具象化对象）\n        self.expression = expression #self实例的expression方法\n        self.message = message\n\nclass TransitionError(Error):\n    \"\"\"Raised when an operation attempts a state transition that's not\n    allowed.\n\n    Attributes:\n        previous -- state at beginning of transition\n        next -- attempted new state\n        message -- explanation of why the specific transition is not allowed\n    \"\"\"\n\n    def __init__(self, previous, next, message):\n        self.previous = previous\n        self.next = next\n        self.message = message\n{% endcodeblock %}\n\n#### defining clean-up actions \n\n  + 在所有情况下被定义的清理动作[define_clean_up_action_finally](/download/Python/python-tutorial-notes/chapter8/define_clean_up_action_finally.py)\n\n{% codeblock lang:python %}\n>>> try:\n...     raise KeyboardInterrupt\n... finally: #不管异常发生没有，finally都会执行\n...     print('Goodbye, world!')\n...\nGoodbye, world!\nKeyboardInterrupt\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\n{% endcodeblock %}\n  + try...except...else...finally语句连用[define_clean_up_action_else](/download/Python/python-tutorial-notes/chapter8/define_clean_up_action_else.py)\n{% codeblock lang:python %}\n#! /usr/bin/python3\n#-*-coding:utf-8-*-\n\n'''\ntry...except...finally语句中使用else\n'''\n\ndef divide(x,y):\n    try:\n        result = x/y\n    except ZeroDivisionError:\n        print(\"division by zero.\")\n    else:\n        print(\"the result is \",result)\n    finally:\n        print(\"excuting finally clause.\")\n\nprint(divide(2,1))\nprint(divide(2,0))\nprint(divide(\"2\",\"1\"))#不能输入字符\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\nthe result is  2.0\nexcuting finally clause.\nNone\ndivision by zero.\nexcuting finally clause.\nNone\nexcuting finally clause.\nTraceback (most recent call last):\n  File \"define_clean_up_action_else.py\", line 20, in <module>\n    print(divide(\"2\",\"1\"))#不能输入字\n  File \"define_clean_up_action_else.py\", line 10, in divide\n    result = x/y\nTypeError: unsupported operand type(s) for /: 'str' and 'str'\n{% endcodeblock %}\n  + conclusion\n    try:后面接正确运行的语句，如果没有异常，则运行\n    except:后面接异常类型，自定义异常描述\n    finally:不论是否发生异常，都会运行\n    else:与其他语句中的用法相同，用在异常语句中，意味着异常不会发生\n    raise:异常引发语句\n\n#### predefined clean-up actions\n\n  + with 语句处理异常\n{% codeblock lang:python %}\nfor line in open(\"myfile.txt\"): \n  print(line, end=\"\")\n\n#这段代码将会打开一个文件，但是不会关闭，这将会产生一个异常\n```\n  但是用了with语句\n```\nwith open(\"myfile.txt\") as f: \n   for line in f: \n       print(line, end=\"\")\n#这将会自动关闭打开的文件。\n{% endcodeblock %}\n","tags":["Python"],"categories":["python-tutorial-notes"]},{"title":"将python做为计算器","url":"%2F2019%2F05%2F03%2FPython%2Fpython-tutorial-notes%2Fchapter3_an_informal_introduction_to_python%2Fan-informal-introduction-to-python%2F","content":"\n\n### 将python做为计算器\n#### 整数\n##### numbers1.py \n  + 整数运算[点击下载](/download/Python/python-tutorial-notes/chapter3/numbers1.py)\n{% codeblock lang:python %}\n#!/usr/bin/python3\n# coding=utf-8\n'''\n这个程序是整数之间的运算\n有- + * /等运算\n'''\nprint (\"请输入整数\")\na = 2+2\nb = 50 - 5*6\nc = (50-5*6)/4\nd = 8/5\n\nprint ('plus:',a)  #单变量输出\nprint (\"minus:%d\\nmultiplied:%.2f\\nexcpept%.2f\\n\" %(b,c,d)) #格式化输出\n{% endcodeblock %}\n  + 输入输出\n{% codeblock lang:python %}\ninput:python3 numbers.py \noutput:\n请输入整数\nplus: 4\nminus:20\nmultiplied:5.00\nexcpept1.60   #python3现在能让/输出浮点数\n{% endcodeblock %}\n<!--more-->\n##### numbers2.py \n  + 运算符的运用和指数[点击下载](/download/Python/python-tutorial-notes/chapter3/numbers2.py)\n{% codeblock lang:python %}\n'''\n/ % // 运算符的运用和指数\n'''\n#!/usr/bin/env python\n# coding=utf-8\n\nprint (\"请输入：\\n\")\na = 17/3\nb = 17//3\nc = 17%3\nd = 5*3+2\ne = 5**2\nf = 2**7\nprint(\"a = %f\\nb = %f\\nc = %d\\nd = %d\\ne = %d\\nf = %d\\n\"%(a,b,c,d,e,f))\n{% endcodeblock %}\n\n  + 输出浮点数和指数\n{% codeblock lang:python %}\n请输入：\n\na = 5.666667\nb = 5.000000\nc = 2\nd = 17\ne = 25\nf = 128\n{% endcodeblock %}\n\n##### numbers3.py \n  + 变量运算[点击下载](/download/Python/python-tutorial-notes/chapter3/numbers3.py)\n{% codeblock lang:python %}\n'''\n变量运算\n'''\n#! /usr/bin/python3\n# coding:utf-8\nprint(\"请输入变量：\\n\")\nwidth = 20\nheight = 5*9\nprint(\"the add : %d\\n\"%(width*height))\n{% endcodeblock %}\n  + 输出 \n{% codeblock lang:python %}\n请输入变量：\n\nthe add : 900\n{% endcodeblock %}\n\n### numbers4.py \n  + 其他运算[点击下载](/download/Python/python-tutorial-notes/chapter3/numbers4.py)\n\n{% codeblock lang:python %}\n#!/usr/bin/python3\n# coding=utf-8\n'''\n其他运算\n'''\na = 4*3.75-1\ntax = 12.5/100\nprice = 100.50\nc = price*tax\n#在python解释器下price+_  '_'表示继续上一个运算的结果，与price相加\nprint(\"a = %f\\ntax = %f\\nc = %f\\n\"%(a,tax,c))\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\na = 14.000000\ntax = 0.125000\nc = 12.562500\n{% endcodeblock %}\n\n##### strings[点击下载](/download/Python/python-tutorial-notes/chapter3/strings.py)\n\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\nprint(\"spam eggs\")\nprint(\"does\\'t\")\nprint(\"does't\") #print('does't')不正确，''单引号不能\nprint('yes\",he said.')\nprint(\"\\\"yes\\\",he said.\") #用反斜杠\nprint('\"isn\\'t\",she said.') #字符串加引号不用反斜杠需要将双引号改为单引号\n#>>> '\"isn\\'t\",she said'\n#'\"isn\\'t\",she said'  \n#在解释器下与脚本下的显示不一样\ns = 'first line.\\nsecond line.'\nprint(s)\nprint('C:\\some\\name') #C:\\some\n                      #ame\nprint(r'C:\\some\\name') #C:\\some\\name\nprint(\"\"\"\n      Usage: thingy [OPTIONS]\n      -h                 Display this Usage message\n      -H hostname        hostname to connect to\n      \"\"\") #打印帮助信息\nprint(3*'un'+'ium') #复制un三次\nprint('Py''thon') #连接多个字符串\ntext = ('put several strings within parenteses' 'to have them joined together.') #将两个字符串连接成一个字符串\nprint(text)\nprefix = 'Py'\nprint(prefix + 'thon')\n\nword = 'Python'\nprint(word[0])\nprint(word[5])#利用列表输出字符\nprint(word[-1])#从最后的字符开始取字符\nprint(word[-4])\nprint(word[2:4])#只选取2到4之间的字符\nprint(word[0:2]+word[2:4])#将两个选取的字符串连接\nprint(word[-2:]) #选取倒数第二个字符串到最后\nprint('J'+word[1:])#将J和选取的字符串连接\nprint(word[:2]+'Py')\ns = 'supercaliasdfdgfdhgfj'\nprint(len(s))#字符串长度\n{% endcodeblock %}\n输出\n{% codeblock lang:python %}\nspam eggs\ndoes't\ndoes't\nyes\",he said.\n\"yes\",he said.\n\"isn't\",she said.\nfirst line.\nsecond line.\nC:\\some\name\nC:\\some\\name\n\n      Usage: thingy [OPTIONS]\n      -h                 Display this Usage message\n      -H hostname        hostname to connect to\n      \nunununium\nPython\nput several strings within parentesesto have them joined together.\nPython\nP\nn\nn\nt\nth\nPyth\non\nJython\nPyPy\n21\n{% endcodeblock %}\n##### list(列表)\n  + 列表是一个数据可变的结构，列表中的数据字符数字都可以\n  + 列表的功能\n    1.增加数据append方法\n    2.切割列表【：】\n    3.连接两个列表\n    4.列表中的列表，列表可以包括子集列表\n  + lists.py[点击下载](/download/Python/python-tutorial-notes/chapter3/lists.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n'''\n列表\n'''\nsquares = [1,4,8,16,25]\nprint(squares)  #输出列表数据\nprint(squares[0])\nprint(squares[-1])\nprint(squares[-3:]) #从倒数第三个数据到最后一个数据\nprint(squares[:])#相当于直接输出列表全部数据\nprint(squares + [36,64,81,100])#直接在列表后面增加数据\n\n#替代列表中的数据\ncubes = [1,8,65,125.78]\nprint(cubes)\ncubes[3] = 64\nprint(cubes)\n\n#用append()方法增加数据\ncubes.append(216)\nprint(cubes)\n\ncubes.append(7**2)#增加指数\nprint(cubes)\n\n#列表中的字符串\nletters = ['a','b','c','d','e','f','g']\nprint(letters)\n#替代列表中的一串字符\nletters[2:5] = ['C','D','E'] #从2到5的数据替换成另外三个数据\nprint(letters)\nletters[2:5] = [] #将2到5的数据替换为空\nprint(letters)\nletters[:] = [] #将整个列表数据替换为空\n\nletters = ['a','b','c','d']\nprint(len(letters)) #打印字符串长度\n#将列表字符与数字连接\na = ['a','b','c','d']\nb = [1,2,3]\nc = [a,b]   #将a和b做为c列表的子集\nprint(c) #输出整个列表\nprint(c[0])#输出列表的第一个子集a\nprint(c[0][1]) #输出列表的第一个子集的第二个数据\n\n{% endcodeblock %}\n输出列表\n{% codeblock lang:python %}\n[1, 4, 8, 16, 25]\n1\n25\n[8, 16, 25]\n[1, 4, 8, 16, 25]\n[1, 4, 8, 16, 25, 36, 64, 81, 100]\n[1, 8, 65, 125.78]\n[1, 8, 65, 64]\n[1, 8, 65, 64, 216]\n[1, 8, 65, 64, 216, 49]\n['a', 'b', 'c', 'd', 'e', 'f', 'g']\n['a', 'b', 'C', 'D', 'E', 'f', 'g']\n['a', 'b', 'f', 'g']\n4\n[['a', 'b', 'c', 'd'], [1, 2, 3]]\n['a', 'b', 'c', 'd']\nb\n{% endcodeblock %}\n#### 首次编程\n##### fibonacci(斐波拉契数)[点击下载](/download/Python/python-tutorial-notes/chapter3/fibonacci.py)\n\n{% codeblock lang:python %}\n\n'''\n#!/usr/bin/env python\n# coding=utf-8\n'''\nfibonacci数\n'''\na,b = 0,1\nwhile b < 10 :\n    print(b) #先输出b\n    a,b = b,a+b #可以分解为a = b b = a+b\n{% endcodeblock %}\n\n  + 输出fibonacci\n{% codeblock lang:python %}\n1\n1\n2\n3\n5\n8\n{% endcodeblock %}\n##### 格式化输出\n{% codeblock lang:python %}\n#!/usr/bin/python3\n#coding:utf-8\n\ni = 258*258\nprint('the value of i is',i)\n{% endcodeblock %}\n输出\n{% codeblock lang:python %}\nthe value of i is 66564\n{% endcodeblock %}\n### 变种fibonacci表示[点击下载](/download/Python/python-tutorial-notes/chapter3/fibonacci1.py)\n\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n'''\nfibonacci数\n'''\na,b = 0,1\nwhile b < 1000 :\n    print(b,end=',') #用，来分割输出数据\n    a,b = b,a+b #可以分解为a = b b = a+b\n{% endcodeblock %}\n输出fibonacci1\n{% codeblock lang:python %}\n1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,\n{% endcodeblock %}\n\n","tags":["Python"],"categories":["python-tutorial-notes"]},{"title":"APUE学习笔记-标准IO库","url":"%2F2019%2F05%2F03%2FAPUE%2FAPUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FAPUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%87%E5%87%86IO%E5%BA%93%2F","content":"\n### 标准IO库\n标准io库就是C语言用来处理流和文件的一个库，它是对文件IO系统调用（不同操作系统提供不同的系统调用）的封装，这使得这套标准库能够隐藏细节，可以移植到其他平台上。\n<!-- more -->\n#### 流和对象\n对于标准IO库来说，它们的操作是围绕流进行的。标准库将需要操作的文件与流关联，通过流来对文件进行各种操作。当打开一个流时，标准IO函数返回一个FILE对象的文件结构指针，这样就能通过文件结构指针对文件进行操作。\n文件结构指针就是一个指向文件对象的指针，文件对象则是将文件所有信息封装为一个对象结构，这样的话能够进行读写字符、字符串、格式化数据、二进制数据多种形式的操作。\n#### 缓存\n相对于IO系统调用直接操作文件描述符，没有设置缓存，只能读写二进制文件（因为没有设置缓存，每次只能有一个字节被接收变量接收）。IO标准库则设置了缓存，它在内存中开辟一个缓存区。当执行读文件操作时，会先将数据读入缓存区，装满后从缓存区依次读入接收变量。这样使得能够读写字符文件(一个字符多个字节)等多字节文件。\n  + 缓存类型\n    标准IO提供三种缓存方式\n    全缓存:填满缓存区才进行IO操作(标准输入和标准输出不涉及交互，才是全缓存)\n    行缓存:遇到换行符就执行IO操作\n    不到缓存:不对字符进行缓存(标准出错是不带缓存)\n\n\n#### 标准IO库函数\n\n##### 设置缓存\n{% codeblock lang:C %}\n#include <stdio.h>\n/*******************************************\n  ①\n  mode　缓冲类型：\n  _IOFBF　全缓存\n  _IOLBF　行缓存\n  _IONBF　不带缓存\n  注意：\n    buf指向一个长度为BUFSIZ(定义在<stdio.h>中)的缓存则该流就是全缓存的\n    buf设置为NULL则关闭缓存\n********************************************/\n\n/*******************************************\n FILE *fp : *fp是一个文件指针，指向的是一个文件结构对象\n char *buf : 缓冲区，缓存fp文件中获取的数据，通常是一个数组(这个缓冲区大小是固定的，通常是系统指定的大小)\n return   : 返回值无\n function : 用于将指定的缓冲区(buf)与特定文件(fp)关联，实现操作缓冲区时直接操作文件流的功能。用来设置打开或者关闭缓存机制,操作fp文件指针指向的文件对象\n notice   : setbuf相当于调用setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZE)\n********************************************/\nvoid setbuf(FILE *fp , char *buf);\n\n/*******************************************\n  FILE *fp    : *fp是一个文件指针，指向一个文件结构对象\n  char *buf   : 缓冲区，缓存fp文件中获取的数据，通常是一个数组\n  int mode    : mode指定缓冲类型(注释一)\n  size_t size : 指定缓冲区大小\n  return      : 成功返回0,出错返回非0\n  function    : 精确的指定缓冲区大小和类型，再将缓冲区(buf)与特定文件关联(fp)，从而操作文件流\n********************************************/\nint setvbuf(FILE *fp , char *buf , int mode , size_t size);\n/*******************************************\n  FILE *fp : 文件指针\n  return   : 成功返回0,出错返回EOF\n  function : 用来刷新流，使该流所有未写的数据都被传递到内核\n  notice   : fp=NULL时，函数将刷新所有输出流\n********************************************/\nint fflush(FILE *fp);\n{% endcodeblock %}\n\n##### 打开和关闭流\n{% codeblock lang:C %}\n#include <stdio.h>\n/*******************************************\n ②\n type 参数类型:\n    r 以只读方式打开文件，该文件必须存在。\n　　r+ 以可读写方式打开文件，该文件必须存在。\n　　rb+ 读写打开一个二进制文件，只允许读写数据。\n　　w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。\n　　w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。\n　　wb 只写打开或新建一个二进制文件；只允许写数据。\n　　wb+ 读写打开或建立一个二进制文件，允许读和写。\n　　a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）\n　　a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）\n　　ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。\n\n\nPOSIX.1要求以这种方式创建的文件具有下列存取许可权:\n  S_IRUSR : 文件属主读\n  S_IWUSR : 文件属主写\n  S_IRGRP : 文件属组读\n  S_IWGRP : 文件属组写\n  S_IROTH : 其他人可读\n  S_IWOTH : 其他人可写\n********************************************/\n\n/*******************************************\n  const char *pathname : 文件路径,指针指向一个文件路径字符串(路径不能被修改,需要添加const)\n  const char *type     : 文件打开方式(参见②)\n  return               : 成功返回文件指针，出错返回NULL\n  function             : 指定打开文件方式，通过文件路径pathname打开文件\n********************************************/\nFILE *fopen(const char *pathname , const char *type);\n\n/*******************************************\n  const char *pathname : 文件路径,指针指向一个文件路径字符串(路径不能被修改,需要添加const)\n\n  const char *type     : 文件打开方式(参见②)\n  FILE *fp             : 文件指针，指向文件结构对象\n  return               : 成功返回文件指针，出错返回NULL\n  function             : 指定打开文件方式，在一个特定的流上(由fp指示),打开一个指定的文件(路径名由pathname指示)\n********************************************/\nFILE *freopen(const char *pathname , const char *type , FILE *fp);\n/*******************************************\n  int fd               : 文件描述符，是一个正整数\n  const char *type     : 文件打开方式(参见②)\n  return               : 成功返回文件指针，出错返回NULL\n  function             : 取一个现存的文件描述符(通过open,dup,dup2,fcntl,pipe函数得到),并使一个标准的IO流与该描述符相结合， 此函数常用于由创建管道和网络通信通道函数获得的插述符。因为这些特殊类型文件不能用标准IO fopen函数打开，需要调用设备专用函数获得文件描述符。然后使一个标准IO流与该描述符相结合\n********************************************/\nFILE *fdopen(int fd , const char *type);\n\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  return               : 成功返回0，出错返回EOF\n  function             : 关闭一个打开的指定文件流\n********************************************/\nint fclose(FILE *fp);\n{% endcodeblock %}\n\n##### 读和写流\n一旦打开了流，可以在三种不同的 **非格式化IO** 中进行选择，对其进行读写操作。\n  + 每次一个字符的IO\n    一次读或者写一个字符，如果流带缓冲，则处理所有缓冲\n  + 每次一行的IO\n    使用fgets和fputs一次读或写一行，每行以一个换行符终止。\n  + 直接IO\n    fread和fwrite函数支持，每次IO操作读或写某种数量的对象，每个对象具有指定长度。通常用于从二进制文件中读或写一个结构\n\n\n###### 输入函数\n用于一次读一个字符\n{% codeblock lang:C %}\n\n/*******************************************\n  注意：\n    使用unsigned char不带符号: \n    如果最高位为1(如果是有符号，1000 0000这个最高位为1为符号位，表示负数；如果是无符号，最高位不是符号位，就算为1也表示一个正数)也不会使返回值为负\n    要求返回值是int类型:\n    因为已发生错误或已到达文件尾端的指示值EOF值为-1,是一个负数，unsigned char不能表示，需要使用int类型\n********************************************/\n#include <stdio.h>\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  return               : 成功返回下一个字符(int类型,unsigned char类型强转)，出错返回EOF(-1)\n  function             : 与fgetc等价，不同在于可被实现为宏\n  notice               : \n                        1 不应当具有副作用的表达式.（常量，只能为右值,效率高）\n                        2 fgetc一定是一个函数，可以得到其地址。允许将fgetc地址作为参数传递\n********************************************/\nint getc(FILE *fp) ;\n\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  return               : 成功返回下一个字符(int类型,unsigned char类型强转)，出错返回EOF(-1)\n  function             : 从文件流中读取下一个字符\n  notice               : 这里返回一个int类型是因为EOF是一个远大于char类型范围的数，只能使用int类型来接收。如果返回unsigned char型(不能为负数)，就永远不能接收EOF(在宏中定义为-1),int类型能够接收\n********************************************/\nint fgetc(FILE *fp);\n\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  return               : 成功返回下一个字符(int类型,unsigned char类型强转)，出错返回EOF(-1)\n  function             : 等同于getc(stdin),从标准输入获取\n********************************************/\nint getchar(void) ;\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  return               : 若条件为真则为非 0(真),否则为0(假)\n  function             : 返回出错标志\n********************************************/\nint ferror(FILE *fp);\n\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  return               : 若条件为真则为非 0(真),否则为0(假)\n  function             : 返回文件结束标志\n********************************************/\nint feof(FILE *fp);\n\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  return               : 无返回值\n  function             : 清除出错标志和结束标志\n********************************************/\nvoid clearerr(FILE *fp);\n\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  int c                : 要读的字符\n  return               : 若成功则为c,若出错则为EOF\n  function             : 从一个流读字符c之后，可以调用这个函数将字符c再送回流中。送回流中的字符以后可以从流中读出，但读出字符顺序与送回顺序相反。\n********************************************/\nint ungetc(int c , FILE *fp);\n{% endcodeblock %}\n\n###### 输出函数\n对应输入函数，每个输入函数都有一个输出函数，性质与上面输入函数相对应\n{% codeblock lang:C %}\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  int c                : 要取的字符\n  return               : 若成功则为c,若出错则为EOF\n  function             : 与fgetc等价，不同在于可被实现为宏\n********************************************/\nint putc(int c , FILE *fp);\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  int c                : 要取的字符\n  return               : 若成功则为c,若出错则为EOF\n  function             : 将一个字符c,强制转换为unsigned char , 写入流中\n********************************************/\nint fputc(int c , FILE *fp);\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  int c                : 要取的字符\n  return               : 若成功则为c,若出错则为EOF\n  function             : 等价于putc(c, stdout)\n********************************************/\nint putchar(int c);\n{% endcodeblock %}\n\n##### 每次一行IO\n{% codeblock lang:C %}\n/*\n  获取输入缓存\n*/\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  int n                : 指定缓存大小\n  char *buf            : 用于缓存读取到的字符\n  return               : 若成功则为buf,若已处文件尾端或出错则为NULL\n  function             : 从流(fp)中读取小于n个字符，并存储到buf(字符串指针)中,遇到EOF或者换行符停止。该缓存一个NULL字符结尾\n********************************************/\nchar *fgets(char *buf , int n , FILE *fp);\n/*******************************************\n  return               : 若成功则为 buf,若已处文件尾端或出错则为NULL\n  function             : 尽量不要使用，不能指定缓存长度，可能造成缓存越界\n********************************************/\nchar *gets(char *buf); \n\n/*\n  输出一行\n*/\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  const char *str      : 指向一个字符串，这个字符串是一个常量，不能修改\n  return               : 若成功则为非负值,若出错则为EOF\n  function             : 将一个以NULL字符终止的字符串(str)写到指定的流(fp),终止符NLL不写出\n********************************************/\nint fputs(const char *str , FILE *fp);\n/*******************************************\n  const char *str      : 指向一个字符串，这个字符串是一个常量，不能修改\n  return               : 若成功则为c,若出错则为EOF\n  function             : 将一个以NULL字符终止的字符串写到标准输出，终止符不写出(尽量避免使用)\n********************************************/\nint puts(const char *str);\n{% endcodeblock %}\n\n##### 二进制IO\n二进制IO，我么需要一次读或写整个结构\nfgetc和fputs一次只能读写一字节\n其中可能会有null字符，所以不能用fputs和fgets\n{% codeblock lang:C %}\n/*******************************************\n  const char *ptr      : 指向二进制数据的开始地址\n  size_t size          : 二进制数据大小\n  size_t nobj          : 对象个数\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  return               : 读的对象数(也就是nobj)\n  function             :指定需要读取的对象个数，指定需要读取的大小， 从流fp中读取数据，放入以ptr为开始地址的后面size大小的内存空间中\n********************************************/\nsize_t fread(void *ptr , size_t size , size_t nobj , FILE *fp);\n/*******************************************\n  const char *ptr      : 指向二进制数据的开始地址\n  size_t size          : 二进制数据大小\n  size_t nobj          : 对象个数\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  return               : 写的对象数(也就是nobj)\n  function             : 指定需要读取的对象个数，指定需要读取的大小，将以ptr为开始地址的后面内存空间中的数据写入流fp中 \n********************************************/\nsize_t fwrite(const void *ptr , size_t size , size_t nobj , FILE *fp);\n{% endcodeblock %}\n\n##### 定位流\n{% codeblock lang:C %}\n#include <stdio.h>\n/*\n  ftell和fseek\n    是Unix函数，他们假定文件的位置可以存放在一个长整型中。\n    只能以字节为计量单位\n*/\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  return               : 若成功则为当前文件位置指示,若出错则为-1L\n  function             : 函数通过fp流获取这个流指向的位置指示符指示的当前值\n  notice               : 对于二进制文件，位置指示符是从文件起始位置开始度量，以字节为单位\n********************************************/\nlong ftell(FILE *fp);\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  long offset          : 文件偏移量,以字节为单位\n  int whence           : 设置文件开始位置(SEEK_SET(文件起始位置),SEEK_CUR(当前位置),SEEK_END(文件结束位置))\n  return               : 若成功则为0,若出错则为非0\n  function             : 函数通过fp获取文件流，通过whence设置函数在哪里开始，通过offset设置whence后面需要有多少个字节\n  notice               :\n                         1 对于二进制文件，位置指示符是从文件起始位置开始度量，以字节为单位\n    　                   2 对于文本文件，whence一定要在文件起始位置，offset只能是0或者对该文件ftell返回的值\n********************************************/\nint fseek(FILE *fp , long offset , int whence);\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  return               : 无返回值\n  function             : 将流中的文件位置指示符放置到文件开始位置\n********************************************/\nvoid rewind(FILE *fp);\n\n\n/*\n  fgetpos和fsetpos函数\n    是ANSIC C标准函数\n    设置了一个fpos_t对象，将当前值存入对象中，使得值能重复利用\n\n*/\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  fpos_t *pos          : pos指向的对象用于存放当前值\n  return               : 若成功则为 0,若出错则为非 0\n  function             : fgetpos将文件指示器的当前位置存入有pos指向的对象中\n********************************************/\nint fgetpos(FILE *fp , fpos_t *pos);\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  fpos_t *pos          : pos指向的对象用于存放当前值(这个值是从fgetpos的pos中获取的，是固定的)\n  return               : 若成功则为 0,若出错则为非 0\n  function             : fsetpos取出pos中的当前值，用这个值来定位到文件流中的该位置\n********************************************/\nint fsetpos(FILE *fp , const fpos_t *pos);\n{% endcodeblock %}\n\n##### 格式化IO\n###### 格式化输出\n{% codeblock lang:C %}\n#include <stdio,h>\n/*\n  printf,fprintf,sprintf是非常常用的格式化输出函数\n  与之对应的则是scanf,fscanf,sscanf三个格式化输入函数\n\n*/\n/*******************************************\n  char *format         : 提示信息，包括指定格式化格式\n  ...                  : 需要格式化的数据\n  return               : 若成功则为输出字符数,若输出出错则为负值\n  function             : 将格式化数据写到标准输出\n********************************************/\nint printf(const char *format , ...);\n/*******************************************\n  FILE *fp             : 文件指针，指向一个文件结构对象\n  char *format         : 提示信息，包括指定格式化格式\n  ...                  : 需要格式化的数据\n  return               : 若成功则为输出字符数,若输出出错则为负值\n  function             : 将格式化数据写到指定的流fp\n********************************************/\nint fprintf(FILE *fp , const char *format , ...);\n/*******************************************\n  char *buf            : 缓存数组，用于接收格式化数据\n  char *format         : 提示信息，包括指定格式化格式\n  ...                  : 需要格式化的数据\n  return               : 存入数组的字符数\n  function             : 将格式化的字符串写入缓存数组buf中\n  notice               : 会在数组尾端加入null字节，但不包括在返回值中  可能会造成由buf指向的缓存溢出\n********************************************/\nint sprintf(char *buf , const char *format , ...);\n\n#include <stdarg,h>\n/********************************************\n  上面三个格式化输出函数的变种，可变参数表变化为va_list宏\n  va_list              : va_list是一种类型(定义在stdarg.h),表示参数列表，和...的功能差不多，但是它可以使用stdarg.h中的函数进行拓展\n*********************************************/\nint vprintf(const char *format , va_list arg);\nint vfprintf(FILE *fp , const char *format , va_list arg);\nint vsprintf(char *buf , const char *format , va_list arg);\n\n{% endcodeblock %}\n\n###### 格式化输入\n{% codeblock lang:C %}\n\n#include <stdio,h>\n/********************************************\n  这三个格式化输入函数的功能与上面对应的格式化输出函数的功能项对应\n  return : 返回指定的输入项数，若输入出错，或在任意变化前已至文件尾端则为EOF\n*********************************************/\nint scanf(const char *format , ...);\nint fscanf(FILE *fp , const char *format , ...);\nint sscanf(const char *buf , const char *format , ...);\n{% endcodeblock %}\n\n##### 实现细节\n总的来说，标准IO函数库中的库函数最终都会调用IO系统调用\n因此，每个流都会有与其相关的文件描述符(IO系统调用都是使用文件描述符来进行的)\n我们可以使用函数获取文件描述符\n{% codeblock lang:C %}\n#include <stdio.h>\n\n/********************************************\n  FILE *fp : 文件指针\n  return   : 返回与该流相关的文件描述符\n  function : 指定文件流，获取该文件流的文件描述符\n  notice   : 如果标准IO库函数需要调用系统调用，则需要用这个函数获取文件描述符来调用\n*********************************************/\nint fileno(FILE *fp);\n{% endcodeblock %}\n我们可以用一个程序来获取标准库的实现细节\n{% codeblock lang:C %}\n//#include \"../../include/apue.h\"\n#include \"../../include/standard_error.h\"\n#include <stdio.h>\n\n/***************************************************\n  const char * :  流的别名，由使用函数者命名\n  FILE *fp     :  使用的流\n  function     :  为特定的流命名，并输出流的缓存类型和缓存大小\n****************************************************/\nvoid pr_stdio(const char * , FILE *fp);\n\nint main(void)\n{\n  FILE *fp ;\n  /* 将一行字符串输出到标准输出 */\n  fputs(\"enter any character\\n\" , stdout);\n  /* 从标准输入读取字符，如果没有读取到结尾就结束，表示错误 */\n  if(getchar() == EOF)\n  {\n    err_sys(\"getchar error\");\n  }\n  fputs(\"one line to standard error\\n\",stderr);\n\n  pr_stdio(\"stdin\"  , stdin);  /* 由getchar放入标准输入 */\n  pr_stdio(\"stdout\" , stdout); /* fputs里的字符输出到标准输出 */\n  pr_stdio(\"stderr\" , stderr); /* fputs里的字符输出到标准错误 */\n\n  if((fp = fopen(\"/etc/motd\" , \"r\")) == NULL)\n  {\n    err_sys(\"fopen error\");\n  }\n\n  /* 从文件流中一个字节一个字节的获取，直到遇上EOF */\n  if(getc(fp) == EOF)\n  {\n    err_sys(\"getc error\");\n  }\n\n  pr_stdio(\"/etc/motd\" , fp);\n\n  exit(0);\n}\n\nvoid pr_stdio(const char *name , FILE *fp)\n{\n  printf(\"stream = %s, \" , name);\n  if(fp->_flags & _IONBF)\n  {\n    printf(\"无缓存\");\n  }else if(fp->_flags & _IOLBF)\n  {\n    printf(\"行缓存\");\n  }else\n  {\n    printf(\"全缓存\");\n  }\n  /* 在linux下可能没有bufsiz这个属性 */\n  printf(\", buffer size = %d\\n\" , fp->_bufsiz); \n}\n\n/*\n  结论:\n    当标准输入、输出连至终端时，它们是行缓存;当它们定向到普通文件则是全缓存\n    普通文件按系统默认是全缓存\n\n */\n{% endcodeblock %}\n\n\n##### 临时文件\n{%codeblock lang:C  %}\n#include <stdio.h>\n/********************************************\n  char *ptr : 一个指向字符串的指针，用来存放产生的有效路径名字符串\n  return    : 返回指向唯一路径名的指针\n  function  : 产生一个与现在文件名不同的一个有效路径名字符串，每次调用，都会产生一个不同的路径名,最多调用次数是TMP_MAX(stdio.h),放入ptr指向的内存区\n  notice    : ptr=NULL,产生的路径名存放在一个静态区，指向静态区的指针作为函数值返回，下一次调用,会重写静态区\n              如果不是NULL,则指向长度至少是L_tmpnam个字符的数组(stdio.h)\n*********************************************/\nchar *tmpnam(char *ptr);\n/********************************************\n  return    : 若成功则为文件指针,若出错则为NULL\n  function  : 创建一个临时文件，返回一个指向这个临时文件的文件指针\n*********************************************/\nFILE *tmpfile(void);\n\n\n/********************************************\n  directory选择：\n    选择环境变量TMPDIR作为目录(如果有)\n    directory非NULL,指定directory为目录\n    将<stdio.h>中的字符串P_tmpdir作为目录\n    将本地/tmp目录作为目录\n  prefix注意:\n    如果非NULL，最多包含5个字符\n  const char *directory : 指定需要创建的临时文件所在的目录\n  const char *prefix    : 指定需要创建的临时文件的前缀\n  return                : 返回指向临时文件的唯一路径名的指针\n  function              : 指定临时文件目录和前缀，通过这些创建一个指定目录，指定前缀的临时文件\n*********************************************/\nchar *tempnam(const char *directory , const char *prefix);\n{% endcodeblock %}\n\ntmpnam和tmpfile应用\n\n{% codeblock lang:C %}\n\n#include \"../../include/standard_error.h\"\n#include <stdio.h>\n\nint main(void)\n{\n  char name[L_tmpnam] , line[MAXLINE] ;\n  FILE *fp ;\n\n  /* 使用tmpnam创建一个有效的路径名字符串，放入静态区中，指向该静态区的指针作为函数返回值 */\n  printf(\"%s\\n\",tmpnam(NULL));\n\n  /* 将产生的有效路径名字符串放入name数组中，并将name返回 */\n  tmpnam(name);\n  printf(\"%s\\n\",name);\n\n  /* 创建一个临时二进制文件,返回临时文件对象,关闭程序后将自动删除 */\n  if((fp = tmpfile()) == NULL)\n  {\n    err_sys(\"tmpfile error\");\n  }\n  /* 将字符串写入文件对象中 */\n  fputs(\"one line of output\\n\",fp);\n  /* 将指针复位到起始地址，从起始地址开始读取 */\n  rewind(fp);\n  /* 从文件对象中一行一行的获取数据，并放到line数组中 */\n  if(fgets(line , sizeof(line) , fp) == NULL)\n  {\n    err_sys(\"fgets error\");\n  }\n  /* 从line数组中去除数据放入标准输出中 */\n  fputs(line , stdout);\n  exit(0);\n}\n{% endcodeblock %}\n\ntempnam应用\n{% codeblock lang:C %}\n#include \"../../include/standard_error.h\"\n#include <stdio.h>\n\nint main(int argc , char *argv[])\n{\n  /* 第一个argc是命令,第一个参数是目录,第二个参数是前缀 */\n  if(argc != 3)\n  {\n    err_quit(\"usage:a.out<directory><prefix>\");\n  }\n\n  /*\n      argv[1][0] != '' ? argv[1]:NULL  : 如果第一个参数不是空字符串则正常输出，如果是则输出为NULL\n      argv[2][0] != ' '? argv[2]:NULL  : 如果第二个参数不是空字符串则正常输出，如果是则输出为NULL\n   */\n  printf(\"%s\\n\",tempnam(argv[1][0] != ' ' ? argv[1]:NULL , argv[2][0] != ' '?argv[2]:NULL));\n  exit(0) ;\n}\n{% endcodeblock %}\n\n","tags":["APUE"],"categories":["APUE学习笔记"]},{"title":"输入与输出","url":"%2F2019%2F05%2F03%2FPython%2Fpython-tutorial-notes%2Fchapter7_input_and_output%2Finput-and-output%2F","content":"\n\n\n### 输入与输出\n\n\n#### 更好看的输出格式\n  + 处理所有的字符串\n    用字符串的切割和连接操作创建自己需要的布局\n  + 使用str(适用于人机交互)和repr(适用于解释器理解)输出\n  + 格式化字符串或者使用str.format()方法\n  + [format_output](/download/Python/python-tutorial-notes/chapter7/format_output.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n\ns = 'Hello world.'\nprint(str(s)) #字符串输出格式,用于将值转换为适用于人阅读的形式\nprint(repr(s)) #返回一个字符串，将值转换为适用于解释器的形式\nprint(str(1/7)) #将数值转换为字符串输出\n\nx = 10*3.25\ny = 200*200\ns = 'the value of x is '+ repr(x) + ' ,and y is ' + repr(y) + '...'\nprint(s)\n\nhello = 'Hello , world.\\n'\nprint(hello) #print会将\\n判断为换行符\nhellos = repr(hello) #repr会将\\n判断为一个字符\nprint(hellos)\nprint(repr((x,y,('spam','eggs')))) #repr的参可以是任何python对象\n\n#输出平方和立方的两种方法\nfor i in  range(1,11):\n    print(repr(i).rjust(2),repr(i*i).rjust(3),end=' ')#第一大列和第二大列所占空格分别为两个和三个（每一大列容纳酔大的空格数）\n    print(repr(i*i*i).rjust(4)) #第三大列所占空格为四个\n\nfor x in range(1,11):\n    print('{0:2d},{1:3d},{2:4d}'.format(x,x*x,x*x*x))#每列的空格由print()增加的\n#repr.rjust()方法表示向右对齐\n\n#str.zfill()表示向左填充0，如下\na = '12'.zfill(5) #只有两位，不足5位，需要在前面填充0\nprint(a)\nb = '-3.14'.zfill(7) #所有字符有5位，不足7位，需要在前面填充0\nprint(b)\nc = '3.14159265359'.zfill(5)#由于字符串位数比给定的大，不需要填充\nprint(c)\nd = '3.1416'.zfill(5)\nprint(d)\n#当字符串中的字符数少于.zfill中的数字，则在前面填充0；当等于或大于时，正常输出字符串。\n\n#.format()函数用法,format输出格式其实就是str.format()形式\nprint('we are the {},who say \"{}\"!'.format('knight','Ni'))\nprint('{0} and {1}.'.format('spam','eggs'))#{}中数字表示所在位置\nprint('{1} and {0}.'.format('spam','eggs'))#{0}表示.format中的第二个参数在输出参数中的第一个位置\n\n#关键字参数用在format中\nprint('this {food} is {adjective}.'.format(food='spam',adjective='absolutely horrible'))#输出关键字参数对应的键值\n\n#位置与关键字参数组合\nprint('the story is {0},{1} and {other}.'.format('Bill','Manfred',other='Georg'))\n\n#!a(apply acsii),!r(apply repr),!s(apply str).就是将输入的转换为对应的格式\ncontents = 'eels'\nprint('my hovercraft is full of {}.'.format(contents))\nprint('my hovercraft is full of {!r}!'.format(contents))#转换为repr格式\nprint('my hovercraft is full of {!a}.'.format(contents))#转换为ascii格式\nprint('my hovercraft is full of {!s}.'.format(contents))#转换为str格式\n\n#用‘':'，':'之后的整数表示字符所需要的最小范围\ntable = {'Sjoerd':4127,'Jack':4098,'Dcab':7679}\nfor name,phone in table.items(): #table.items表示关键字参数\n    print('{0:10} ==> {1:10d}'.format(name,phone)) #第一个表示输出的是字符，第二个表示输出的是数字，通过位置表示键值\n\n#通过关键字(用0[keyword]表示关键字参数)来表示键值(用d表示键值),只需要输出字典\ntable = {'Sjoerd':4127,'Jack':4098,'Dcab':6079493}\nprint('Jack:{0[Jack]:d};  Sjoerd:{0[Sjoerd]:d};''  Dcab:{0[Dcab]:d}'.format(table)) \nprint('Jack:{0[Jack]:d};  Sjoerd:{0[Sjoerd]:d};'.format(table)) \n\n#用'**'表示关键字参数,与内建函数vars（返回一个包含本地变量的字典）联合使用\nprint('Jack:{Jack:d};  Sjoerd:{Sjoerd:d};''  Dcab:{Dcab:d}'.format(**table)) \n\n#老式的string格式\nimport math \nprint('the value of PI is approximately %5.3f.'%math.pi)\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\nHello world.\n'Hello world.'\n0.14285714285714285\nthe value of x is 32.5 ,and y is 40000...\nHello , world.\n\n'Hello , world.\\n'\n(32.5, 40000, ('spam', 'eggs'))\n 1   1    1\n 2   4    8\n 3   9   27\n 4  16   64\n 5  25  125\n 6  36  216\n 7  49  343\n 8  64  512\n 9  81  729\n10 100 1000\n 1,  1,   1\n 2,  4,   8\n 3,  9,  27\n 4, 16,  64\n 5, 25, 125\n 6, 36, 216\n 7, 49, 343\n 8, 64, 512\n 9, 81, 729\n10,100,1000\n00012\n-003.14\n3.14159265359\n3.1416\nwe are the knight,who say \"Ni\"!\nspam and eggs.\neggs and spam.\nthis spam is absolutely horrible.\nthe story is Bill,Manfred and Georg.\nmy hovercraft is full of eels.\nmy hovercraft is full of 'eels'!\nmy hovercraft is full of 'eels'.\nmy hovercraft is full of eels.\nJack       ==>       4098\nDcab       ==>       7679\nSjoerd     ==>       4127\nJack:4098;  Sjoerd:4127;  Dcab:6079493\nJack:4098;  Sjoerd:4127;\nJack:4098;  Sjoerd:4127;  Dcab:6079493\nthe value of PI is approximately 3.142.\n{% endcodeblock %}\n\n#### 对文件进行读写操作\n  + f.open(filename,mode) filename:文件名；mode:进行操作的方式，读操作（r）,写操作（w）,只能对文件增加数据（a）,进行读写操作（r+）\n  + 用with关键字进行文件操作,在完成任务后将会关闭文件,如果不用，需要使用f.close()函数关闭文件\n  + [file_read_write](/download/Python/python-tutorial-notes/chapter7/file_read_write.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n\nwith open('workfile') as f:#为open()取别名\n    read_data = f.read() #workfile中读取的数据放入read_data\nprint(read_data)\nprint(f.closed) #标记文件是否已经关闭，true表示正确关闭\n#print(f.read()) #运行错误，表示文件确实被关闭\n#f.close()\n#print(f.read()) #文件\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\n```\nthis is the entire file.\\n\nasl;lfhdsgjkvnhbkgdsfghi\n\nTrue\n```\n```\n>>> with open('workfile') as f:\n...     read_data = f.read()\n>>> f.closed\nTrue\n```\n```\n>>> f.close()\n>>> f.read()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: I/O operation on closed file\n{% endcodeblock %}\n\n##### 文件对象的方法\n  + f.read() :读取文件\n  + f.readline() :从文件中读取单行(用\\n结尾)\n  + [file_object_methods](/download/Python/python-tutorial-notes/chapter7/file_object_methods.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n\nf = open('workfile') #打开文件\nprint(f.read()) #读取文件\nprint(f.read()) #由于已经读取过了，再读取为空\n\nf = open('workfile1') #打开文件\nprint(f.readline()) #只读取一行，不能与f.read一起用\nprint(f.readline()) #再读取只能读取下一行,读取了的不能再读取\n\n#用循环将文件中的文本取出\nfor line in f:\n    print(line,end=' ')\nf = open('workfile1', 'w') #打开文件,并支持写入\nprint(f.write('this is a text\\n')) #向文件写入文本，返回写入文本的长度\n\n#将其他类型转换为字符串\nf = open('workfile1', 'w') #打开文件,并支持写入\nvalue = ('answer',42) #元组\ns = str(value) #将元组转换为字符串\nf.write(s) #将s写入f文件中，需要有w权限\n\nprint('please input:\\n')\nf = open('workfile3','rb+') #表示有读取文件，可以追加binary类型数据\nprint(f.write(b'0123456789abcdef')) #写入binary类型数据\nprint(f.seek(5)) #寻找文件中第六个字节\nprint(f.read(1))\nprint(f.seek(-3,2))\nprint(f.read(1))\n\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\nasdfdgfdhgfj\nthis a double text\n\nthis is a text\n\n\n('answer', 42)\n\n\n15\nplease input:\n\n16\n5\nb'5'\n15\nb'f'\n{% endcodeblock %}\n\n#### 用json保存数据结构\nimport json\njson.dumps()\njson.dumps(x,f)\njson.load()\n","tags":["Python"],"categories":["python-tutorial-notes"]},{"title":"控制流工具","url":"%2F2019%2F05%2F03%2FPython%2Fpython-tutorial-notes%2Fchapter4_control_flow_tools%2Fcontrol-flow-tools%2F","content":"\n\n### 控制流工具\n#### if语句\n  + [if_example](/download/Python/python-tutorial-notes/if_example.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\nx = input(\"please enter an data: \") #说明语句和输入变量,这里的x是str类型\nprint(x) #输出\nb = int(input(\"please enter an integer: \"))#只能输入整型数据，输入其他报错,b是int类型\nprint(b)\n\n#if语句\n\nif b < 0 :\n    b = 0\n    print('negative changed to zero') #输出字符串\nelif b == 0:\n    print('zero')\nelif b == 1:\n    print('single')\nelse:\n    print('more')\n```\n + 输出\n```\nplease enter an data: 21\n21\nplease enter an integer: 1\n1\nsingle\n\n```\n\n#### for 语句\n  + [for-example](/download/Python/python-tutorial-notes/for_example.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\n'''\n用for输出列表中的字符串\n'''\nwords = ['cat','windows','linux','strings']\n\n#for语句\nfor x in words: #x为words中的子集word[0...3],word[0]=cat\n    print(x,len(x)) #输出x和len\n```\n  + 输出\n```\ncat 3\nwindows 7\nlinux 5\nstrings 7\n```\n  + [for-example1](for_example1.py/download/Python/python-tutorial-notes/)\n```\n#!/usr/bin/env python\n# coding=utf-8\nwords = ['cat','windows','linux','pig']\nfor x in words[:]:\n    if len(x) > 5:\n        words.insert(0,x) #将符合条件的数据增加到words[0]中\n        print(words)\n```\n  + 输出\n```\n['windows', 'cat', 'windows', 'linux', 'pig']\n```\n\n#### range()函数\n  + [range-example](/download/Python/python-tutorial-notes/range-example.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\n\nfor i in range(10): #表示输出从0到10的整数\n    print('please output i: %d\\t'%i)  \nprint('\\n')\n\nfor x in range(5,10): #输出从5到10的数\n    print('please output x: %d\\t'%x)  \nprint('\\n')\n\nfor b in range(0,10,3):#输出从0到10的数（每个数之间相隔3）\n    print('please output b: %d\\t'%b)  \n\nprint('\\n')\nfor c in range(-10,-100,-30):#输出从-10到-100的数（每个数之间隔-30）\n    print('please output c: %d\\t'%c)  \n\n#range()函数与len()函数连用\na = ['mary','had','a','little','lamb']\nprint('\\n')\nfor e in range(len(a)): #用a的长度做为i的范围\n    print(e,a[e])#输出第i个a[i]\n\n#直接输出range\nprint(range(0,10))\n\n#用列表输出\nd = list(range(5))\nprint(d)\n```\n  + 输出格式\n```\nplease output i: 0\t\nplease output i: 1\t\nplease output i: 2\t\nplease output i: 3\t\nplease output i: 4\t\nplease output i: 5\t\nplease output i: 6\t\nplease output i: 7\t\nplease output i: 8\t\nplease output i: 9\t\n\n\nplease output x: 5\t\nplease output x: 6\t\nplease output x: 7\t\nplease output x: 8\t\nplease output x: 9\t\n\n\nplease output b: 0\t\nplease output b: 3\t\nplease output b: 6\t\nplease output b: 9\t\n\n\nplease output c: -10\t\nplease output c: -40\t\nplease output c: -70\t\n\n\n0 mary\n1 had\n2 a\n3 little\n4 lamb\nrange(0, 10)\n[0, 1, 2, 3, 4]\n```\n\n#### 循环中的break,contiune,else子句\n  + [for-break-example](/download/Python/python-tutorial-notes/for_break_example.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\nfor n in range(2,10): #从2到10\n    for x in range(2,n):#从2到n  双重循环\n        if n % x == 0 :\n            print(n,'equals',x,'*',n//x)\n            break  #停止循环\n        else:\n            print(n,'is a prime number')\n\nfor num in range(2,10): \n    if(num % 2 == 0): #求余\n        print(\"found an even number\",num)\n        continue #继续循环\n    print(\"found a number\",num)\n```\n  + 输出格式\n```\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n5 is a prime number\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n7 is a prime number\n7 is a prime number\n7 is a prime number\n7 is a prime number\n8 equals 2 * 4\n9 is a prime number\n9 equals 3 * 3\nfound an even number 2\nfound a number 3\nfound an even number 4\nfound a number 5\nfound an even number 6\nfound a number 7\nfound an even number 8\nfound a number 9\n```\n\n#### pass语句\n##### 遇到pass语句,两种情况\n  + 语句中，会使程序等待在那里，需要强制断开（ctrl+c）\n  + 类中，构造一个空类，适合以后想到东西可以直接在这里补充\n##### example\n  + [pass-example](/download/Python/python-tutorial-notes/pass-example.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\nwhile True:\n    pass\n#不能输出，程序等待，一直运行\n```\n##### class\n  + [pass-class-example](/download/Python/python-tutorial-notes/pass_class_example.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\nclass MyEmptyClass:\n    pass\n#这个空类可以以后用\n```\n##### def\n  + [pass-def-example](/download/Python/python-tutorial-notes/pass_def_example.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\ndef initlog(*args):\n    pass\n```\n\n#### 定义函数\n##### fibnacci\n  + [def_fibnacci](/download/Python/python-tutorial-notes/def_fibnacci.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\n#example1\ndef fibnacci(n):\n    a,b = 0,1\n    while a<n :\n        print(a,end=',')\n        a,b = b , a+b\n#输出需要在函数外面     \nprint(fibnacci(1000))\n\n#example2\ndef fibnacci2(n):\n    result = [] #result为输出结果\n    a,b = 0 , 1 \n    while a < n:\n        result.append(a)#将a增加如result\n        a,b = b , b+a\n    return result #返回结果\nprint('实例输出：\\n')\nprint(fibnacci2(100)) \n```\n  + 输出\n```\n0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,None\n实例输出：\n\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n```\n\n#### 更多的定义函数\n##### 默认参数值,只能指向不变对象\n  + [def_default_argument_values](/download/Python/python-tutorial-notes/def_default_argument_values.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\n'''\n默认参数值\n'''\ndef ask_ok(prompt , retries=4 , reminder='please try again!'): #retries,reminder为默认参数\n    while True :\n        ok = input(prompt)\n        if ok in ('y','ye','yes'):#输入其中的一个\n            return True \n        if ok in ('n','no','nop','nope'):#如果第一个为真，这句将不执行\n            return False\n        retries = retries-1 #每执行一次，retries-1\n        if retries < 0 : #当执行完次数，则报错\n            raise ValueError('invalid user response')\n        print(reminder) #打印结果，retries<0后重新运行程序\n#这个函数参数两个参数为默认参数，默认参数如果不赋值，则默认输出\n#如果赋值，则依照赋值的数据打印\n\n    \n#实例1\nprint(ask_ok('Do you really want to quit?'))\n#实例2\nprint(ask_ok('OK to overwrite the file ?',2))#2为retries赋值\n#实例3\nprint(ask_ok('OK to overwrite the file ?',2,'Come on , inly yes or no!'))\n```\n\n  + 实例1\n```\nDo you really want to quit?\nplease try again!\nDo you really want to quit?\nplease try again!\nDo you really want to quit?\nplease try again!\nDo you really want to quit?\nplease try again!\nDo you really want to quit?\nTraceback (most recent call last):\n  File \"def-default-argument-values.py\", line 22, in <module>\n    print(ask_ok('Do you really want to quit?'))\n  File \"def-default-argument-values.py\", line 15, in ask_ok\n    raise ValueError('invalid user response')\nValueError: invalid user response\n\n```\n  + 实例2\n```\nOK to overwrite the file ?\nplease try again!\nOK to overwrite the file ?\nplease try again!\nOK to overwrite the file ?\nTraceback (most recent call last):\n  File \"def-default-argument-values.py\", line 24, in <module>\n    print(ask_ok('OK to overwrite the file ?',2))#2为retries赋值\n  File \"def-default-argument-values.py\", line 15, in ask_ok\n    raise ValueError('invalid user response')\nValueError: invalid user response\n```\n  + 实例3\n```\nOK to overwrite the file ?\nCome on , inly yes or no!\nOK to overwrite the file ?\nCome on , inly yes or no!\nOK to overwrite the file ?\nTraceback (most recent call last):\n  File \"def-default-argument-values.py\", line 26, in <module>\n    print(ask_ok('OK to overwrite the file ?',2,'Come on , inly yes or no!'))\n  File \"def-default-argument-values.py\", line 15, in ask_ok\n    raise ValueError('invalid user response')\nValueError: invalid user response\n\n```\n\n##### 默认参数\n  + [def_arg](/download/Python/python-tutorial-notes/def_arg.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\ni = 5 \ndef f(arg = i):\n    print(arg)\ni = 6\nf()\n\n#实例\nprint(f())\n```\n  + 输出\n```\n5\n5\nNone\n```\n##### f\n  + [f](/download/Python/python-tutorial-notes/def_f.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\ndef f(a , L = []): \n    L.append(a) #将变量a增加入L\n    return L\n#实例1\nprint(f(1))\nprint(f(2))\nprint(f(3))\nprint(f(4,[1,2,3,4]))\nprint(f(4,[1,2,3,4]))\nprint(f(1))\nprint(f(2))\nprint(f(3))\n```\n  + 输出\n```\n[1]\n[1, 2]\n[1, 2, 3]\n[1, 2, 3, 4, 4]\n[1, 2, 3, 4, 4]\n[1, 2, 3, 1]  #当为默认参数重新赋值，此后的默认参数将会改变\n[1, 2, 3, 1, 2]\n[1, 2, 3, 1, 2, 3]\n```\n### f_example \n  + [f_example](/download/Python/python-tutorial-notes/def_f_example.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\ndef f_example(L=[]):\n    L.append('END')\n    return L\nprint(f_example())\nprint(f_example([1,2,3]))\nprint(f_example())\n\n```\n  + 输出\n```\n['END'] \n[1, 2, 3, 'END']  #现在默认参数为END\n['END', 'END']  #第一个为默认参数，后面一个是增加的\n```\n#### 可变参数\n##### def-varied\n  + [def_varied](/download/Python/python-tutorial-notes/def_varied.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\n'''\n可变参数\n'''\ndef varied(*numbers): #可变参数,可以传入多个参数,*numbers相当于一个元组tuple\n    sum = 0\n    for n in numbers:\n        sum = sum + n*n\n    return sum\n\nprint(varied(1,3,4,5))\n```\n  + 输出\n```\n51  #可变参数能同时输入多个参数，组合成元组，进行运算\n```\n\n#### 关键字参数\n  + 需要关键字和关键字值形式keyword=value\n##### parrot\n  + [parrot](/download/Python/python-tutorial-notes/def_parrot.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\ndef parrot(voltage,state = 'a stiff',action = 'voom',type = 'Norwegian Blue'):\n    print('--this parrot wouldn\\'t',action,end='') #用空格分开\n    print(\"if you put\",voltage,\"volts though it.\") \n    print(\"--lovely plumage , the \",type )\n    print(\"it's\",state , \"!\")\n\n#实例1\n#print(parrot(1000)) #voltage值为1000，其他使用默认变量 位置参数\n#实例2\n#print(parrot(voltage=1000))  #关键字参数\n#实例3\n#print(parrot(voltage=10000000,action='VOOOOOM'))#输出输入的值 1个位置参数，1个关键字参数\n#实例4\n#print(parrot(action='VOOOOOM',voltage=100000))#两个关键字参数\n#实例5\nprint(parrot('a million','bereft of left', 'jump'))#这三个数据填在parrot的前三个参数位，三个位置参数\n#实例6\nparrot('a thousand', state='pushing up the daisies')#将数据一次填入参数位（指定参数除外），1个位置参数，1个关键字参数\n```\n  + 输出\n```\n--this parrot wouldn't voomif you put 1000 volts though it.\n--lovely plumage , the  Norwegian Blue\nit's a stiff !\nNone\n--this parrot wouldn't voomif you put 1000 volts though it.\n--lovely plumage , the  Norwegian Blue\nit's a stiff !\nNone\n--this parrot wouldn't VOOOOOMif you put 10000000 volts though it.\n--lovely plumage , the  Norwegian Blue\nit's a stiff !\nNone\n--this parrot wouldn't VOOOOOMif you put 100000 volts though it.\n--lovely plumage , the  Norwegian Blue\nit's a stiff !\nNone\n--this parrot wouldn't jumpif you put a million volts though it.\n--lovely plumage , the  Norwegian Blue\nit's bereft of left !\nNone\n--this parrot wouldn't voomif you put a thousand volts though it.\n--lovely plumage , the  Norwegian Blue\nit's pushing up the daisies !\n```\n\n  + 无效的输入\n```\nparrot()                     # required argument missing\nparrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument\nparrot(110, voltage=220)     # duplicate value for the same argument\nparrot(actor='John Cleese')  # unknown keyword argument\n```\n#### 命名关键字参数\n  + 传入的关键字参数不受限制\n##### cheeseshop\n  + [def_cheeseshop](/download/Python/python-tutorial-notes/def_cheeseshop.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\n'''\n命名关键字参数\n'''\ndef cheeseshop(kind , *arguments , **keywords):#命名关键字参数使得关键字参数传入不受限制\n    print(\"--Do you have any \",kind , \"?\")\n    print(\"--i'm  sorry , we're all out of \",kind)\n    for arg in arguments : #*arguments为可变参数,可以输入多个参数\n        print(arg) #arg将多个参数分别提取出来\n    print(\"-\"*40)\n    for kw in keywords: # **keywords为关键字参数，需要keyword=value组合   \n        print(kw , \":\",keywords[kw]) #kw为关键字，keywords[]为值\n\nprint(cheeseshop(\"Limburger\",\"it's very runny,sir\",\"it's really very , very runny ,sir\",shopkeeper = \"michael Palin\",client = \"John Cleese\",shetch = \"Cheese Shop shetch\"))\n```\n  + 输出\n```\n--Do you have any  Limburger ?\n--i'm  sorry , we're all out of  Limburger\nit's very runny,sir\nit's really very , very runny ,sir\n----------------------------------------\nshetch : Cheese Shop shetch\nclient : John Cleese\nshopkeeper : michael Palin\nNone\n```\n\n#### 可变参数\n\n##### varied\n  + [def_varied](/download/Python/python-tutorial-notes/def_varied.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\n'''\n可变参数\n'''\ndef varied(*numbers): #可变参数,可以传入多个参数,*numbers相当于一个元组tuple\n    sum = 0\n    for n in numbers:\n        sum = sum + n*n\n    return sum\n\nprint(varied(1,3,4,5))\n```\n  + 输出\n```\n51  #可变参数能同时输入多个参数，组合成元组，进行运算\n```\n\n##### concat\n  + [concat](/download/Python/python-tutorial-notes/def_concat.py)\n```\n#!/usr/bin/env python3\n# coding=utf-8\ndef concat(*args,sep=\"/\"):#可变参数和默认参数\n    return sep.join(args)\n#实例\nprint(concat(\"earth\",\"mars\",\"venus\"))#只为可变参数赋值\nprint(concat(\"earth\",\"mars\",\"venus\",sep=\".\")) #可变参数和默认参数\n```\n  + 输出\n```\nearth/mars/venus\nearth.mars.venus\n```\n\n####  解出参数列表\n##### def_unpacking_range\n  + [def_unpacking_range](/download/Python/python-tutorial-notes/def_unpacking_range.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\n'''\n元组\n'''\na = list(range(3,6))\nprint(a) #用list函数将range(3,6)中的参数解压\n\nargs = [3,7]\nb = list(range(*args))\nprint(b) #用list函数将range中的可变参数解压\n```\n  + 输出\n```\n[3, 4, 5]\n[3, 4, 5, 6]\n```\n\n##### def_unpacking_parrot\n  + [def_unpacking_parrot](/download/Python/python-tutorial-notes/def_unpacking_parrot.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\n'''\n参数解压\n'''\n\ndef parrot(voltage,state='a stiff',action='voom'):\n    print(\"-- this parrot wouldn't\",action,end=' ')\n    print(\"if you put \",voltage,\"volts though it.\",end=' ')\n    print(\"E's \",state,\"!\")\nd = {\"voltage\":\"four million\",\"state\":\"bleedin' demised\",\"action\":\"VOOM\"}\nprint(parrot(**d)) #传递命名关键字参数，字典\n```\n  + 输出\n```\n-- this parrot wouldn't VOOM if you put  four million volts though it. E's  bleedin' demised !\nNone\n```\n\n#### 匿名函数\n  + [def_lambda_make](/download/Python/python-tutorial-notes/def_lambda_make.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\n'''\n匿名函数\n'''\ndef make(n):\n    return lambda x: x+n #匿名函数设置一个简单的参数，在式中进行简单计算\n#实例\nf=make(42) #这里的43为n值\n\nprint(f(39)) #这里的39是x值\n#lambda 用作函数\n#>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n#>>> pairs.sort(key=lambda pair: pair[1])\n#>>> pairs\n#[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]\n```\n  + 输出\n```\n81\n```\n\n#### 文档字符串\n  + 用作说明文档\n##### my_function\n  + [def_my_function](/download/Python/python-tutorial-notes/def_my_function.py)\n```\n#!/usr/bin/env python3\n# coding=utf-8\n'''\n文档字符串，用作说明文档\n'''\ndef my_function():\n    \"\"\"Do nothing , but document it.\n\n    No really , it doesn't do anything\n    \"\"\"\n    pass \n\n#实例\nprint(my_function.__doc__) #\"__\"需要两个杠\n```\n  + 输出\n```\nDo nothing , but document it.\n\n    No really , it doesn't do anything\n```\n\n#### 函数注释\n##### fn\n  + [fn](/download/Python/python-tutorial-notes/fn.py)\n```\n#!/usr/bin/env python\n# coding=utf-8\n'''\n函数注释\n'''\ndef fn(ham:str,eggs:str='eggs')->str:\n    print(\"annotations: \",fn.__annotations__)#函数注释所在的隐藏属性\n    print(\"arguments: \",ham,eggs) #函数参数输出\n    return ham+\"and\"+eggs\n#实例\nprint(fn('spam')) \n```\n  + 输出\n```\nannotations:  {'return': <class 'str'>, 'ham': <class 'str'>, 'eggs': <class 'str'>}\narguments:  spam eggs\nspamandeggs\n```\n","tags":["Python"],"categories":["python-tutorial-notes"]},{"title":"类","url":"%2F2019%2F05%2F03%2FPython%2Fpython-tutorial-notes%2Fchapter9_classes%2Fclasses%2F","content":"\n# classes 类\n\n## a word about names and objects 名称和对象\n+ 对象是私有的，多个名称能被绑定到相同的对象中\n\n这些名称也被称为别名，避免命名与关键字冲突\n这些类中的名称只能在类中使用，不能用在类外。\n名称能够忽视不变的基类型（strings,numbers,tuples）\n但是，用在可变化的对象中（lists,dictionaries,and most other types）会有一些语义冲突。\n名称的作用有时与指针有一些方面相似.\n\n## python scopes and namespaces python作用域和名字空间\n\n+ 名称空间是名称到对象的映射\n\n+ 名称空间的例子\n内建名称（包含函数和内建异常名称），在模块中的全局名称，函数调用的中本地名称，一个对象的属性集也可以看做名称空间\n\n+ 在不同名称空间中的名称是没有关联的\n例如，两个模块定义了相同的名称，但是两个模块中的名称作用域不同，是不相关联的。\n\n+ attribute(属性)\n具体表现是做为点（'.'）\nz.real   real是对象z的属性\nmoudlename.function moudlename是模块对象，function是模块对象的属性\n模块属性与模块中定义的全局变量都共享同样的名称空间\n属性可以是只读或者可写。可写的属性可以写入，也可以被删除（moudlename.function=42,del moudlename.function）\n\n+ 名称空间生存期\npython解释器开启时会创建包含内建名称的名字空间，并且永远不会被删除。\n模块中的全局名称空间在模块定义被读入时被创建，模块名字空间会持续存在，直到解释器退出\n由解释器的顶层调用执行的语句，无论是从脚本读入，还是交互式，都被认为是模块中\\_\\_main\\_\\_的一部分，它们有自己的全局名称空间（内建名称也是在模块中，被称为builtins）\n\n+ 作用域\n作用域是一个名称空间可以直接访问的文本区域\n\n+ 正在执行的程序，至少有三个嵌套的作用域，他们的名称空间是可以直接访问的。\n最内部的作用域（包含本地变量，第一个被搜索）\n从最近的封闭作用域开始搜索的任何封闭函数的作用域，包含非本地也包含非全局名称。\n下一个包含现在模块的全局名称的持续作用域\n最外围的作用域是是包含内建名称的名称空间\n\n如果一个名称被声明为全局的，那么所有的引用和赋值都会直接进入包含模块全局名称的中间范围。\n为了重新绑定在最内层范围之外发现的变量，可以使用nonlocal语句:如果不声明nonlocal，则这些变量是只读的(对这样一个变量进行写入的尝试只会在最内层的范围内创建一个新的局部变量，从而保持不变的外部变量不变)。\n\nglobal可以用来表示特定的变量在全局范围内，并且应该在那里进行重新绑定;\nnonlocal语句表示特定的变量存在于一个封闭的范围内并且应该在那里进行重新绑定\n\n### scopes and namespaces example 作用域和名字空间例子\n```\n#!/usr/bin/env python3\n# coding=utf-8\n\ndef scope_test():\n    def do_local():\n        spam = \"local spam\" #局部名称\n\n    def do_nonlocal():\n        nonlocal spam \n        spam = \"nonlocal spam\" #nonlocal名称\n\n    def do_global(): #nonlocal改变局部名称后，现在的局部名称为spam=\"nonlocal\"\n        global spam\n        spam = \"global spam\" #局部名称\n\n    spam = \"test spam\" #为全局名称\n    \n    do_local()\n    print(\"After local assignment:\",spam) #输出的是test spam，因为局部名称不能修改全局名称，所以输出的是全局名称的值\n    do_nonlocal()\n    print(\"After nonlocal assignment:\" , spam) #输出的是nonlocal spam,因为nonlocal可以改变spam绑定的名称\n    do_global()\n    print(\"After global assignment:\",spam)#输出的还是nonlocal，因为global绑定为全款名称，改变global定义的spam实际上为全局名称spam=\"test spam\"\n\nscope_test()\nprint(\"in global scope:\",spam) #输出的是global，因为全局名称绑定被global改变了，改变为global所在函数的spam\n```\n输出\n\n```\nAfter local assignment: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nin global scope: global spam\n```\n\n## a first look at classes\n\n### 类的形式\n```\nclass ClassName:\n    <statement-1>\n    ...\n    ...\n    ...\n    <statement-n>\n```\n\n### 类对象\n+ 类是一个属性和方法的集合\n\n例如，students是一个类，指的是学生这个集合\n\n+ 对象，也称为实例，是一个类的具体实现。类对象就是可以用类名直接表示的对象,支持两种操作属性引用(也称为类方法)和实例化\n\n例如，student是Student这个类的具体实现，一个群体中具体的某一个人。\n首先，定义一个类\n```\nclass Student:\n\tpass\n\nbart = Student() #这是一个实例，将Student看做一个函数。在其中有很多对象，它将返回一个对象，并赋值给bart，bart成为了一个实例，也就是对象。\n```\n\n#### 实例的属性和方法\n\n实例的属性也就是对象的变量，与c++需要中的prviate中的变量差不多，能被方法调用。\n实例的方法，实例绑定的函数，也称为公有接口，与c++中public中的公共接口类似。实例能够通过公共接口调用实例变量。但是不能直接修改实例变量。\t\n\n+ 属性引用\n标准语法为obj.name;在类被创建后有效的属性名称在类的名称空间中。\n\n+ 实例绑定属性\n\nbart是指向实例的，它就代表了实例本身，bart通过运算符'.'来引用属性。\n```\nclass Student(object):\n\tdef __init__(self,name,score):\n\t\tself.name = name    #为实例对象绑定属性\n\t\tself.score = score #self是代指对象本身，和上面的bart差不多。\n```\n+ 实例方法的使用\n\n需要实例化一个对象，将对象名赋值给self使用\n\n+ 类对象是一个模板，类实例是这个模板的具体体现，实例化将会创建一个对象，对象将会具有特定的初始状态\n```\n#!/usr/bin/env python\n# coding=utf-8\n\nclass MyClass:\n    \"\"\"\n    A simple example clss.\n    \"\"\"\n    i = 123456 #为类的属性\n\n    def f(self):#指代的是对象本身（类实例），代表当前对象地址，避免非限定调用造成的全局变量\n        return 'hello world'\n\n    #MyClass.i（返回整型）和MyClass.f（返回函数）都是有效的属性引用\n    #__doc__也是一个有效的属性，返回属于类的docstring：'A simple example clss.'\n\n\n    #类实例化使用函数表示法，假设类对象是一个没有参数的函数，它将返回一个新实例\n    #x = MyClass() #创建一个新实例，并将这个对象赋给局部变量x\n    def __init__(self):#self指代类对象\n        self.data = [] #这是类的实例化,将会创建一个空对象\n```\n+ 方法也可以有具有更大灵活性的参数，方法的参数将会被传递给类实例\n类当做函数时，类后面的参数则是类实例\n```\n#! /usr/bin/python3\n# coding=utf-8\nclass Complex:#类对象\n    def __init__(self,realpant , imagpart):\n        self.r = realpant   #绑定属性\n        self.i = imagpart #绑定属性\n#x为新的类实例\nx = Complex(3.0,-4.5) #这两个参数就是self.r,self.i这两个类实例，x为实例对象 \n#实际上这后面的参数是__init__方法中的参数，通过类实例传递给了x\nprint(x.r,x.i)\n```\n输出\n```\n3.0 -4.5\n```\n\n### 实例对象\n\n+ 类能实例化，对象也可以实例化，对象的实例化就是对象的属性引用\n```\n#接上面的类\n#对象实例化\nx.counter = 1  #对象实例的初始状态\nwhile x.counter < 10: #属性引用也可以称为方法，这是属于对象的方法\n    x.counter = x.counter * 2\nprint(x.counter)\ndel x.counter #删除\n```\n输出\n```\n3.0 -4.5\n16\n```\n\n### method objects 方法对象\n```\n#接上MyClass类\nx = MyClass() #从MyClass类中返回一个对象，赋给x,这里的x.f()其实是等效于Myclass.f\nxf = x.f      #x对象调用f方法，并赋给xf\nwhile True :\n    print(xf()) #xf现在就是x.f方法\n```\n\n### class and instance variables 类和实例的变量\n+ 类变量\n是所有对象共享的变量\n```\n#! /usr/bin/python3\n#-*-coding-*-\n\n'''\n类和实例变量\n'''\n\nclass Dog:\n    kind = 'canine'  #所有dog的种类，每一只dog共同拥有的属性\n    def __init__(self,name): #dog name,每条dog有不同的name\n        self.name = name    #为实例绑定属性\n\n\nd = Dog('Fido')  #创建一个实例，d是一条叫Fido的dog\ne = Dog('Buddly') #创建另一个实例，e是一条叫Buddly的dog\n\nprint('d is a ',d.kind) #调用的是类变量\nprint('e is a ',e.kind)\n\nprint('d is a ',d.name) #调用的是本实例的变量\nprint('e is a ',e.name)\n```\n输出\n```\nd is a  canine\ne is a  canine\nd is a  Fido\ne is a  Buddly\n```\n+ 将数据添加到类变量\n这会使数据在所有对象实例中共享\n```\n#! /usr/bin/python3\n#coding:utf-8\n\nclass Dog:\n    tricks = [] \n    def __init__(self,name):\n        self.name = name\n    def add_trick(self,trick):\n        self.tricks.append(trick)\n\n\nd = Dog('Fido')\ne = Dog('Buddly')\nd.add_trick('roll ever')\ne.add_trick('play dead')#e使用方法，增加trick到tricks\n\nprint(d.tricks)#tricks是一个类变量，被所有实例共享,所以每个实例向tricks增加内容都会被所有实例共享\n\nprint(Dog.tricks)\n#在这里Dog.tricks(所有对象共享的属性)与d.tricks(对象的属性)显示相同.\n```\n输出\n```\n['roll ever', 'play dead']\n['roll ever', 'play dead']\n```\n\n+ 实例变量\n各个对象实例所独有的变量，只能被所属实例调用\n\n```\n#! /usr/bin/python3\n#coding:utf-8\n\nclass Dog:\n    def __init__(self,name):\n        self.name = name\n        self.tricks = [] #给实例的属性绑定一个空列表\n\n    def add_trick(self,trick):\n        self.tricks.append(trick)\n\nd = Dog('Fido')\ne = Dog('Buddly')\n\nd.add_trick('roll ever')\ne.add_trick('play dead')\n\nprint(d.tricks)\nprint(e.tricks) #有对象属性\n#print(Dog.tricks)#Dog没有类属性tricks\n```\n输出\n```\n['roll ever']\n['play dead']\n```\n\n## random remarks\n\n+ 函数定义在类外面,在类定义中，函数包含在类中是不必要的\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n\n#函数定义在类外面\n\ndef fi(self,x,y):\n    return min(x,x+y)\nclass C:\n    f = fi\n\n    def g(self):\n        return 'hello world'\n    h = g \n```\n\n+ self参数也可以放在类的其他方法中\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n\nclass Bag:\n    def __init__(self):\n        self.data = []\n\n    def add(self,x):\n        self.data.append(x)\n\n    def addtwice(self,x):\n        self.add(x)\n        self.add(x)\n\n#实例\nd = Bag()\nd.add(7) #添加元素到列表\nd.add(8)\nprint(d.data) #输出列表\n```\n输出\n```\n[7, 8]\n```\n\n## inheritance 继承\n继承是子类继承父类的属性和方法\n+ 继承的形式\n```\nclass DeriveClassName(BaseCalssNmae): #括号中的为父类\n    <statement-1>\n    ...\n    ...\n    ...\n    <statement-n>\n#父类定义在其他模块\nclass DeriveClassName(moudlename.BaseClassNmae):\n```\n+ 继承的例子\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n'''\n类继承\n'''\n#父类动物\nclass Animal(object):\n    def run(self):\n        print('Animal is running......')\n\n\n#子类\nclass Dog(Animal):\n    pass\n\nclass Cat(Animal):\n    pass\n\ndog = Dog()\ndog.run()   #dog类继承了Animal类,可以直接使用Animal的属性和方法\ncat = Cat()\ncat.run()\n```\n输出\n```\nAnimal is running......\nAnimal is running......\n```\n+ 多态\n对继承的延伸，子类可以定义与父类相同的方法，子类的方法输出将会覆盖父类的方法输出\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n'''\n继承的多态\n'''\n\nclass Animal(object):\n    def run(self):\n        print('Animal is running......')\n\nclass Dog(Animal):\n    def run(self):\n        print('Dog is runing......')\n    def eat(self):\n        print('Dog eating meat......')\n\nclass Cat(Animal):\n    def run(self):\n        print('Cat running......')\n\n#现在输出的是子类定义的函数输出，也就是父类同名函数被覆盖了\ndog = Dog()\ncat = Cat()\n\ndog.run()\ndog.eat()\ncat.run()\n```\n输出\n```\nDog is runing......\nCat running......\n```\n+ 检查对象继承和判断实例类型\n\nisinstance(obj,int):检查实例的类型\nissubclass(bool,int):检查类继承,返回true false\n\n### multiple inheritance 多重继承\n+ 多重继承形式\n```\nclass DeriveClassName(Base1,Base2,Base3):\n    <statement-1>\n    ...\n    ...\n    ...\n    <statement-n>\n```\n\n+ 多重继承定义\n多重继承是动态语言的特色，一个子类能够同时继承多个父类的属性和方法\n\n## private variables 私有变量\n\n+ 私有变量与访问限制\n私有变量是只有内部可以访问，外部不能访问。\n+ 私有变量形式\n在普通变量之前加上两个下划线，如self.\\_\\_name，这就是私有变量\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n'''\n私有变量\n'''\n\nclass Mapping:\n    def __init__(self,iterable):\n        self.items_list = []  #相当于在函数中定义的变量\n        self.__update(iterable) #调用方法\n\n    def update(self,iterable):\n        for item in iterable:\n            self.items_list.append(item)\n\n    __update = update #将update方法的副本复制给私有变量\n\nclass MappingSubclass(Mapping): #子类\n    def update(self,keys,values):\n        for item in zip(keys,values): #将keys,values组装返回一个元组\n            self.items_list.append(item)\n```\n\n## 其他\n+ 类也有c语言中struct数据类型的作用\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n'''\n将类当做struct数据类型\n'''\nclass Emptyclass:\n    pass\n\njoin = Emptyclass()\n\njoin.name = 'john Doe'\njoin.dept = 'computer lab'\njoin.salary = '1000'\n\n#实例\n\nprint(join.name,\"\\n\",join.dept,\"\\n\",join.salary)\n```\n输出\n```\njohn Doe \n computer lab \n 1000\n```\n## 迭代器\n+ for语句用于迭代\n```\n+ 用for循环进行迭代\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n'''\n迭代器，用for进行迭代\n'''\n\nfor element in [1,2,3]: #list\n    print(element)\nfor element in (1,2,3): #tuple\n    print(element)\nfor key in {'one':1,'two':2}: #dictionary\n    print(key)\nfor char in \"123\": #string\n    print(char)\nfor line in open(\"myfile.txt\"):\n    print(line)\n```\n输出\n```\n1\n2\n3\n1\n2\n3\none\ntwo\n1\n2\n3\nthis is a txt .\n```\n+  for 语句调用iter()进行迭代\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n\ns = 'abc'\nit = iter(s) #用于迭代的内建函数\n\nprint(it)\nprint(next(it)) #next函数表示显示下一个迭代的值\nprint(next(it))\nprint(next(it))\nprint(next(it))\n```\n输出\n```\n<str_iterator object at 0x7ffbce6ae9e8>\na\nb\nc\nTraceback (most recent call last):\n  File \"class_iterator_next.py\", line 11, in <module>\n    print(next(it))\nStopIteration       #当迭代对象为空时，则返回错误,停止迭代\n```\n\n+ 定义一个iter()方法，返回\\_\\_next\\_\\_()方法\n\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n'''\n定义一个__iter__()方法，用__next__()方法返回一个对象\n'''\n\nclass Reverse:\n    def __init__(self,data):\n        self.data = data \n        self.index = len(data) #返回data长度\n    def __iter_(self):\n        return self        #\n    def __next__(self):\n        if self.index == 0: #数据长度为0则停止迭代\n            raise StopIteration #将引发异常\n        self.index = self.index - 1 #数据长度-1\n        return self.data[self.index] #返回第i个数据\n\nrev = Reverse(\"spam\")\nfor char in rev:\n    print(char)\n#不知为什么，不能迭代，输出错误\n```\n\n## generators 生成器\n\n+ 生成器是一个简单的用来创建迭代器的工具.与普通函数差不多，但是用yield返回.\n生成器自动创建\\_\\_iter()\\_\\_和\\_\\_next()\\_\\_方法，生成器实现的函数也可以用迭代器实现。\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n'''\n生成器，用yield返回\n'''\n\ndef reverse(data):\n    for index in range(len(data)-1,-1,-1): #从后面开始循环到开始\n        yield data[index]   #由于是列表，从0开始，需要-1\n\nfor char in reverse('golf'):\n    print(char)\n```\n输出\n```\nf\nl\no\ng\n```\n## generator expressions 生成器表达式\n\n+ 是一些简单的生成器被编码为表达式，它使用像列表生成式的语法，但是‘\"\\[\\]\"换为\"()\"\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n'''\n生成器生成式\n'''\n#求i的平方\na = sum(i*i for i in range(10))\nprint(a)\n\n#两个列表乘积\nxvec = [10,20,30]\nyvec = [7,6,4]\nb = sum(x*x for x,y in zip(xvec,yvec)) #用zip函数将两个列表组装成元组\nprint(b)\n\n#\nfrom math import pi,sin\nsine_table = {x:sin(x*pi/180) for x in range(0,91)}\nunique_words = set(word for line in page for word in line.split())\nvaiedictorian = max((student.gpa,student.name) for student in graduates)\ndata = 'golf'\nlist(data[i] for i in range(len(data)-1,-1,-1))\n```\n输出\n```\n285\n1400\nTraceback (most recent call last):\n  File \"class_generator_expression.py\", line 19, in <module>\n    unique_words = set(word for line in page for word in line.split())\nNameError: name 'page' is not defined\n\n```\n","tags":["Python"],"categories":["python-tutorial-notes"]},{"title":"官方教程未使用的python内容","url":"%2F2019%2F05%2F03%2FPython%2Fpython-tutorial-notes%2Fothers%2Fothers%2F","content":"\n# 官方教程未使用的python内容\n\n## map()和reduce()函数\n+ map()函数\n第一个参数是定义的运算规则，后面的序列是需要计算的元素\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n\ndef f(x):\n    return x*x\n\nr = map(f , [1,2,3,4,5,6,7,8]) #第一个参数是定义的运算规则，后面的序列是需要计算的元素\nprint(list(r))\n```\n输出\n```\n[1, 4, 9, 16, 25, 36, 49, 64]\n```\n\n+ reduce()函数\nreduce把一个函数作用在一个序列上，这个函数必须接收两个参数，把结果继续和序列的下一个元素做累积计算\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n\n'''\nreduce()函数作用在一个序列上，必需接收两个参数，把结果继续和序列的下一个元素进行计算。\nreduce(f,(x1,x2,x3,x4)) 效果相当于f(f(f(x1,x2),x3),x4)\n'''\n\nfrom functools import reduce\n\n#求和运算\ndef add(x,y):\n    return x+y\na = reduce(add,[1,3,5,7,9])\nprint('sum is : ',a)\n\n#复杂的运算\ndef fn(x,y):\n    return x*10+y\nb = reduce(fn,[1,3,5,7,9])\nprint('sum2 is : ',b)\n\n#字符串\ndef fn(x,y):\n    return x*10+y\n\ndef char2num(s):\n    return {'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9}[s]\nc = reduce(fn,map(char2num,'13579')) #map将字典中的关键字与输入的匹配，输出键值，并将键值用自定的函数规则运算\nprint('char is : ',c)\n\n#用lambda匿名函数进行简化\ndef char2num(s):\n    return {'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9}[s]\ndef str2int(s):\n    return reduce(lambda x,y: x*10+y,map(char2num,s))\nprint('str is : ',str2int('123456'))\n```\n输出\n```\nsum is :  25\nsum2 is :  13579\nchar is :  13579\nstr is :  123456\n```\n\n## filter\n+ filter函数用于过滤序列\n与map类似,filter也接收一个函数和一个序列，但是把传入的函数依次作用于每个元素,根据返回true/false判断保留或者丢弃该元素\n\n```\n#!/usr/bin/env python\n# -*-coding=utf-8-*-\n'''\nfilter函数与函数map类似，需要传入两个参数，传入函数依次作用在序列上\n'''\n#删掉偶数，只保留奇数\ndef is_odd(n):\n    return n%2==1\na = list(filter(is_odd,[1,2,3,4,5,6,7,8,9,10]))\nprint(a)\n\n#删除字符串中的空格\ndef not_empty(s):\n    return s and s.strip() #删除空格用strip()\nb = list(filter(not_empty,['A','B','C',None,'D']))\nprint(b)\n\n#用filter求素数\ndef _odd_iter(): #私有函数\n    n=1\n    while True:\n       n=n+2\n       yield n\ndef _not_divisible(n): #筛选函数\n    return lambda x: x%n>0\ndef primes():\n    yield 2  #首先生成第一个素数２\n    it=_odd_iter() #初始化序列\n    while True:\n        n = next(it)　#返回序列第一个数\n        yield n\n        it = filter(_not_divisible(n),it)#构造新序列\nfor n in primes():\n    if n < 1000:\n        print(n)\n    else:\n        break\n```\n\n+ sorted 排序算法\n\n","tags":["Python"],"categories":["python-tutorial-notes"]},{"title":"数据结构","url":"%2F2019%2F05%2F03%2FPython%2Fpython-tutorial-notes%2Fchapter5_data_structures%2Fdata-structures%2F","content":"\n\n### 数据结构\n\n\n#### 列表\n  + functions on lists \n{% codeblock lang:python %}\nlist.append(x) #向列表末尾添加元素,a【len(a):】=【x】\nlist.extend(itrable) #使用一个序列扩展另一个序列，序列中的元素将添加到列表尾部a【len(a):】=itrable\nlist.insert(i,x) #将x插入第i个位置\nlist.remove(x) #删除x\nlist.pop(【i】) #将第i个位置的数据退栈\nlist.clear() #del a【:】\nlist.index(x【,start盘【,end】】) #查找索引\nlist.count(x) #返回x在列表中所在位置\nlist.sort(key=none,reverse=false)#参数是用来自定义排序\nlist.reverse() #将列表中元素颠倒\nlist.copy() #复制列表\n{% endcodeblock %}\n  + [list_example](/download/Python/python-tutorial-notes/chapter5/list_example.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\nfruits = ['orange','apple','pear','banana','kiwi','apple', 'banana']\n#fruits.count('apple')\n#fruits.count('tangerine')\n#fruits.index('banana')\n#fruits.index('banana',4) #从第4个位置开始查找banana\n#fruits.pop() #显示退栈数据，退栈是从列表尾部开始\n\n#实例\nprint(fruits.count('apple'))\nprint(fruits.count('tangerine'))\nprint(fruits.index('banana'))\nprint(fruits.index('banana',4))\nfruits.reverse() #颠倒顺序\nprint(fruits)\nfruits.append('grape') #在列表末尾添加元素\nprint(fruits)\nfruits.sort() #排序\nprint(fruits)\nprint(fruits.pop())\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\n2\n0\n3\n6\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\npear\n{% endcodeblock %}\n\n##### 用于栈\n  + [list_stack](/download/Python/python-tutorial-notes/chapter5/list_stack.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n'''\n栈在列表中的应用\n'''\nstack = [3,4,5]\n#在列表末尾插入元素\nstack.append(6)\nprint(stack)\nstack.append(7)\nprint(stack)\n#显示弹出栈的元素\nstack.pop()\nstack.pop()\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\n[3, 4, 5, 6]\n[3, 4, 5, 6, 7]\n{% endcodeblock %}\n\n#### 列表用于队列\n##### queue\n  + [list_queue](/download/Python/python-tutorial-notes/chapter5/list_queue.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n\nfrom collections import deque   #被设计来从末尾更快速的append and pop元素\nqueue = deque([\"Eric\",\"Join\",\"Michae\"])\n#从末尾增加元素\nqueue.append(\"Terry\")\nprint(queue)\nqueue.append(\"Graham\")\nprint(queue)\n#从队列左边退出队列\nqueue.popleft() \nprint(queue)\nqueue.popleft()\nprint(queue)\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\ndeque(['Eric', 'Join', 'Michae', 'Terry'])\ndeque(['Eric', 'Join', 'Michae', 'Terry', 'Graham'])\ndeque(['Join', 'Michae', 'Terry', 'Graham'])\ndeque(['Michae', 'Terry', 'Graham'])\n{% endcodeblock %}\n\n#### 列表推导式(列表生成式)\n\n##### list-comprehensions\n  + [list_comprehensions](/download/Python/python-tutorial-notes/chapter5/list_comprehensions.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n'''\n列表生成式\n'''\n#example1\nsquares = [] #构建一个空队列\nfor x in range(10):\n    squares.append(x**2)#将构建的列表中的元素用x解出再**运算\n#实例\nprint(squares)\n\n#example2\nsquares = list(map(lambda x:x*2,range(10))) #实际上结果和上面的一样\nprint(squares)\n\n#example3\nsquares = [x**2 for x in range(10)]#第三种表达形式\nprint(squares)\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n{% endcodeblock %}\n\n##### list-comprehensions1\n  + [list_comprehensions1](/download/Python/python-tutorial-notes/chapter5/list_comprehensions1.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n#example1\na = [(x,y) for x in [1,2,3] for y in [3,1,4] if x!=y] \nprint(a) #生成以元组为子集的列表\n\n#example2\n\ncombs = [] #构建空列表\n\nfor x in [1,2,3]:\n    for y in [3,1,4]:\n        if x!=y:\n           combs.append((x,y))\n\nprint(combs)\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\n{% endcodeblock %}\n##### list-comprehensions2\n  + [list_comprehensions2](/download/Python/python-tutorial-notes/chapter5/list_comprehensions2.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\nvec = [-4,-2,0,2,4]\n#创建新的列表，值加倍递增\na = [x*2 for x in vec]\nprint(a)\n\n#过滤列表中的负数\nb = [x for x in vec if x >= 0]\nprint(b)\n\n#对所有元素应用abs()函数\nc = [abs(x) for x in vec]\nprint(c)\n\n#在每个元素中调用方法\nfreshfruit = ['banana','loganberry','passion fruit']\nd = [weapon.strip() for weapon in freshfruit]\nprint(d)\n#创建一个有两个参数的二元组\ne = [(x , x**2) for x in range(6)]\nprint(e)\n#用两个for循环将双重列表转转为列表\nvec = [[1,2,3],[4,5,6],[7,8,9]]\nf = [num for elem in vec for num in elem] #用elem将vec列表中的各个子集提取出来，用num将各个子集中的元素提取出来\nprint(f)\n\n#包含合成生成式和嵌套函数的列表生成式\nfrom math import pi #求圆周率\ng = [str(round(pi,i)) for i in range(1,6)] \nprint(g) #得出来的pi为字符串\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\n[-8, -4, 0, 4, 8]\n[0, 2, 4]\n[4, 2, 0, 2, 4]\n['banana', 'loganberry', 'passion fruit']\n[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n['3.1', '3.14', '3.142', '3.1416', '3.14159']\n{% endcodeblock %}\n\n##### 嵌套列表生成式\n  + [list_nexted_comprehensions](/download/Python/python-tutorial-notes/chapter5/list_nexted_comprehensions.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n'''\n嵌套列表生成式\n'''\nmatrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12],] #每个子集后面要加逗号\na = [[row[i] for row in matrix] for i in range(4)]\nprint(a)\n\n#等价于\ntransposed = []\nfor i in range(4):\n    transposed.append([row[i] for row in matrix])\nprint(transposed)\n\n#等价于\ntransposed = [] #初始化\nfor i in range(4):\n    transposed_row=[]  \n    for row in matrix: #行初始化\n        transposed_row.append(row[i])#往列表第row个元素的第i个位置增加元素\n    transposed.append(transposed_row) #往列表的第i个位置增加元素\nprint(transposed)\n\n#相似\ne = list(zip(*matrix))\nprint(e)\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]\n{% endcodeblock %}\n#### del语句\n  + [del_example](/download/Python/python-tutorial-notes/chapter5/del_example.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n'''\n删除语句\n'''\na = [-1,0,1,2,3,4,77,99,3444]\nprint(a)\n\ndel a[0]\nprint(a)\n\n#切片删除\ndel a[2:4]\nprint(a)\n\n#全部删除\ndel a[:]\nprint(a)\n\n#删除全部变量\ndel a #输出错误，因为变量已经被删除\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\n[-1, 0, 1, 2, 3, 4, 77, 99, 3444]\n[0, 1, 2, 3, 4, 77, 99, 3444]\n[0, 1, 4, 77, 99, 3444]\n[]\n{% endcodeblock %}\n\n#### 元组与序列\n  + [tuple_example](/download/Python/python-tutorial-notes/chapter5/tuple_example.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n'''\n元组与序列\n'''\nprint(\"example\")\nt = 12345,54321,'hello' #元组可以只用逗号分开，不需要括号\nprint(t[0])\nprint(t)\n\n#元组嵌套\nu = t,(1,2,3,4,5)\nprint(u)#嵌套后的元组成为有两个子集元组的大元组\n\n#元组值不可变,t[0]=9999(元组重置元素是不可行的，会报错)\n#元组可以包含可变的参数,如列表\nv = ([1,2,3],[3,2,1])\nprint(v)\n\n\nprint(\"example2\")\nempty = ()\nsing = 'woow'\nsingleton = 'hello', #后面多加一个逗号表示元组\nprint(len(empty)) #显示empty长度\nprint(len(sing)) #显示sing长度\nprint(len(singleton))#显示singleton长度\nprint(empty)\nprint(sing)\nprint(singleton)\n\n#在解释器中，如果，t = 1,2,3 ，可以颠倒，1,2,3=t\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\nexample\n12345\n(12345, 54321, 'hello')\n((12345, 54321, 'hello'), (1, 2, 3, 4, 5))\n([1, 2, 3], [3, 2, 1])\nexample2\n0\n4\n1\n()\nwoow\n('hello',)\n{% endcodeblock %}\n\n#### sets\n  + [set_example](/download/Python/python-tutorial-notes/chapter5/set_example.py)\n    用花括号或者set()函数创建sets（创建空的sets需要用set()函数）\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n'''\nsets集合\n'''\n\nbasket = {'apple','orange','apple','pear','orange','banana'} #用{}创建sets\nprint(basket)#不重复输出元素\n\n#判断sets中的value是否在字典中\na = 'orange' in basket\nprint(a)\nb = 'cranfg' in basket\nprint(b)\n\n#对两个单词的操作\na = set('abracadabra')\nb = set('alacazam')\nprint(a) #不重复输出a中的字母\nc = a - b #相减\nprint(c)\nd = a | b #或\nprint(d)\ne= a ^ b #取反\nprint(e)\nf = a & b #取并集\nprint(f)\n\n#用列表生成式\ng = {x for x in 'abracadabra' if x not in 'abc'} #输出不在abc范围中的字符串中的字母\nprint(g)\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\n{'apple', 'pear', 'banana', 'orange'}\nTrue\nFalse\n{'d', 'r', 'c', 'a', 'b'}\n{'d', 'r', 'b'}\n{'d', 'c', 'z', 'r', 'b', 'l', 'm', 'a'}\n{'d', 'z', 'r', 'b', 'l', 'm'}\n{'c', 'a'}\n{'d', 'r'}\n{% endcodeblock %}\n\n#### 字典\n  + [dict_example](/download/Python/python-tutorial-notes/chapter5/dict_example.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n'''\n字典\n'''\n#字典与集合一样需要用花括号\ntel = {'jack':4098,'sape':4139}\nprint(tel)\ntel['guido'] = 4127 #通过关键字添加元素\nprint(tel)\n\ndel tel['sape'] #通过关键字删除元素\nprint(tel)\n\ntel['irv'] = 4098 #添加键值与字典中键值相同的元素\nprint(tel)\n\na = list(tel.keys())#列出字典中的关键字\nprint(a)\n\nb = sorted(tel.keys())#将字典按关键字排序\nprint(b)\n\n#两个相同键值的元素，只能识别一个\nc = 'jack' in tel\nd = 'irc' in tel  \ne = 'guido' in tel\nprint(c)\nprint(d)\nprint(e)\n\n#用dict()函数构建字典\nf = dict([('sape',4139),('guido',4127),('jack',4098)])\nprint(f)\n\n#用于字典的生成式\ng = {x: x**2 for x in (2,4,6)} #关键字为（2,4,6），键值为x**2 \nprint(g)\n\nh = {x: x**2 for x in [2,4,6]} \nprint(h)\n\n#用关键字参数\ni = dict(sape=4139,guido=4127,jack=4089)\nprint(i)\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\n{'jack': 4098, 'sape': 4139}\n{'jack': 4098, 'guido': 4127, 'sape': 4139}\n{'jack': 4098, 'guido': 4127}\n{'jack': 4098, 'guido': 4127, 'irv': 4098}\n['jack', 'guido', 'irv']\n['guido', 'irv', 'jack']\nTrue\nFalse\nTrue\n{'jack': 4098, 'guido': 4127, 'sape': 4139}\n{2: 4, 4: 16, 6: 36}\n{2: 4, 4: 16, 6: 36}\n{'jack': 4089, 'guido': 4127, 'sape': 4139}\n{% endcodeblock %}\n\n## 循环技术\n  + looping through dictionaries \n  + looping through sequence\n  + loop over more sequence\n  + loop over a sequence in reverse\n  + loop over a sequence in sorted order\n  + loop create a list\n\n  + [loop_dict](/download/Python/python-tutorial-notes/chapter5/loop_dict.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n'''\n用字典循环\n'''\n#looping through dictionaries \nprint(\"looping through dictionaries:\\n\")\nknights = {'gallahad':'the pure','robin':'the brave'}\nfor k,v in knights.items(): #items()用作显示字典键值\n    print(k,v)\n\n#looping through sequence\nprint(\"looping through sequence:\\n\")\nfor i,n in enumerate(['tic','tac','toe']): #enumerate()函数在字典上是枚举、列举的意思\n    print(i,n)\n\n#loop over more sequence\nprint(\"loop over more sequence:\\n\")\nquestions = ['name','quest','favorite color']\nanswers = ['lancelot','the holy grail','blue']\nfor q,a in zip(questions,answers): #zip函数接受任意多个序列做为参数，返回一个元组列表\n    print('what is your{0}? it is {1}.'.format(q,a))#format格式化函数用{},:代替传统%\n\n#loop over a sequence in reverse\nprint(\"to loop over a sequence in reverse:\\n\")\nfor i in reversed(range(1,10,2)):#颠倒顺序\n    print(i)\n\n#loop over a sequence in sorted order\nprint(\"loop over a sequence in sorted order\\n\")\nbasket = ['apple','orange','apple','pear','orange','banana']\nfor f in sorted(set(basket)):#按照集合排序(用字母顺序排序),set输出不能重复\n    print(f)\n\n#loop create a list\nprint(\"loop create a list :\\n\")\nimport math  #导入数学公式\nraw_data = [56.2,float('NaN'),51.7,55.3,52.5,float('NaN'),47.8]\nfiltered_data = [] #创建一个空列表\nfor value in raw_data:\n    if not math.isnan(value): #nan is not a number，这一句表示输出是number的\n        filtered_data.append(value)\nprint(filtered_data)\n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\nlooping through dictionaries:\n\nrobin the brave\ngallahad the pure\nlooping through sequence:\n\n0 tic\n1 tac\n2 toe\nloop over more sequence:\n\nwhat is yourname? it is lancelot.\nwhat is yourquest? it is the holy grail.\nwhat is yourfavorite color? it is blue.\nto loop over a sequence in reverse:\n\n9\n7\n5\n3\n1\nloop over a sequence in sorted order\n\napple\nbanana\norange\npear\nloop create a list :\n\n[56.2, 51.7, 55.3, 52.5, 47.8]\n{% endcodeblock %}\n\n#### 更多的条件语句\n  + 用在while if语句中\n##### 比较类型\n  + in and not in 检查一个值是否在序列中\n  + is and is not 比较 =两个对象是否相同\n  + a小于b连等于c 几个比较可以被链接\n  + (A  and (not B)) or C 几个比较可以用布尔操作符联合\n\n\n  + [comparison_example](/download/Python/python-tutorial-notes/chapter5/comparison_example.py)\n{% codeblock lang:python %}\n#!/usr/bin/env python\n# coding=utf-8\n'''\n将比较的结果分配给变量\n'''\nstring1,string2,string3='','Trondheim','Hammer Dance' #三个变量分别赋值\nnon_null = string1 or string2 or string3 #比较三个变量中的数据，并赋值给另一个变量\nprint(non_null) \n{% endcodeblock %}\n  + 输出\n{% codeblock lang:python %}\nTrondheim\n{% endcodeblock %}\n\n#### 序列与其他类型的比较\n{% codeblock lang:python %}\n(1, 2, 3)              < (1, 2, 4)\n[1, 2, 3]              < [1, 2, 4]\n'ABC' < 'C' < 'Pascal' < 'Python'\n(1, 2, 3, 4)           < (1, 2, 4)\n(1, 2)                 < (1, 2, -1)\n(1, 2, 3)             == (1.0, 2.0, 3.0)\n(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)\n{% endcodeblock %}\n","tags":["Python"],"categories":["python-tutorial-notes"]},{"title":"python的虚拟环境和包","url":"%2F2019%2F05%2F03%2FPython%2Fpython-tutorial-notes%2Fchapter12_virtual_environments_and_packages%2Fvirtual_environments_and_packages%2F","content":"\n\n\n# virtual environments and packages 虚拟环境和包\n\n## introduction 介绍\n\npython程序经常使用没有包含在标准库中的包和模块,程序有时需要特定版本的库，因此有些程序需要的版本不同，这将会产生版本冲突。\n解决办法：创建一个虚拟环境，一个自己的目录树容器，包含一个python程序安装需要的详细的python版本以及附加的包.\n不同的程序需要用不同的虚拟环境，用来解决冲突。\n\n\n## creating virtual environments 创建虚拟环境\nvenv模块是用来创建和管理虚拟环境的，通常将会安装大多数你需要的最近的python版本。如果在你的系统有许多python版本，你能选择一个特定的你想要运行的python版本。\n创建一个虚拟环境，选择自己要放置的目录，并且用带有目录路径的脚本运行venv模块：\n```\npython3 -m venv tutorial-env #如果目录不存在，将会创建一个tutorial-env，也能在其中创建目录，其中包含python解释器的副本，标准库和各种支持文件。\n```\n创建好有个虚拟环境后，需要激活它。\n在windows上，运行：\n```\ntutorial-env\\Scripts\\active.bat\n```\n在linux/Unix上，运行：\n```\nsource tutorial-env/bin/active\n```\n改变虚拟环境:\n```\n$ source ~/envs/tutorial-env/bin/activate\n(tutorial-env) $ python\nPython 3.5.1 (default, May  6 2016, 10:59:36)\n  ...\n>>> import sys\n>>> sys.path\n['', '/usr/local/lib/python35.zip', ...,\n'~/envs/tutorial-env/lib/python3.5/site-packages']\n```\n\n## managing packages with pip 用pip包管理器\n\n```\npip search astronomy #搜索python包\npip install packages #安装包\npip install requests=2.6.0 #安装指定版本包\npip install --upgrade requests #更新包版本\npip show requests  #显示包信息\npip list #显示所有的安装在虚拟环境中的包\npip freeze > requests.txt 　#将会产生一个被安装包的列表，但是使用pip期望的格式输出\npip install -r requests.txt requests.txt将会提交到版本控制，并作为程序的一部分，用户能够用-r安装所有需要的包\n```\n","tags":["Python"],"categories":["python-tutorial-notes"]},{"title":"学习Git-大乘","url":"%2F2019%2F05%2F01%2FGit%2F%E5%AD%A6%E4%B9%A0Git%2F%E5%AD%A6%E4%B9%A0Git-%E5%A4%A7%E4%B9%98%2F"},{"title":"学习Git-合体","url":"%2F2019%2F05%2F01%2FGit%2F%E5%AD%A6%E4%B9%A0Git%2F%E5%AD%A6%E4%B9%A0Git-%E5%90%88%E4%BD%93%2F"},{"title":"学习Git-化神","url":"%2F2019%2F05%2F01%2FGit%2F%E5%AD%A6%E4%B9%A0Git%2F%E5%AD%A6%E4%B9%A0Git-%E5%8C%96%E7%A5%9E%2F"},{"title":"学习Git-元婴","url":"%2F2019%2F05%2F01%2FGit%2F%E5%AD%A6%E4%B9%A0Git%2F%E5%AD%A6%E4%B9%A0Git-%E5%85%83%E5%A9%B4%2F"},{"title":"学习Git-金丹","url":"%2F2019%2F05%2F01%2FGit%2F%E5%AD%A6%E4%B9%A0Git%2F%E5%AD%A6%E4%B9%A0Git-%E9%87%91%E4%B8%B9%2F","content":"\n### 分支\n\n#### 什么是分支?  \n在git中，分支是指向单个commit(提交)的一个指针。git项目中，有个默认主分支master和其他的develop分支。master分支表示这个项目的稳定发布版本，而develop则是这个项目的贡献者们提交给项目的未发布的开发者版本。只有被认可后，develop中的分支可以合并到主分支master中，成为项目需要发布的一部分。到最终项目发布，需要的就是主分支master中的代码。\n#### 为什么在git中使用分支\ngit中的分支实际上仅是一个包含所指向对象校验和的文件，创建和撤销非常廉价。\n#### 理解分支  \n  + 首先，假设在工作目录中有三个文件，我们需要将其暂存提交  \n  {% codeblock %}\n  git add README test.rb LICENSE2\n  git commit -m 'initial commit of my project'\n  {% endcodeblock %}\n\n一次提交后仓库里的数据如下图所示：  \n![一次提交后仓库里的数据](一次提交后仓库里的数据.png)\n两次提交后，仓库历史会变成如图所示：\n![多次提交后的 Git 对象数据](多次提交后的Git对象数据.png)\nGit中的分支，其实是指向commit对象的可变指针，git会使用master作为分支的默认名字，每次提交，master分支指针都会自动指向最新的提交对象。\n![指向提交数据历史的分支]](指向提交数据历史的分支.png)\n\n  + 其次，创建分支\n    git保存有一个名为HEAD的指针，它是指向你正在工作中的本地分支\n  {% codeblock %}\n  git branch testing　#创建一个分支\n  git checkout testing #进入创建的这个分支中工作，使其成为工作目录，指针HEAD则指向当前这个分支\n  #在test.rb分支中修改\n  vim test.rb \n  git commit -a -m 'made a change' #此时，分支testing向前移动，而master分支仍然指向原来的commit对象\n  git checkout master #回到master分支，工作目录成为master,HEAD指针从新指向master分支\n  #在master分支中修改\n  vim test.rb\n  git commit -a -m 'made a change' #此时，分支master向前移动，指针HEAD指向当前这个分支\n  {% endcodeblock %}\n  + 然后，分支合并\n    创建分支都是为了主分支不被干扰，重启一个模块，测试成功后放入主分支中，成为主分支的一部分\n\n\n{% codeblock %}\ngit checkout master #切换到主分支\ngit merge testing  #将testing分支合并到主分支，此时，master分支和testing分支指向同一位置\n#这时，完成了对主分支的更新\ngit branch -d testing #testing分支这时已经没有用，可以删除掉了\n{% endcodeblock  %}\n\n#### 管理分支\n\n\n{% codeblock  %}\ngit branch #给出所有分支清单\ngit branch -v #查看各分支最后一次commit的情况\ngit branch --merged #筛选出已经合并的分支 已被并入的分支可以直接删除\ngit branch --no-merged #查看未合并的分支 删除分支会导致失败(可以使用git branch -D强制删除)\n{% endcodeblock  %}\n\n#### 分支式工作流程\n##### 长期分支\n可以创建多个等级的分支，每个等级的分支有不同的工作。这可以想象成流水线工作。\n![流水线](流水线.png)\n比如，最高等级是master，作为主干分支，是最稳定的发布版本，也是最老旧的版本，它作为项目发布的分支。\n第二等级是develop等级的分支，所有开发者的分支都合并到这个分支，作为测试分支，如果测试通过则合并到master分支中。\n下一个等级的则是建议更新，它包含还没有成熟到可以进入master分支的内容，当其中的内容已经开发完成，只需要放入develop中进行测试，测试成功则进入master中。\n##### 特性分支\n一个特性是指一个短期的，用来实现单一特性或者与其相关工作的分支。你可以把做出的改变保持在特性分支中几分钟，几天，等他们成熟后再合并。\n##### 远程分支\n远程分支是对远程仓库的索引。远程分支就像书签，提醒你上次连接远程仓库时上面各分支的位置。\n在本地工作的同时有人向远程仓库推送内容让提交历史发生分歧，我们可以运用*git fetch origin*来进行同步，将指针移动远程仓库中新的位置。\n\n{% codeblock  %}\ngit remote add origin http://xxxxxx #将远程仓库加入本地仓库，并命名别名\ngit fetch origin #将远程仓库与本地同步\n{% endcodeblock  %}\n  + 推送  \n    如果要想和其他人分享某个分支(test)\n\n\n\n{% codeblock  %}\ngit push origin test #将本地的分支推送到远程仓库origin中，与人分享分支而一起开发\ngit push origin test:test #也可以取出我的test本地分支推送到远程的test分支\ngit push origin test:master #也可以取出我的test本地分支推送到远程的master分支\n#协作者从服务器上获取数据时，会得到新的一个test分支,但是自己无法编辑与开发\ngit fetch origin\ngit merge origin/test #这样才能将别人的分支合并到自己的当前分支\ngit checkout -b test origin/test　#如果自己想要修改这个分支，可以自己在远程分支的基础上分化出一个新的test分支来开发，这回切换到新建的本地test分支（称为跟踪分支），与远程内容同步，你可以继续开发\n{% endcodeblock  %}\n  + 跟踪分支\n    从远程分支检出的本地分支，称为跟踪分支，跟踪分支是一种和远程分支有直接联系的本地分支。\n  + 删除远程分支  \n\n\n\n{% codeblock  %}\ngit push origin :test #直接删除远程分支,在这里提取空白然后把它直接变成远程分支\n{% endcodeblock  %}\n\n#### 衍合\n把一个分支整合到另一个分支的方法有*merge(合并)*和*rebase(衍合)*。\nrebase可以把在一个分支里提交的改变在另一个分支里重放一遍。rebase能产生一个更为整洁的提交历史  \n{% codeblock  %}\ngit checkout test #检出到test中\ngit rebase master #让test与master衍合，回到两个分支的共同祖先，提取所在分支每次提交时产生的差异，把差异分别保存到临时文件里，然后从当前分支转换到你需要衍合入的分支，依序使用每一个差异补丁文件\ngit rebase --onto master server client #检出client分支，找出client分支和server分支的共同祖先之后的变化，然后把他们在master重演一遍。\n#与下面的过程表示的意思一样\ngit checkout master #检出到master\ngit merge client #将client合并\ngit rebase master server #将server衍合\ngit checkout master #检出到master\ngit merge server #将server合并\n{% endcodeblock  %}\n  + 注意\n    永远不要衍合那些已经推送到公共仓库的更新\n","categories":["学习Git笔记"]},{"title":"学习Git-筑基","url":"%2F2019%2F05%2F01%2FGit%2F%E5%AD%A6%E4%B9%A0Git%2F%E5%AD%A6%E4%B9%A0Git-%E7%AD%91%E5%9F%BA%2F","content":"\n### 基础\n#### 创建git项目\n{% codeblock %}\ngit init  #初始化git项目仓库,创建git数据库\ngit add . #跟踪新文件，将文件存入暂存区\ngit status #检查文件状态\nvim .gitigore\n\\*~ #忽略所有~结尾的文件\nbuild/　#忽略所有build目录中的文件\ngit commit -m \"change\" #将更改提交\n{% endcodeblock %}\n#### git基本命令\n  + git diff \n  {% codeblock %}\n  git diff #查看尚未暂存的文件更新了那些,比较工作目录中当前文件和暂存区快照之间的差异\n  git diff --cached #查看暂存的文件更新，查看暂存的文件和上次提交时的快照之间的差异\n  git diff --staged #与上面那个相同\n  {% endcodeblock %}\n  + git rm \n{% codeblock %}\ngit rm test.c #从版本管理中移除\ngit rm -f test.c #强制移除\ngit rm --cached test.c #从暂存区中移除\n{% endcodeblock %}\n  + git mv\n{% codeblock %}\ngit mv test.c tes1.c #相当于运行了mv test.c tes1.c ; git rm test,c ; git add tes1.c\n{% endcodeblock %}\n  + git commit\n{% codeblock %}\ngit commit -m \"change\" # -m 后面跟提交说明\ngit commit -a -m \"change\" #跳过暂存自动把所有已经跟踪的文件暂存起并提交，不需要git add\ngit commit --amend #重新提交，使用当前的暂存区域快照提交，最终只有一个提交\n{% endcodeblock %}\n  + git log\n{% codeblock %}\n  git log #按提交时间列出所有更新\n  git log -2 -p #-p展开显示每次提交的内容差异　-2表示显示最近两次\n  git log --stat #仅显示简要的增改行数统计\n  git log --pretty=oneline #--pretty指定使用完全不同于默认格式的方式展示提交历史　oneline将每个提交放在一行显示　\n  git log --pretty=format:\"%h - %an, %ar : %s\" #使用一定格式显示\n  git log --pretty=format:\"%h %s\" --graph #--graph查看简单图形\n  git log --since=2.weeks 按照时间作限制\n{% endcodeblock %}\n  + git reset\n{% codeblock %}\ngit reset HEAD test.c #取消test.c的暂存\n{% endcodeblock %}\n  + 取消对文件的修改\n    git checkout -- test.c *会取消你所有的更改*\n  + git remote #远程仓库的使用\n{% codeblock %}\ngit remote #查看所有远程仓库的名字\ngit remote -v(verbose) #显示仓库对应的克隆地址\ngit remote add vim-set https://github.com/rack-leen/vim #将远程仓库地址添加到git中\ngit remote show vim-set #查看vim-set中的详细信息\ngit remote rename vim-set vim #将仓库名重命令\ngit remote rm vim #删除仓库地址\n{% endcodeblock %}\n\n  + git fetch\n{% codeblock %}\ngit fetch vim-set #将远程仓库中的内容抓取下来\n{% endcodeblock %}\n  + git push\n{% codeblock %}\ngit push vim-set master #将本地分支master推送到origin服务器上\n{% endcodeblock %}\n\n  + git tag\n{% codeblock %}\ngit tag #按字母顺序显示标签\ngit tag -1 1.2.\\* #只显示1.2版本的标签\ngit tag -a v1.4 -m \"my version 1.4\" #-m 创建一个含附注的标签 -a指定标签名\ngit tag show #显示标签信息\ngit tag -s v1.6 -m 'my version 1.6' #用gpg签署标签\ngit tag v1.5-1 #创建一个轻量级的标签\ngit tag -v v1.5 #验证标签\ngit tag -a v1.6 6asdsg #在打标签的时候跟上对应提交对象的校验和\ngit push vim v1.5 #分享标签\ngit push vim --tag #推送所有标签\n{% endcodeblock %}\n","tags":["Git"],"categories":["学习Git笔记"]},{"title":"学习Git-初识","url":"%2F2019%2F05%2F01%2FGit%2F%E5%AD%A6%E4%B9%A0Git%2F%E5%AD%A6%E4%B9%A0Git-%E5%88%9D%E8%AF%86%2F","content":"\n### 初识\n\n#### 什么是Git?\n\n","tags":["Git"],"categories":["学习Git笔记"]},{"title":"学习C语言-数据类型解析","url":"%2F2019%2F04%2F27%2FC%2F%E5%AD%A6%E4%B9%A0C%E8%AF%AD%E8%A8%80%2F%E5%AD%A6%E4%B9%A0C%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90%2F"},{"title":"学习C语言-变量的三个属性","url":"%2F2019%2F04%2F27%2FC%2F%E5%AD%A6%E4%B9%A0C%E8%AF%AD%E8%A8%80%2F%E5%AD%A6%E4%B9%A0C%E8%AF%AD%E8%A8%80-%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B1%9E%E6%80%A7%2F"},{"title":"学习Linux-软件磁盘阵列","url":"%2F2019%2F04%2F23%2FLinux%2F%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0%2F%E5%AD%A6%E4%B9%A0Linux-%E8%BD%AF%E4%BB%B6%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%2F","content":"\n### 什么是软件磁盘阵列？\n```\n介绍：磁盘阵列又称RAID，即容错廉价磁盘阵列。\n功能：RAID可以通过一些技术将多个较小的磁盘整合成为一个较大的磁盘设备，这个较大的磁盘设备不只有存储功能，还能数据保护。\n整个RAID由于选择的等级不同，可以分为几个等级：\n```\n\n### 磁盘阵列模式\n\n#### １、RAID-0（等量模式，stripe）：性能最佳\n```\n组成：使用相同型号与容量的磁盘。\n形式：RAID会将把存储的数据切割成块均匀分布到各个组成磁盘阵列的磁盘中。\n优点：整合各个磁盘，加大了磁盘容量。\n缺点：一块磁盘损坏，所有数据损毁，有数据损毁的风险。如果型号不同，性能会根据水桶原则以最小的那个容量为准，最小容量磁盘没有了，大大降低磁盘阵列性能。\n\n```\n\n#### ２、RAID-1（映像模式，mirror）：完整备份\n```\n组成：使用相同型号与容量的磁盘。\n形式：将同一份写入的数据分别写入其他不同磁盘。\n优点：完整备份文件，一个磁盘损坏，文件也能完全保存。\n缺点：由于有一半容量用于备份，总容量只有总磁盘容量的一半。读取性能较低。\n\n```\n\n\n#### ３、RAID 0+1 / RAID 1+0\n```\n组成：综合RAID-0和RAID-1的功能。\n形式：RAID 0+1，先将两个磁盘用RAID-0方式组合，共两组，再将两组RAID-0组合成RAID-1。RAID 1+0则相反。\n优点：结合了RAID-0,RAID-1的优点，性能最佳，数据安全。\n缺点：由于RAID-1的缺点，总容量减少一半用来备份。\n\n```\n\n#### ４、RAID 5：性能与数据备份的均衡考虑\n```\n组成：至少需要三块以上的磁盘才能组成。\n形式：RAID-5与RAID-0有点类似，但在每个循环的写入过程中，在每个磁盘还加一个同位检查数据，会记录其他磁盘的备份数据。\n优点：有同位检查码，能支持一个磁盘损毁却能救回来，读取性能与RAID-0相差不大，但是写入速度比较慢。\n缺点：要占用一块磁盘的容量，仅能支持一个磁盘损毁。\n备注：发展出了RAID-6,能够支持两块磁盘损毁。\n\n```\n\n#### ５、 Spare Disk：预备磁盘功能\n```\n组成：一块或者多块没有包含在磁盘阵列里的磁盘\n形式：当磁盘阵列磁盘损坏，这块spare disk主动被拉入磁盘阵列，立即重建数据系统。\n优点：替代损坏的磁盘，是数据完整，能够保证数据安全。\n缺点：未知。\n\n```\n\n### 磁盘阵列分类\n\n#### １、硬件磁盘阵列\n```\n\n通过磁盘阵列卡来完成数组的目的。\n```\n\n#### ２、软件磁盘阵列（CentOS　mdadm）\n```\n利用软件来仿真磁盘阵列的功能。\n\n```\n","tags":["Linux"],"categories":["鸟哥的Linux私房菜笔记"]},{"title":"学习Linux-打印机及硬件数据收集","url":"%2F2019%2F04%2F23%2FLinux%2F%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0%2F%E5%AD%A6%E4%B9%A0Linux-%E6%89%93%E5%8D%B0%E6%9C%BA%E5%8F%8A%E7%A1%AC%E4%BB%B6%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%2F","content":"\n### 1、打印机\n\n### 2、CUPS设置linux打印机\n\n### 3、硬件数据收集与驱动及im_sensors\n\n##### 硬件信息收集与分析\n\n命令\n```\nfdisk\nhdparm:查看硬盘信息与测试读写速度\ndmesg:查看内核运行过程中所显示的各项信息记录\nvmstat:分析系统目前状态\nlspci:列出PC的PCI接口设备\nispci -vv(显示更详细信息)n（查看id）\nlspci -s 设备总线等 -vv\nlsusb:列出系统各个USB端口状态与链接的USB\nlsusb -t(目录树)\niostat:事实列出整个CPU与接口设备的I/O状态\niosstat -c(仅显示cpu状态) -d（仅显示存储设备状态） -k（默认显示block,以k为单位） -m(以M为单位) -t（显示日期）\nim_sensors(检测温度电压)\nim_sensors-detect(主板芯片组检测程序)\nudev：用户级软件。使用户自行处理/dev/下的设备\nhal（硬件抽象层）:将系统所有硬件进行快照，并持续检查快照的内容\n自定义设备名称：更改/etc/udev/rules.d/*.rules 按照：KERNEL=\"分区名\",NAME=\"改后名\"改变分区名称\n反向删除：umount 改变了的分区 ,rm 规则文件\n```\n"},{"title":"学习C语言 指针","url":"%2F2019%2F04%2F21%2FC%2F%E5%AD%A6%E4%B9%A0C%E8%AF%AD%E8%A8%80%2F%E5%AD%A6%E4%B9%A0C%E8%AF%AD%E8%A8%80-%E6%8C%87%E9%92%88%2F","content":"\n## 指针\n> 指针，是C语言中的一个重要特性。运用好指针，我们对于内存工作的理解也会有深刻的认识。\n\n### 内存、地址和指针\n#### 内存\n![内存](内存.png\u0001\u0001 \"内存\")  \n      如上图所示，这就是内存在计算机中的表现形式，每一个单位称为一个字节，每个字节包含存储一个字符所需要的位数。  \n![内存单位](内存单位.png\u0001\u0001 \"内存单位\")  \n      为了存储更大的值，多个字节组合成一个更大的单位。上图是以4个字节的字来表示。  \n+ 注意：  \n    1.尽管一个字包含4个字节，但它仍然只有一个地址。  \n    2.内存中的每个位置（一个地址）有一个独一无二的标识  \n    3.内存中的每个位置（一个地址）都包含一个值\n<!-- more -->\n#### 地址  \n下面一个例子显示了内存中5个字的内容\n![内存内容](地址与内容1.png   \"地址与内容1\")  \n方框上方是每个字的在内存中的地址，方框中的值就是这个地址中的内容  \n高级语言的特性就是通过名字来访问内存的位置，高级语言使用名字来代替地址，这些名字就是变量。  \n指针变量，则是指向这些名字的变量（指向变量的变量），指针变量指向一个内存地址。通过取地址运算符指向名字所代表的地址，通过解引用得到这个内存地址中的内容。\n\n#### 指针  \n##### 定义   \n      C语言中的指针是指专门用来存放内存地址的变量，每个指针都有与之相关联的数据类型，该类型决定了指针所指向的变量的类型。\n```C\n      char *p ;         //定义了一个char类型的指针变量，这个指针变量能指向一个char类型的内存地址\n      int *p1 , p2 ;    //这里定义了一个指针int型的指针变量p1和一个int变量p2\n      double *p=null ;  //这个语句可以看作是两个语句，先是定义double类型的指针变量p,将p指向一个内存地址(这里为NULL表示不指向任何地址)\n```\n##### 指针的运算符  \n```\n   &: 取地址运算符 , 指针通过取地址运算符得到变量名代表的地址\n   *: 解引用运算符 ，指针通过解引用运算符得到该地址中的内容\n```\n\n##### 指针表达式\n以一个声明开头,首先声明和初始化需要的变量\n```C\nchar ch = 'd';\nchar *cp = &ch ;\n```\n  + 注意   \n    **以下图中加粗的椭圆表示表达式的值**  \n    **方框表示地址**\n    **方框上的字符表示内存别名**  \n\n  + &ch表达式  \n![&ch表达式](&ch表达式.png \"&ch表达式\")\n解释：表达式&ch意思为将变量ch取地址，得到ch的地址，这个地址中的内容就是'd'。当&ch用作右值时，取的是ch的地址;作为左值则是非法(左值一般是变量，用于存储右值,&ch会取得一个地址，不是变量)。\n  + cp表达式\n![cp表达式](cp表达式.png \"cp表达式\")  \n解释：表达式cp是一个指针变量（指向一个变量的变量）,在声明中已经为cp指向&ch。当作为左值时，它的左值就是cp所处的内存位置；当作为右值就是cp的内容。  \n  + &cp表达式\n![&cp表达式](&cp表达式.png \"&cp表达式\")  \n解释：表达式&cp是将指针变量cp取地址，得到指针变量的地址。cp是一个指向ch地址的指针变量,&cp作为右值则是一个不知名的指针(指向字符d的指针的指针)指向的地址。同样，不能作为左值。\n  + \\*cp表达式\n![*cp表达式](*cp表达式.png \"*cp表达式\")  \n解释：表达式*cp是将指针cp解引用，得到ch地址中的内容'd'。当作为右值时，它的值是ch中的内容；作为左值是得到它自己的地址，\\*cp的地址是ch的地址;作为右值则是它自己的内容，它的内容是ch的内容。\n  + \\*cp+1\n![*cp+1表达式](*cp+1.png \"*cp+1\")  \n解释:\\*cp+1,cp先解引用得到cp指向地址的内容'd'，然后+1,得到一个新值'e'。当作为左值时，表达式是一个具体的值，不能作为左值；作为右值，它的值是一个新值'e'。\n  + \\*(cp+1)  \n![*(cp+1)](*（cp+1）.png \"*（cp+1）\")  \n解释:\\*(cp+1),得到一个新的指针cp+1,指向一个新的地址，然后将指针解引用，得到指向的新地址的内容。作为右值时，表示这个cp+1指向的新的地址的内容；作为左值时，表示cp+1指向的新的地址本身。\n  + ++cp\n![++cp](++cp.png \"++cp\")  \n解释： ++cp，可以分为两个变量，增值前的指针和增值后的指针。增值前的指针先增加得到一个新的指针指向一个新的地址，增加后的指针得到增加前的指针+1后的一份拷贝，增加后的指针也是指向同一个新地址。\n  + cp++  \n![cp++](cp++.png \"cp++\")  \n解释： cp++,先返回一份cp的拷贝，然后再增加cp的值，表达式的值则是原来cp的值的一份拷贝。\n  + \\*++cp    \n![cp++](*++cp.png \"*++cp\")  \n解释： 间接访问操作符作用于增值后的指针的拷贝上，所以它的右值是ch后面的那个内存地址的值，左值是是那个位置本身。\n  + \\*cp++    \n![*cp++](*cp++.png \"*cp++\")  \n解释： \\*cp++,右值是变量ch的值，左值是变量ch的内存位置。\n  + ++\\*cp  \n![++*cp](++*cp.png \"++*cp\")    \n解释： 先执行间接访问操作，然后，cp所指向的的值增加1。\n##### 指针和数组  \nC语言中，指针和数组密切相关，数组名实际上是指向数组第一个元素的指针\n{% codeblock lang:C %}\nint a[] = {1,2,3,4,5,6}; //一个数组在内存中表示一个逻辑上连续存储的内存块\nint *p = a ; //这里指针p指向的是一个数组的首地址（也就是一个内存块的地址）,通过指向首地址而指向一个数组\nint *pa = &a[0]; //这里pa指针指向的是数组a中的第一个元素的地址\np = p+1 ; //指针此时，p指向数组a中的a[1]的地址\n{% endcodeblock %}\n示例：\n{% codeblock lang:C %}\n#include <stdio.h>\nint main()\n{\n  int a[10],i , *p=NULL ; //这里定义一个长度为10的数组a,一个变量i,和一个初始化为NULL的指针p\n\n  //初始化数组a\n  for(i=0;i<10;i++)\n  {\n    a[i] = i ;\n  }\n\n  //用下标方法打印数组值（数组从0开始）\n  for(i=0 ; i<10 ; i++)\n  {\n    printf(\"%d\",a[i]);\n  }\n  printf(\"\\n\");\n\n  //用指针形式打印数组,a+i表示从首地址开始加i个地址，相当于得到数组中的第i个元素的地址，然后用*解引用运算符解引用，得到a+i地址中的内容\n      for(i=0 ; i<10 ; i++)\n      {\n        printf(\"%d\",*(a+i));\n      }\n      printf(\"\\n\");\n\n      //先让指针p指向数组a的首地址，使得指针p指向数值a\n      //*p++ : *p=*p+1由于运算符+优先级小于* , 指针p先解引用得到p指向地址的内容，并打印，再+1,将新值赋值给*p,之后指针p指向下一个地址\n      for(p=a ; p<a+10 ;)\n      {\n        printf(\"%d\",*p++);\n      }\n      printf(\"\\n\");\n\n      return 0 ;\n    }\n    {% endcodeblock %}\n  + 注意区别：  \n        \\*p++ : 先取得当前p所指向的变量值再使得p指向后一个变量，相当于a[i++]\n        \\*p-- : 先取得当前p所指向的变量值再使得p指向前一个变量，相当于a[i--]\n        \\*++p : 先使p指向后一个变量再取得p所指向的变量的值，相当于a[++i]\n        \\*--p : 先使p指向前一个变量再取得p所指向的变量的值，相当于a[--i]\n\n##### 指针和函数\n  + 指针作为函数的参数  \n    作用是将一个变量的地址送到一个函数中。\n    {% codeblock lang:C %}\n    #include <stdio.h>\n\n    void change(int i , int *p)\n    {\n      i++ ;\n      if(p!=NULL)\n      {\n        (*p)++; //先解引用取得当前指向的变量值，再将值+1,然后指向新的值(与*p++有区别)\n      }\n    }\n\n    int main()\n    {\n      int a=5,b=10;\n      change(&b);\n      printf(\"a=%d,b=%d\\n\",a,b);//a=5,b=11；a传进函数后，成为这个函数的局部变量，在函数销毁后，局部变量得到的值也会被销毁；b是将地址传进函数，通过指针运算，指针p将b的地址中的值+1，最终函数销毁，b的地址没有被销毁，因此b的值变了\n      return 0 ;\n    }\n    {% endcodeblock %}\n  + 返回指针的函数  \n    作用是返回指针，即地址(指针指向的是地址)。\n    {% codeblock lang:C %}\n    #include <stdio.h>\n    char *name[3] = {\"are\",\"you\",\"ok\"};//一个字符串需要用指针来获取\n    char *message = \"wrong input\" ;\n\n    char *test(int i)\n    {\n      if(i<0 || i>3)\n      {\n        return message ;//返回一个指向字符串的指针\n      }\n      else\n      {\n        return name[0] ;//返回数组的首地址\n      }\n    }\n\n    int a ;\n    char *p ;\n    printf(\"input:\");\n    scanf(\"%d\",&a);\n    p = test(a); //p获取返回的字符串\n    printf(\"%s\\n\",p);\n    {% endcodeblock %}\n  + 指向函数的指针  \n    指向函数的指针是一个指针变量，它 **指向一个函数**。一个函数的 **函数名是一个指针**，它指向 **函数的代码**。函数的调用可以通过函数名来调用也可以通过指向函数的指针调用。\n    {% codeblock lang:C %}\n    #include <stdio.h>\n    #define GET_MAX 0\n    #define GET_MIN 1\n\n    //定义一个获取最大值函数\n    int get_max(int i , int j)\n    {\n      return i>j?i:j ;\n    }\n    //定义一个获取最小值函数\n    int get_min(int i , int j)\n    {\n      return i>j?j:i ;\n    }\n\n    int compare (int i , int j , int flag)\n    {\n      int ret ;\n      int (*p)(int , int); //定义一个指向有两个int参数的函数的函数指针\n      if(flag == GET_MAX) //如果为真\n      {\n        //笔者注：可以把p看做是引用变量，指向一个函数对象\n        p = get_max ; //使得函数指针p指向函数get_max的入口地址，让函数指针作为get_max函数的别名\n      }\n      else\n      {\n        p = get_min ;\n      }\n\n      //笔者注：有点像面对对象的多态，p就是一个接口，而get_max和get_min函数就是这个接口的具体实现，需要用到那个函数就使用p调用哪个函数\n      ret = p(i,j);//将参数传入函数指针，通过函数指针p来调用p指向的函数,获取返回值\n      return ret ;\n    }\n\n    int main()\n    {\n      int i=5 , j =10 ,ret ;\n      ret = compare(i,j,GET_MAX);\n      printf(\"the MAX is %d\\n\",ret);\n      return 0 ;\n    }\n    {% endcodeblock %}\n\n  + 函数指针做形参  \n    函数的参数可以是指针，那么指向函数的函数指针也可以作为函数参数传递。\n    {% codeblock lang:C %}\n    #include <stdio.h>\n    int get_big(int i , int j)\n    {\n      return i>j?i:j ;\n    }\n    //笔者注：其实可以把函数形参中的函数指针放在函数中,作为局部变量\n    int get_max(int i , int j , int k , int (*p)(int , int))\n    {\n      int ret ;\n      ret = p(i,j);\n      ret = p(ret , k);\n      return ret ;\n    }\n    //函数指针作为局部变量\n    int get_max1(int i, int j , int k)\n    {\n      int (*p)(int ,int);\n      int ret ;\n      p = get_big ;\n      ret = p(i,j);\n      ret = p(ret,k);\n      return ret ;\n    }\n\n    int main()\n    {\n      int i=5,j=10,k=15,ret1,ret2 ;\n      //两个方法都可行\n      ret1 = get_max(i,j,k,get_big);\n      ret2 = get_max1(i,j,k);\n      printf(\"get_max:%d\\nget_max1%d\\n\",ret1,ret2);\n      return 0 ;\n    }\n    {% endcodeblock %}\n  + 返回函数指针的函数  \n    {% codeblock lang:C %}\n    #include <stdio.h>\n    //笔者注：将get_big这个函数看作是商品\n    int get_big(int i , int j)\n    {\n      return i>j?i:j ;\n    }\n\n    //笔者注：可以把这个返回函数指针的函数看作是快递员,商品通过快递员运送\n    int (*get_function(int a))(int , int)\n    {\n      printf(\"%d\\n\",a);\n      return get_big ; //返回一个函数指针,将函数返回\n    }\n\n    int main()\n    {\n      int i=5 , j = 10 , max ;\n      int (*p)(int , int); //定义一个函数指针\n      //笔者注：最后快递员将商品运送到客户那里,100就是商品的快递号\n      p = get_function(100); //用函数指针指向返回函数指针的函数的返回值,得到一个函数,现在p是指向get_big函数的函数指针\n      //笔者注：客户开始使用商品\n      max = p(i,j); //现在的p调用一个函函数\n      printf(\"The MAX is %d\\n\",max);\n      return 0 ;\n    }\n    {% endcodeblock %}\n  + 指向字符串的指针   \n    C语言中没有字符串类型的关键字，但是有多种方法访问字符串。\n    - 用字符数组存放字符串\n    - 用字符串指针来指向字符串\n\n  　　\n    {% codeblock lang:C %}\n    #include <stdio.h>\n    int main()\n    {\n      //采用字符数组拷贝字符串\n      char a[] = \"Linux C Program\" , b[20],c[20];\n      int i ;\n      //数组采用指针形式\n      for(i=0 ; *(a+i) != '\\0' l i++)\n      {\n        *(b+i) = *(a+i);\n      }\n      *(b+i) = '\\0' ;\n      //采用字符指针拷贝字符串\n      char *p1 , *p2 ;\n      p1 = a ; //p1指向数组a首地址\n      p2 = c ;\n      //使用解引用运算符获取指向数组中的值\n      //对指针变量进行增量加，实现对数组块的地址遍历\n      for(;*p1 != '\\0' ; p1++,p2++)\n      {\n        *p2=*p1 ; //将指针p1指向的数组中的元素的值传给指针p2指向的数组的元素\n      }\n      *p2='\\0';\n\n      printf(\"%s\\n\",a);\n      printf(\"%s\\n\",b);\n      printf(\"%s\\n\",c);\n      return 0 ;\n    }\n    {% endcodeblock %}\n### 结束语\n> 指针作为C语言的精髓，对于初学者来说确实难学。难学归难学，在真正理解并接受指针这个概念后，你将被指针的绝妙所折服。正所谓，不识庐山真面目，只缘身在此山中。\n","tags":["C"],"categories":["初级篇"]},{"title":"学习Linux-启动流程","url":"%2F2019%2F04%2F20%2FLinux%2F%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0%2F%E5%AD%A6%E4%B9%A0Linux-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F","content":"\n### 1、linux的启动流程\n{% codeblock %}\n加载BIOS的硬件信息与进行自我测试，依据设置取得第一个可启动的设备\n-->\n读取并执行第一个启动设备内MBR的boot loader（即是grub,spfdisk等）\n-->\n依据boot loader的设置加载kernel，kernel开始检测硬件与加载驱动程序\n-->\n主动调用init进程，init取得run-level(运行程序优先级)信息\n-->\ninit执行/etc/rc.d/rc.sysinit文件准备软件执行的操作环境\n-->\ninit执行run-level的各个服务启动（scripts）\n-->\ninit执行/etc/rc.d/rc.local文件\n-->\ninit执行终端机模拟程序mingetty进程，最后等待用户登录\n{% endcodeblock %}\n<!-- more -->\n### 2、BIOS,boot loader,kernel加载\n\n{% codeblock %}\nBIOS,MBR:开机时，系统自动加载BIOS，并通过BIOS加载CMOS，取得各个硬件配置，之后BIOS进行开机自检，执行硬件检测初始化，，配置PnP设备，定义启动顺序，进行启动设备数据读取。\nBIOS通过硬件的INT13检测磁盘，读取MBR。\nBoot Loader引导加载程序：包含在MBR中，认识操作系统文件格式，加载内核文件  -->linux的boot loader是grub\n功能：提供菜单，加载内核文件，转交其他loader.\n注：每个文件系统都会有一个引导扇区提供操作系统安装boot loader。\n安装双系统问题：windows的loader不具有控制权转交功能，因此只能先装windows再装linux。\nboot loader加载内核检测硬件与initrd功能\nlinux内核文件放在/boot中，而其他的linux启动不需要的附加内核（附加的驱动程序）放在/lib/modules/目录类，并且被编译为模块。\n虚拟文件系统：放在/boot/initrd，能够通过boot loader来被加载，并被激活，如果boot loader不能顺利挂载根目录，initrd就会被解压缩启动，并且在内存中仿真一个根目录，且仿真的文件系统能提供一个可执行程序来加载启动需要的内核模块，，帮助内核重新调用/sbin/init开始后续的启动流程，从而正常启动系统。\n{% endcodeblock %}\n\n\n\n### 3、第一个进程init及配置文件/etc/inittab与runlevel\n{% codeblock %}\nrun-level：执行等级\n0 --> halt\n1--> 单用户维护模式\n2 --> 类似纯文本模式，但是无NFS服务\n3 --> 纯文本模式 ， \n4 --> 系统保留功能 ， \n5 --> X11 ， \n6 --> reboot\n{% endcodeblock %}\n\n### 4、init处理系统初始化流程（/etc/rc.d/rc.sysinit）\n\n#### 主要工作：\n{% codeblock %}\n1、取得网络环境与主机类型\n2、测试与挂载内存设备/proc及USB设备/sys\n3、是否启动SElinux\n4、启动系统随机数生成器（进行密码加密演算）\n5、设置终端机字体\n6、设置启动过程中的欢迎画面\n7、设置系统时间与时区，读取/etc/sysconfig/clock\n8、接口设备的检测与Plug and Play(PnP)参数的设置\n9、用户自定义模块加载\n10、加载内核相关设置\n11、设置主机名与初始化电源管理模块\n12、初始化软件磁盘阵列\n13、初始化LVM文件系统功能\n14、fsck检查磁盘文件系统\n15、进行磁盘配额的转换\n16、重新以可读写模式挂载系统磁盘\n17、启动quota功能\n18、启动系统伪随机数生成器\n19、清除临时文件\n20、将启动相关信息加载到/var/log/dmesg中\n{% endcodeblock %}\n\n### 5、启动系统服务与相关的启动配置文件（/etc/rc.d/rc(n)& /etc/sysconfig）\n{% codeblock %}\n/etc/rc.d/rc\\*:K开头的文件是表示stop,S开头的文件表示start，其后数字表示启动顺序\n注：都是连接文件\n用户自定义开机程序：/etc/rc.d/rc.local中包括的完整文件名\n在/etc/inittab内的mingetty是启动终端机的命令\n{% endcodeblock %}\n\n\n### 6、启动中需要的配置文件\n\n{% codeblock %}\n/etc/modprode.conf：指定系统内硬件所使用的模块\n/etc/sysconfig/：启动中读取的相关服务配置文件,authconfig,设置用户身份认证机制;clock,设置时区，/usr/share/zoneinfo/Asia/ShangHai复制到/etc/localtime；i18n，设置语系；keyboard&mouse,键盘，鼠标形式；so on...\nrun-level切换\nrunlevel：展现当前runlevel\ninit:切换命令\n{% endcodeblock %}\n\n\n\n### 7、内核与内核模块\n\n#### 位置：\n{% codeblock %}\n内核：/boot/vmlinuz or /boot/vmlinuz-version\n内核解压缩所需RAMDisk:/boot/initrd(/boot/initrd-version)\n内核模块：/lib/modules/version/kernel or /lib/modules/$(uname -r)/kernel\n内核源码;/usr/src/linux or /usr/src/kernels\n内核版本：/proc/sys/kernel\n系统内核功能：/proc/sys/kernel\n{% endcodeblock %}\n#### 内核模块与依赖性：\n{% codeblock %}\ndepmod -Ane:创建modules.dep，记录内核支持的模块的各项依赖性\n{% endcodeblock %}\n#### 查看内核模块\n{% codeblock %}\nlsmod:模块名称，模块大小，模块是否被其他模块所用\nmodinfo -a（author）d(description)i(license)n(详细路径) 模块名称\n{% endcodeblock %}\n#### 加载与删除\n{% codeblock %}\ninsmod /lib/modules/$(uname -r) 文件路径 // 加载模块  //不主动分析依赖性\nrmmod -f(强制)w（完结后） 模块名\nmodprode -1cfr //主动分析依懒性\n/etc/modprode.conf\n{% endcodeblock %}\n\n\n### 8、grub\n{% codeblock %}\nboot loader 的程序代码执行与设置值加载分成两个阶段\nstage1:执行boot loader主程序，最小主程序安装在启动区\nstage2:主程序加载配置文件，配置文件都放在/boot中\ngrub配置文件：/boot/grub/menu.lst\n硬盘在grub的代号从0开始，例如，第一块硬盘，（hd0）,(hd0,1),(hd0,2)\nchain loader转交控制权：编辑/boot/grub/menu.lst，将第一个启动的系统设置为使用hd0分区，读取第一个硬盘分区。\n{% endcodeblock %}\n\n\n### 9、Initrd，创建initrd文件\n\n{% codeblock %}\nmkinitrd -v --with=模块名称 initrd文件名 内核版本 ：重制initrd文件\n{% endcodeblock %}\n\n\n\n### 10、测试与安装grub\n{% codeblock %}\n如果机器没有安装grub，可以尝试安装一个\n{% endcodeblock %}\n#### 安装步骤：\n{% codeblock %}\n1、grub-install [--root-dirrctory=DIR]（安装实际目录） INSTALL_DEVICE（安装设备）\n2、创建配置文件：vim /boot/grub/menu.lst\n3、grub shell命令：root (hdx,x)：选择含有grub目录的分区代号；find /boot/grub/stage1：寻找安装信息；find /boot/vmlinuz：寻找内核；setup (hdx,x)安装grub于boot loader or MBR中；quit 离开。\nvga是屏幕分辨率，改变分辨率必须支持framebuffer_console(大写)这个内核功能参数\nBIOS无法读取大硬盘问题：新建/boot分区，并放在最前面\n{% endcodeblock %}\n#### grub菜单加密：\n{% codeblock %}\n\t1、grub-md5-crypt：产生md5密文；\n\t2、vim /boot/grub/menu.lst，将产生的密文以password --md5 密文 格式加入title，每加入一个title，加密一个title.\n\t3、整体设置，将密文放在最开始的全局设置 password --md5 密文\n{% endcodeblock %}\n\n\n\n### 11、启动过程问题解决\n\n{% codeblock %}\n忘记root密码：重新启动，进入grub，e编辑，进入单用户维护模式，修改passwd。\ninit配置文件错误：进入grub，改用bash；mount -o remount、rw / 将根目录重新挂载为可读写 mount -a；reboot\nBIOS磁盘对用问题：磁盘代号对应错误，致使紊乱，grub-install --recheck /dev/sda1：主动跟新device.map\n因文件系统错误而无法启动：fsck,检查系统错误并解决坏块，reboot\n利用chroot切换到另一个磁盘：暂时将根目录移到其他磁盘挂载，并解决问题\n{% endcodeblock %}\n","tags":["Linux"],"categories":["鸟哥的Linux私房菜笔记"]},{"title":"学习Linux-日志文件","url":"%2F2019%2F04%2F20%2FLinux%2F%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0%2F%E5%AD%A6%E4%B9%A0Linux-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%2F","content":"\n### 1、常见的日志文件\n{% codeblock %}\n/var/log/cron：crontab进程的日志\n/var/log/dmesg:：记录系统开机内核检测过程中产生的各项信息\n//var/log/lastlog:最近一次登陆系统信息\n/var/log/maillog /var/log/mail/\\*:记录邮件来往信息\n/var/log/messages:记录系统发生错误信息\n/var/log/secure：记录涉及需要账号密码的软件的登陆信息\n/var/log/wtemp /var/log/faillog：记录wtemp（正确登陆系统者账户信息），faillog（错误登陆系统者账号信息）\n/var/log/httpd/\\* /var/log/news/\\* /var/log/samba/\\*:记载不同的网络服务自己产生的各项信息\n{% endcodeblock %}\n<!-- more -->\n### 2、日志文件所需相关服务与进程\n\n{% codeblock %}\n产生方式：1、软件开发商自定义写入日志文件与相关格式，2、系统提供的日志文件管理服务来统一。\n\nklogd:记录内核信息\nsyslogd：统一管理日志文件的服务\n启动：ps aux | grep syslog（检查启动）； chkconfig --list syslog(开机启动)\n一般格式：事件发生日期与时间；主机名；服务名称/函数名称；实际数据内容\n配置文件：/etc/syslog.conf ；格式：服务名称【.=!】信息等级 信息记录的文件名或设备主机\n信息等级：1，info（基本信息说明）;2,notice（注意信息）;3、warning（警示信息）;4、err（错误信息）;5、crit（临界点）;6、alert（警告）;7、emerg（疼痛级）\n{% endcodeblock %}\n\n#### 日志文件安全性设置\n{% codeblock %}\n隐藏属性：chattr +a 强制不能删除，只能增加\n日志文件服务器：将某一主机当做日志文件服务器，启动端口监听，进行文件传送。主机添加服务器地址，服务器修改syslog配置文件（-r）\nlogrotate：自动化处理日志文件容量与更新，将旧文件更改名称，新建空白文件，重新开始记录\n配置文件：/etc/logrotate.conf /etc/logrotate.d/\nlogrotate配置文件语法：1、weekly(默认轮替周期)，2、rotate(保留日志文件)， 3、create(创建), 4、compress（压缩）， 5、include 绝对路径 6、设置的轮替命令{7、monthly(周期)， 8、minsize（文件容量）， 9、create(指定创建文件夹的用户，权限，所属)， 10、rotate（保留文件）}\nsyslog配置文件语法：1、文件名， 2、参数（用{}包括），3、sharedscripts...endscript(大格式)， 4、prerotate:启动logrotate之前进行的命令， 5、postrotate:启动logrotate之后启动的命令 \nlogrotate -v(显示模式)f（强制执行） logfile\n{% endcodeblock %}\n\n#### 分析日志文件\n{% codeblock %}\nlogwatch\n{% endcodeblock %}\n\n","categories":["鸟哥的Linux私房菜笔记"]},{"title":"学习Linux-软件安装-tarball","url":"%2F2019%2F04%2F20%2FLinux%2F%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0%2F%E5%AD%A6%E4%B9%A0Linux-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-tarball%2F","content":"### 1、可执行文件\n{% codeblock %}\nlinux上真正被识别的可执行文件是二进制文件，shell script是利用shell(bash)程序的功能进行判断式。bash本身是二进制可执行文件。\n利用 file 判断文件类型\n{% endcodeblock %}\n\n<!-- more -->\n### 2、make,configure\n{% codeblock %}\nmake与configure编译过程：configure（检测系统环境）创建makefile文件（定义编译的规则文件）--》make根据makefile中的定义的规则编译文件\nconfigure检测：\n\t1、检测编译程序可以编译的程序源码\n\t2、检测本软件所需的函数库或者其他需要的相关软件\n\t3、检测操作平台以及内核是否适合\n\t4、内核的头定义文件是否存在\n\t注：系统不同，所需的环境也不同，所以需要源码的重复编译\n\n{% endcodeblock %}\n\n### 3、tarball软件\n{% codeblock %}\ntarball：打包软件，将源文件打包并压缩，节约空间。\ntarball文件：将软件的所有源码文件先以tar打包，然后再以压缩技术压缩。其中通常会有：源代码文件、检测程序文件、本软件的简易说明。\n{% endcodeblock %}\n\n\n### 4、安装与升级软件\n{% codeblock %}\n更新方法：1、直接以源码进行编译。2、直接以编译好的二进制程序进行安装升级\ntarball文件安装过程：1、解压缩。2、gcc源码编译，生成目标文件。3、gcc进行函数库，主程序，子程序的链接，形成主要的二进制文件。4、将二进制文件及相关的配置文件安装在主机上。\n{% endcodeblock %}\n\n### 5、gcc用法\n{% codeblock %}\n1、 gcc 源代码文件 --》 ./a.out\n2、 gcc -c(接.c文件) hollow.c --》 gcc -o(接.o文件) hollow(改名) hollow.o --》./hollow \n注：gcc -c生成目标文件*.o（存放编译过程中产生的编译，调试信息等，是二进制文件） gcc -0产生可执行文件\n调用外部函数库：gcc -l（加入函数库）m（libm.so函数库） -L+路径（函数库路径） -I+路径（include文件）\n-Wall -O这些参数为CFLAGS（环境变量）\n{% endcodeblock %}\n### 6、make进行宏编译\n#### vim makefile 制定编译规则\n{% codeblock %}\nmain(执行信息):（目标文件,o）\n\tgcc -o 目标文件 lm(调用函数库)\nmake main\n{% endcodeblock %}\n#### 运用变量简化makefile\n{% codeblock %}\nLB = -lm（调用函数库）\nOB = object.o(目标文件)\nCFLAGS = -Wall(指定的环境变量：显示详细警告信息)\nmain: $(OB)\n\tgcc -o $（OB） $（LB）\nclean:\n\trm -rf main $(OB)\n{% endcodeblock %}\n#### make安装流程\n{% codeblock %}\n将tar包解压缩到/usr/local目录--》./configure --prefix=/usr/local/（安装路径） --enable-all-clocks --enable-parse-clocks --》make clean;make--》make check--》make insatll\n{% endcodeblock %}\n### 7、利用patch更新源码\n{% codeblock %}\ndiff -Naur 新旧文件 //比较两个文件改变\npatch -p0 < 路径 //p后面的数字表示去掉几个“/”  这个命令是更新源码\nmake install 安装软件更新\npatch -R 还原文件\n{% endcodeblock %}\n### 8、函数库管理\n{% codeblock %}\n是linux上本身存在的程序，函数库也可以认为是子程序，可以被调用来执行的一段功能函数。\n函数库又分动态函数库与静态函数库\n静态函数库：\\*.a 包括在程序中，编译后的程序很大。函数库更新，需要重新编译可执行文件 系统更新困难\n动态函数库：\\*.so 程序之外，应用时才调入执行程序。函数库更新，不需要改动可执行文件 容易大规模更新\n将动态函数库加载到内存（缓存），增加读取速度：\n/etc/ld.so.conf:读入加载到内存的动态函数库所在目录\nldconfig:可执行文件，将数据读入缓存当中，也将数据记录到/etc/ls.so.conf中\nldconfig -f(conf) -c(cache) -p(列出所有函数库数据内容)\nldd:程序的动态函数库解析\nldd -v(所有信息)d（有丢失的link显示出来）r（错误信息显示） 文件名\n{% endcodeblock %}\n### 9、检验软件正确性\n{% codeblock %}\nmd5sum/sha1sum：判断文件指纹\nmd5sum/sha1sum -b(二进制读取方式)c（检验文件指纹）t（文本类型读取文件指纹） 文件名\nmd5sum/sha1sum --status|--warn --check 文件名\n{% endcodeblock %}\n#### 为重要数据建立指纹数据库\n{% codeblock %}\n用md5sum/sha1sum 检查出文件指纹，并记录为数据库。\n{% endcodeblock %}\n\n","tags":["Linux"],"categories":["鸟哥的Linux私房菜笔记"]},{"title":"学习Linux-软件包管理机制","url":"%2F2019%2F04%2F20%2FLinux%2F%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0%2F%E5%AD%A6%E4%B9%A0Linux-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%2F","content":"\n## 软件包管理机制\n### 1、rpm\n#### 定义\n{% codeblock %}\n是一种数据库记录方式将自己所需的软件安装到linux系统上的一套管理机制 \n{% endcodeblock %}\n#### 特点\n{% codeblock %}\n将要安装的软件编译打包成rpm机制的安装包，在安装包里有默认数据库，记录该软件安装需要的默认依赖属性软件包。\n{% endcodeblock %}\n<!-- more -->\n#### 命名格式\n{% codeblock %}\n软件名称-软件版本信息-发布次数-适合的硬件平台.rpm\n{% endcodeblock %}\n#### 安装流程\n{% codeblock %}\n读取文件内记载的设置参数内容--》比较linux系统环境，找出属性依赖软件安装问题--》安装--》软件相关信息写入/var/lib/rpm/下数据库文件（记录有数字证书信息）\n{% endcodeblock %}\n#### 默认安装路径：\n{% codeblock %}\n/etc：软件配置文件\n/usr/bin：二进制可执行文件\n/usr/lib：程序使用的动态数据库\n/usr/share/doc：帮助手册\n/usr/share/man：man page文件\n{% endcodeblock %}\n#### 安装参数：\n{% codeblock %}\nrpm    -i(install) -v(查看详细安装信息) -h（显示安装进度） 文件名/网址\n       --nodeps          //发现有依赖问题，强制安装\n\t--replacediles    //覆盖文件安装\n\t--replacepkgs     //重复安装\n\t--force           //强制安装，不管什么原因\n\t--text            //测试软件是否可以被安装，找出依赖问题\n\t--justdb          //更新rpm数据库相关信息\n\t--nosignature     //略过数字证书\n\t--perfix 路径       //自定义安装路径\n\t--noscripts       //不让软件在安装时执行系统命令\n{% endcodeblock %}\n#### 查询参数：\n##### 查询已安装软件\n{% codeblock %}\nrpm    -q[ailcdRf]      \n       -qa(all)          //查询已安装软件 \n\t-qi(imformation)  //列出软件详细信息\n\t-ql(list)         //列出软件所有文件与目录所在完整文件名\n\t-qc               //列出该软件所有配置文件\n\t-qd               //列出该软件所有帮助文件\n\t-qR(requires)\t    //列出该软件的依赖\n\t-qf               //找出文件属于安装的哪个文件\n{% endcodeblock %}\n##### 查询rpm文件\n{% codeblock %}\nrpm\t-qp[icdlR]        //参数意义与上述说明一致\n{% endcodeblock %}\n##### 验证参数：\n{% codeblock %}\nrpm    -V  软件            //文件是否被改动\n\t-Va               //列出系统上所有被改动的文件\n\t-Vp               //列出该软件可能被改动的文件\n\t-Vf               //列出某个文件是否被改动\n{% endcodeblock %}\n##### 验证信息：SM5DLUGT c filename\n{% codeblock %}\nS:文件大小容量是否改动；M：文件类型或属性；5：MD5码；D：设备主/次代码；L:LI=ink路径；U：文件所有者；G：文件所属组；T：创建时间。\nc代表文件类型：c:设置文件；d:文档；g：ghost；l:授权文件；r：自述文件。\nrpm卸载\nrpm -e 文件                 //卸载文件\nrpm --rebuilddb          //重建数据库\n{% endcodeblock %}\n### 2、srpm(source rpm)\n#### 定义：\n{% codeblock %}\n没有经过编译，提供的是源代码，以\\*.src.rpm格式命名。其中含有该软件所需要的依赖性软件的说明以及所有rpm所提供的文件。\n{% endcodeblock %}\n#### 过程：\n{% codeblock %}\n会先以rpm机制编译成rpm包，再将文件安装到系统上。\n{% endcodeblock %}\n#### 安装srpm文件：\n{% codeblock %}\nrpbuild --rebuild        //将srpm文件编译与打包，但不安装\n\t --recompile      //直接编译打包且安装\n{% endcodeblock %}\n#### srpm路径与需要软件：\n{% codeblock %}\n/usr/src/redhat/SPECS    //放置该软件设置文件\n/usr/src/redhat/SOURCES  //放置源文件以及config设置文件\n/usr/src/redhat/BUILD    //存放编译过程中的暂存数据\n/usr/src/redhat/RPMS     //顺利编译后，放置打包的文件\n/usr/src/redhat/SRPMS    //放置srpm封装的文件\n注：编译错误会在/tmp产生错误文档，可以查看此文档排错\n{% endcodeblock %}\n### 3、srpms设置文件内容（\\*.spec）\n#### 介绍软件基本相关信息\n{% codeblock %}\nSummary(主要说明)\nName(软件名称)\nVersion(版本)\nRelease(打包次数说明)\nLicense(授权模式)\nGroup（开发团体名称）\nUrl(官方网站)\nSource（软件来源）\npatch(补丁)\nBuildRoot（设置作为编译，使用哪个目录来临时存放中间文件）\nExclusiveArch(说明软件适合安装的硬件)\nRequires(软件依赖)\nPrerep(需要的前驱程序)\nBuildRequires(编译过程中需要的软件)\nPackager(软件打包者)\nVender(开发厂商)\n{% endcodeblock %}\n#### 设置依赖属性需求\n{% codeblock %}\nBuildRoot:%{\\_tmppath}/%{name}-%{version}-%{release}-root\nPrereq:              //前驱程序\nRequires:            //所需依赖\nBuildRequires:       //所需工具软件\n%description         //软件描述\n{% endcodeblock %}\n#### 编译预处理，编译所需命令\n{% codeblock %}\n%prep                //预处理，大致是patch软件\n%setup -q            //解压缩之类的工作\n%patch -p1 -b .config\n%patch -p1 -b .buildroot\n%patch -p1 -b 。ipchains\n注：此项主要工作：1、进行补丁等工作；2、寻找需要的软件目录是否存在；3、事先新建所需目录；4、如果安装时会发生文件覆盖，则进行备份工作。\n%build               //实际编译\ncd src\nautoconf\nCFLAGS=\"-D GUN SOURCE\" %configure\nmake\ninstall -m o755 %{SOURCE1} scritps\ninstall -m o755 %{SOURCE2} scritps\ninstall -m o755 %{SOURCE3} scritps\ninstall -m o755 %{SOURCE4} scritps\ninstall -m o755 %{SOURCE5} scritps\n%install            //安装过程\nrm -rf %{buildroot}\nmkdir -p %{buildroot}/sbin\nmake -C src install RPM INSTALL ROOT-%{buildroot}\n{% endcodeblock %}\n#### 列出软件发布的文件\n{% codeblock %}\n%files\n%defatter (-,root,root)\n%doc 文件\n{% endcodeblock %}\n#### 列出软件更改的历史记录\n{% codeblock %}\n%changelog\n\\*:以时间、修改者、email、与软件版本作为说明\n-:做的详细说明\n{% endcodeblock %}\n#### srpm编译命令\n{% codeblock %}\nrpmbuild -ba(同时生成rpm与srpm) -bb(仅编译成rpm) \\*.spec\n编译步骤：进入/usr/src/redhat/BUILD目录--》依照\\*.spec文件的name与version定义工作目录--》依照\\*.spec中的source设置将/usr/src/redhat/SOURCE中的文件进行解压缩--》开始%build与%install--》将打包文件放置\n{% endcodeblock %}\n### 4、YUM在线升级机制\n#### yum查询参数：\n{% codeblock %}\nyum    -y                       //自动提供yes响应\n\t--installroot=/some/path //自定义安装路径\n\tsearch                   //搜索软件名称\n\tlist                     //列出yum管理的所有软件\n\tinfo                     //所有信息\n\tprovides                 //从文件中搜索软件\n{% endcodeblock %}\n#### 安装/升级参数：\n{% codeblock %}\nyum    install                  //安装\n\tupdate                   //更新\n{% endcodeblock %}\n#### 删除参数：\n{% codeblock %}\nYum    remove                   //删除\n{% endcodeblock %}\n#### Yum设置文件\n{% codeblock %}\n/etc/yum.repos.d/CentOS-Base.repo\n{% endcodeblock %}\n##### 内容解析：\n{% codeblock %}\n[Base]:代表容器的名字\nname:说明容器意义\nmirrorlist=:容器可以使用的镜像站点\nbaseurl=:容器的实际网址\nenable=1：容器被启动\ngpgcheck=1：数字证书验证启动\ngpgket=:数字证书公匙所在位置\n{% endcodeblock %}\n\\#### 清除本机旧数据\n{% codeblock %}\nyum clean packages               //将已下载的文件删除\n           headers               //将下载的软件文件头删除\n           all                   //将所有容器数据删除\n{% endcodeblock %}\n#### yum软件组功能\n{% codeblock %}\nyum    grouplist                  //列出可使用的软件组清单\n       groupinfo                  //了解该软件组名称\n\tgroupinsatll               //安装选中的软件组\n\tgroupremove                //删除软件组\n{% endcodeblock %}","tags":["Linux"],"categories":["鸟哥的Linux私房菜笔记"]},{"title":"学习Linux-什么是SELinux","url":"%2F2019%2F04%2F20%2FLinux%2F%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0%2F%E5%AD%A6%E4%B9%A0Linux-%E4%BB%80%E4%B9%88%E6%98%AFSELinux%2F","content":"\n### 1、什么是SElinux?\n{% codeblock %}\nselinux是由美国国家安全局开发的一种加载在内核的强制访问控制子系统（MAC），弥补自主访问控制（DAC）缺陷。\n{% endcodeblock %}\n### 2、SElinux运行模式\n{% codeblock %}\nselinux控制主体是进程，目标是文件系统，以targeted,strict两种策略限制访问\n除了策略限制外，还有安全上下文（放置在inode）限制，访问需要安全上下文一致。\n{% endcodeblock %}\n<!-- more -->\n##### 安全上下文\n{% codeblock %}\nls -Z :查看安全上下文\n安全上下文分三个字段：\n身份标识（identify）:root,system_u(系统进程),user_u（用户账号）\n角色（rule）：object_r（文件目录）,system_r（进程）\n类型（type）：type（文件资源）,domain（主体程序）\n{% endcodeblock %}\n### 3、SElinux的启动、运行、关闭与查看\n{% codeblock %}\n三种模式：enforcing：强制模式，premissive：宽容模式，disabled：关闭模式\ngetenforce：查看当前模式\nsestatus：列出当前使用策略\nvim /etc/selinux/config：修改模式与策略   注：改变策略后需要重新启动\nvim /boot/grub/menu.lst：查看内核中selinux有没关闭\nsetenforce 0 1 ：0为宽容模式，1为强制模式\n{% endcodeblock %}\n### 4、selinux网络服务运行\n##### 改变安全上下文\n{% codeblock %}\nchcon -R(连同子目录) -t（type） -u（user） -r（r0le） filename\nchcon -R --references=范例文件 文件 ：将文件安全上下文修改为范例文件的\nrestorecon -Rv 文件，目录：修改为默认安全上下文\n{% endcodeblock %}\n### 5、SElinux所需服务\n{% codeblock %}\nsettroubleshoot：将错误信息写入/var/log/messages，比较全面\nchkconfig on ：开机启动\nauditd：将详细数据写入/var/log/auditd/auditd.log\nauditd2why < /var/log/auditd/auditd.log：汇报查询的错误信息\n{% endcodeblock %}\n### 6、SElinux的策略与规则管理\n{% codeblock %}\nseinfo -A(all) -t(type) -r(role) -u(user) -b(bool值) ：查询策略提供的规则\nsesearch -a(all) -s(主体类型) -t(目标类型) -b(bool值) :查询相关的详细规则\ngetsebool -a(all) bool值 查询布尔值状态\nsetsebool -p bool=0|1 改变布尔值状态并写入配置文件\nsemanage foontext(用于安全上下文) -a(增加)|d（删除）|m（修改） -1\nsemanage foontext -a -t(type) 修改的类型 ：定制自定义类型 \n{% endcodeblock %}\n","tags":["Linux"],"categories":["鸟哥的Linux私房菜笔记"]},{"title":"什么是进程","url":"%2F2019%2F04%2F20%2FLinux%2F%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0%2F%E5%AD%A6%E4%B9%A0Linux-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%2F","content":"\n### 什么是进程？\n{% codeblock %}\n触发的二进制文件执行产生的\n{% endcodeblock %}\n\n##### 工作管理 job control\n{% codeblock %}\n“&” 将程序拉入后台进行\njobs -l -s -r：查看目前后台的工作状态\nfg %number ：将后天工作拉入前台\nbg %number ：运行在后台停止的进程\nkill -signal %number  -l -1 -2 -9（强制删除） -15（正常停止）\n{% endcodeblock %}\n<!-- more -->\n##### 脱机管理 :注销系统后继续工作\n{% codeblock %}\nnohup ：前台工作\nnohup & ：后台工作\n{% endcodeblock %}\n### 查看进程\n{% codeblock %}\nps aux（系统所有进程） -lA（系统数据） axjf（连同部分进程树状态）\ntop :动态查看进程变化\ntop -d（更新秒数） -b -p(指定pid)\npstree -A(ACSII) -U(utf8) -p(pid) -u(accounts)\nkillall -i（提示） -e -I（忽略大小写）\n{% endcodeblock %}\n\n### 进程优先级\n{% codeblock %}\nPRI(prority,优先级) NI（nice,调整优先级）\nnice 调整优先级，root修改范围为-20-19，user修改范围为0-19\nnice -n（number） command\nrenice:已存在进程的nice重新调整\nrenice -n(number) pid\n{% endcodeblock %}\n\n### 系统资源查看\n{% codeblock %}\nfree:查看内存使用情况\nfree -b(bytes) -k -m -g -t(物理内存与swap总量)\nuname -a(all) -s(kernel) -r(release) -m（硬件名称:x86_64） -p(cpu) -i（硬件平台：ix86）\nuptime:系统启动时间与工作负载\nnetstat:跟踪网络\nnetstat：-a(all) -t(tcp) -u(udp) -n(no name,list port number) -l(listening) -p(pid)\ndmesg:分析内核产生的信息\nvmstat:检测系统资源变化\nvmatat -a（总计检测次数） -fs（内存相关） -S(单位) -d（磁盘相关） -p（分区）\n{% endcodeblock %}\n##### SUID权限的命令的执行状态\n{% codeblock %}\nfind / -perm +6000 //查询系统SUID的文件\n/proc/\\*:存储内存数据 //p531-532页\n{% endcodeblock %}\n##### 查询已打开文件或执行程序打开文件\n{% codeblock %}\nfuser -umv -ki\nlsof:列出被进程所打开的文件名\nlsof -aUu +d(目录)\npidof -a(仅一个pid) -x(pid) program_name\n{% endcodeblock %}","tags":["Linux"],"categories":["鸟哥的Linux私房菜笔记"]},{"title":"学习Linux-系统服务","url":"%2F2019%2F04%2F19%2FLinux%2F%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0%2F%E5%AD%A6%E4%B9%A0Linux-%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%2F","content":"\n### 1、什么是daemon与服务(service)？\n{% codeblock %}\ndaemon是进程，服务是这个进程提供的\n{% endcodeblock %}\n\n### 2、daemon主要分类\n{% codeblock %}\nstand_alone：此daemon可以自行单独启动服务\nsuper daemon：一个特殊的daemon来统一管理\n注：个别窗口负责单一服务的stand_alone，统一窗口负责各种业务的super daemon\nsuper daemon处理方式：multi-threaded（多线程）,single-threaded（单线程）\ndaemon工作形态：single-control（信号管理，即时服务）,interval-control(隔段时间自动管理，例行性工作)\ndaemon命名规则：服务名称之后加d。\n{% endcodeblock %}\n\n<!-- more -->\n\n### 3、服务与端口的对应\n{% codeblock %}\n系统写入/etc/services\n{% endcodeblock %}\n\n### 4、daemon的启动脚本与启动方式\n\n{% codeblock %}\n\n放置处\n/etc/init.d/\\*:服务启动脚本放置处\n/etc/sysconfig/\\*:各服务的初始化环境配置文件\n/etc/xinetd.conf,/etc/xinetd.d/\\*:super daemon配置文件\n/etc/\\*：各服务各自的配置文件\n/var/lib/\\*：各服务产生的数据库放置处\n/var/run/\\*：各服务的程序的PID记录处\n启动脚本说明\n/etc/init.d/syslog start|stop|status|restart|condrestart\nservices (name) start|stop|status|--status-all\nsuper daemon在配置文件中设置为启动：grep disable /etc/xinetd.d/\\*  disable=yes，则取消\n{% endcodeblock %}\n\n\n### 5、服务的防火墙管理（xinetd, tcp wrappers）\n{% codeblock %}\n/etc/hosts.allow:允许的来自因特网的链接\n/etc/hosts.deny：拒绝的来自因特网的连接\nldd $(witch sshd)：查看sshd是否支持tcp wrappers的功能\n{% endcodeblock %}\n\n### 6、tcp wrappers特殊功能\n\n{% codeblock %}\n\n操作\nspawn：利用后续的shell进行额外的工作，支持变量:%h(hostname),%a(address),%d(daemon)\ntwist：立刻以后续的命令进行，且执行完后终止该次链接.\n{% endcodeblock %}\n\n### 7、系统开启的服务\n{% codeblock %}\nnetstat -tulp ：查看系统开启的网络服务\nnetstat -lnp ：找出监听的端口\n{% endcodeblock %}\n\n### 8、设置开机启动\n{% codeblock %}\n开机顺序\n打开计算机电源，读取MBR取得启动装载程序--》再取得kernel并加载内存且检测系统硬件--》调用init--》执行初始化(/etc/rc.d/rc.sysinit)--》进行daemonstart（/etc/rc.d/rc[0-6].d/\\*）--》加载本机设置（/etc/rc.d/rc.local）\nchkconfig：管理系统服务默认开机与否\nchkconfig --list --level[0123456:执行等级] 服务名称 on|off\nchkconfig --add --del 增加或删除一个服务给chkconfig管理\nntsysv：类图形界面管理模式\nntsysv --level 不同的执行等级\n{% endcodeblock %}"},{"title":"学习Linux-目标文件","url":"%2F2019%2F04%2F17%2FLinux%2F%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0%2F%E5%AD%A6%E4%B9%A0Linux-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%2F","content":"\n### 目标文件\n#### 定义\n{% codeblock %}\n计算机科学中存放目标代码的计算机文件,包含着机器代码，代码在运行时使用的数据，调试信息等，是从源代码文件产生程序文件这一过程的中间产物。\n{% endcodeblock %}\n\n#### 简介\n{% codeblock %}\n目标代码（objectcode）指计算机科学中编译器或汇编器处理源代码后所生成的代码，它一般由机器代码或接近于机器语言的代码组成。[1]目标文件（objectfile）即存放目标代码的计算机文件，它常被称作二进制文件（binaries）。\n目标文件包含着机器代码（可直接被计算机中央处理器执行）以及代码在运行时使用的数据，如重定位信息，如用于链接或调试的程序符号（变量和函数的名字），此外还包括其他调试信息。[2]目标文件是从源代码文件产生程序文件这一过程的中间产物，链接器正是通过把目标文件链接在一起来生成可执行文件或库文件。目标文件中唯一的要素是机器代码，例如，用于嵌入式系统的目标文件可能仅仅含有机器代码。\n{% endcodeblock %}\n\n<!--more -->\n\n#### 目标文件格式\n{% codeblock %}\n目标文件用以存放目标代码和由编译器或汇编器生成的相关数据的计算机文件格式称为目标文件格式。\n目标文件格式有许多不同的种类。最初每种类型计算机都拥有自身独特的格式，但随着Unix和其他可移植操作系统的问世，人们定义了例如COFF和ELF这些格式，并在不同的系统上使用它们。通常，链接器的输入和输出使用相同的文件格式，库文件和可执行文件格式也是一样使用相同的格式。\n设计或选择一种目标文件格式是计算系统整体设计的关键部分。它影响着链接器的性能并因此影响着程序员在开发时的总耗时；如果格式是用于可执行文件，那么格式的设计还会影响程序的开始运行花费的时间，以及影响到系统对用户请求的反应速度。大部分目标文件格式以区块的方式来组织，每一区块中都装载着同种数据。在虚拟内存系统需要这些块的时候，它可以通过将这些块分页后调入，无需进一步地处理就可使用。\n最简单的目标文件格式是DOS的COM文件格式，它是一种仅仅由原始数据组成的文件。COM格式的文件始终被加载到某固定位置。其他的格式都由一组复杂精密的数据结构序列组成，这些格式的规范说明书一般会有许多页。\n调试信息可以是目标文件格式中的一个组成部分，就像COFF中的那样，或是一种可能被数个目标格式使用的半独立格式，如stabs或DWARF。\nGNU计划的BFD库提供了一套通用的应用程序编程接口用来操纵各式各样的目标文件格式。\n典型的目标文件格式所支持的数据类型有：\n符号起始区块（BSSBlockStartedbySymbol的缩写）\n正文段（textsegment或译作代码段）\n数据段（datasegment）\n{% endcodeblock %}\n#### 主要格式\n##### DOS\n\n{% codeblock %}\nCOM\nEXE（MZ）\n可重定位目标模块格式（RelocatableObjectModuleFormat一般称作“OBJ文件”或“OMF”，也在微软视窗操作系统中被一些开发工具厂商所使用）\n{% endcodeblock %}\n##### 嵌入式系统\n{% codeblock %}\nIEEE-695\nS-records\nMacintosh\nPEF/CFM\n{% endcodeblock %}\n\n##### Unix\n{% codeblock %}\na.out（Unix/Linux）\nCOFF（SystemV）\nECOFF（Mips）\nXCOFF（AIX）\n可执行与可链接文件格式（SystemV缩写为ELF，用于大多数现代计算系统中）\nMach-O（NeXT，MacOSX）\n视窗（Windows）\n16位的NewExecutable\nPortableExecutable\n{% endcodeblock %}\n\n##### 其他\n{% codeblock %}\nIBM360目标格式\nNetWare可加载模块（NetWareLoadableModule缩写为NLM）\nOMF（VME）\nSOM（HP）\nXBE（Xbox的可执行文件格式）\nAPP（SymbianOS的可执行文件格式）\n可重定位动态目标文件格式（RelocatableDynamicObjectFileFormat缩写为RDOFF）\nHunk（AmigaOS）\n{% endcodeblock %}\n","tags":["Linux"],"categories":["鸟哥的Linux私房菜笔记"]},{"title":"学习Linux-X window system","url":"%2F2019%2F04%2F17%2FLinux%2F%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0%2F%E5%AD%A6%E4%B9%A0Linux-X-window-system%2F","content":"\n### X window system\n\n{% codeblock %}\n简介：是一套软件，不与硬件相关联。\n{% endcodeblock %}\n#### 组件\n{% codeblock %}\nx server\n管理硬件，读取硬件信息，将硬件操作传递给x client,并且接收x client传递的绘图数据，然后运用网络架构绘制屏幕图像。\n\nx client\n图形化的应用程序，也就是我们的桌面软件,接收x server传递的硬件操作信息，并产生绘图数据，告知x server画出什么样的图像。\n\nx window manager（优化x client）\nx client所绘制的图像非常简陋，需要x window manager优化图像，并提供许多控制元素，管理虚拟桌面，提供窗口控制参数。\n\ndisplay manager\n登录会话管理\n\n流程：x server读取硬件操作信息--》x client形成操作信息所需要的图像数据--》返回x server，并开始绘制屏幕图像（形成一个简陋的x窗口）--》x window manager优化x窗口形成用户能够使用的--》display manager形成登录界面，用户可以开始登录系统x图形界面。\n{% endcodeblock %}\n\n<!-- more -->\n\n#### x window 启动流程\n\n{% codeblock %}\n文字界面，利用startx这个shell script启动x图形界面。\nstartx启动流程：\n\n1、x server：startx+参数--》无参数，寻找用户根目录文件~/.xserverrc--》无，则寻找系统目录文件/etc/X11/xinit/xserverrc--》无，直接执行/usr/bin/X(可执行文件)\n\n2、x client：startx+参数--》无参数，寻找用户根目录文件~/.xinitrc--》无，则寻找系统目录文件/etc/X11/xinit/xinitrc--》无，直接执行xterm虚拟终端机。\n\n3、startx找到上述设置文件后，则调用xinit执行，实际启动X。\n{% endcodeblock %}\n\n#### x启动流程测试\n\n{% codeblock %}\nx :0 &(启动tty7，并且在后台执行)\n\nxterm -display :0 &(在x中启动虚拟终端机)\n\nxclock -display :0 &\n\nxeyes -displzy :0 &(启动其他x client)\n\nkill （关闭软件）\n\n\n{% endcodeblock %}\n\n#### x server设置文件解析\n\n{% codeblock %}\nSection \"name\"\n\n\t设置项目\n\nEndSection\n\n常见的name有：modules(加载的模块),inputdevice（输入的相关设备）,files（设置字体所在目录）,monitor（监视器格式）,device（显卡芯片组）,screen（屏幕显示的行为）,serverlayout（x server选择的选项）\n\nSection \"ServerLayout\"\n\n    Identifier \"layout\"\n    \n    Screen 0 \"nvidia\"\n    \n    Inactive \"intel\"\n\nEndSection\n\n\n\nSection \"Device\"\n\n    Identifier \"intel\"\n    \n    Driver \"intel\"\n    \n    BusID \"PCI:0@0:2:0\"\n    \n    Option \"AccelMethod\" \"SNA\"\n\nEndSection\n\n\n\nSection \"Screen\"\n\n    Identifier \"intel\"\n    \n    Device \"intel\"\n\nEndSection\n\n\n\nSection \"Device\"\n\n    Identifier \"nvidia\"\n    \n    Driver \"nvidia\"\n    \n    BusID \"PCI:4@0:0:0\"\n    \n    Option \"ConstrainCursor\" \"off\"\n\nEndSection\n\nSection \"Screen\"\n\n    Identifier \"nvidia\"\n    \n    Device \"nvidia\"\n    \n    Option \"AllowEmptyInitialConfiguration\" \"on\"\n    \n    Option \"IgnoreDisplayDevices\" \"CRT\"\n\nEndSection\n\n\n{% endcodeblock %}\n\n#### 设置文件重建与显示器参数微调\n\n{% codeblock %}\nxorg -configure :0 //重建设置文件，可以将改动的文件还原，避免设置错误\n\nx -config /root/xorg.conf.new :0 //测试新的设置文件是否顺利运行。\n\ngtf 水平像素 垂直像素 更新频率 -x（默认值） -v(检测过程)\n\n{% endcodeblock %}\n","tags":["Linux"],"categories":["鸟哥的Linux私房菜笔记"]},{"title":"学习Linux-逻辑卷管理器","url":"%2F2019%2F04%2F17%2FLinux%2F%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0%2F%E5%AD%A6%E4%B9%A0Linux-%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86%E5%99%A8%2F","content":"\n### 逻辑卷管理器\n{% codeblock %}\n１、PhysicalVolune,PV,物理卷\n实际分区需要调整系统标识符成为８e，经过pvcreate将它转化为LVM最底层的PV\n２、VoluneGroup,VG,卷用户组\n将PV整合为VG，VG是LVM组合的大磁盘，最大容量为２５６G  .\n３、PhysicalExtend,PE,物理扩展块\nPE是LVM的存储块，４M.与文件系统的block类比。\n４、LogicalVolune,LV,逻辑卷\n最后的VG会被切割成LV，也就是可以被格式化的分区。\n{% endcodeblock %}\n","tags":["Linux"],"categories":["鸟哥的Linux私房菜笔记"]},{"title":"学习Linux-例行性工作","url":"%2F2019%2F04%2F17%2FLinux%2F%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0%2F%E5%AD%A6%E4%B9%A0Linux-%E4%BE%8B%E8%A1%8C%E6%80%A7%E5%B7%A5%E4%BD%9C%2F","content":"\n\n### 什么是例行性工作？\n\n{% codeblock %}\n通过之前设置的设定，提醒用户或者执行命令或程序。\n工作调度种类\nat：处理仅执行一次就结束的工作调度命令，需要开启atd服务。\ncrontab：设置的工作将会循环一直进行，也可以编辑/etc/crontab支持，需要crond服务。\n{% endcodeblock %}\n\n<!--more-->\n\n### 常见例行性工作\n{% codeblock %}\n１、日志文件的轮替(log rotate)\n２、日志文件logwatch的任务\n记录软件问题、硬件错误。以邮件形式发送给root。\n３、新建locate的数据库\n放置在/var/lib/mlocate，系统自动updatedb\n４、what is数据库的建立\n与man page有的查询命令\n５、rpm软件日志文件的新建\n一种软件管理机制\n６、删除临时文件\n调用tmpwatch删除临时文件\n7、与网络服务有关的分析行为\n单一执行工作调度\nat命令与服务\n启动：/etc/init.d/atd resart\n开机启动：chkconfig atd on\n/etc/at.allow：允许的用户使用at\n/etc/at.deny：限制的用户使用at\natq：查看\natrm：删除\nbatch：规定空闲时执行的命令\n{% endcodeblock %}\n\n### 循环执行工作调度\n{% codeblock %}\ncrontab\n/etc/cron.allow：允许的用户使用此命令\n/etc/cron.deny：限制的用户使用此命令\n命令格式：分钟 小时 日期 月份 周 命令（mail 接受人 <文件）\n查询crontab内容：crontab -l\n删除全部：crontab -r\n系统配置文件：/etc/crontab（系统执行例行性任务）\n{% endcodeblock %}\n\n### 唤醒停机期间工作\n\n{% codeblock %}\nanaron会以一天、七天、一月为期检测系统未进行的crontab任务\n位置:/etc/anacrontab\n{% endcodeblock %}\n","tags":["Linux"],"categories":["鸟哥的Linux私房菜笔记"]},{"title":"学习Linux-备份","url":"%2F2019%2F04%2F17%2FLinux%2F%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0%2F%E5%AD%A6%E4%B9%A0Linux-%E5%A4%87%E4%BB%BD%2F","content":"### 备份文件\n\n#### 推荐备份目录\n\n{% codeblock %}\n/boot\n/etc\n/home\n/usr/local\n/var\n{% endcodeblock %}\n\n<!-- more -->\n\n#### 备份软件\n\n{% codeblock %}\ndd if=/dev/sda of=/dev/sdb //备份到sdb\nfind / -print | cpio -covB > /dev/sr0 //备份到磁带机\ndump -0u -f 预留磁盘 备份目录\ndump -1u -f 预留磁盘 备份目录 //第一次增量备份\ntar --exclude  目录 //备份\n{% endcodeblock %}\n","tags":["Linux"],"categories":["鸟哥的Linux私房菜笔记"]},{"title":"awesome配置文件","url":"%2F2019%2F04%2F17%2FLinux%2Fawesome%2Fawesome%2F","content":"\n#=====================================================\n# awesome配置文件\n#=====================================================\n```\n-- 说明：Screen 指屏幕，awesome支持多屏幕。 Tag 指标签，一个标签对应一个虚拟桌面。 Client 指程序窗口。\n-- {{{ 运行所需的库\n-- 标准awesome库\nlocal gears = require(\"gears\")\nlocal awful = require(\"awful\")\nawful.rules = require(\"awful.rules\")\nrequire(\"awful.autofocus\")\n-- 窗口和布局库\nlocal wibox = require(\"wibox\")\n-- 主题控制库\nlocal beautiful = require(\"beautiful\")\n-- 通知库\nlocal naughty = require(\"naughty\")\nlocal menubar = require(\"menubar\")\n-- 导入右键程序菜单模块\nrequire(\"debian.menu\")\n-- }}}\n\n-- {{{ 错误处理\n-- 检查awesome启动过程中是否发生错误\n-- 如果发生错误则启用最近的正确配置，并通知用户\nif awesome.startup_errors then\n    naughty.notify({ preset = naughty.config.presets.critical,\n                     title = \"Oops, there were errors during startup!\",\n                     text = awesome.startup_errors })\nend\n\n-- 处理awesome启动后的运行时错误\ndo\n    local in_error = false\n    awesome.connect_signal(\"debug::error\", function (err)\n        -- Make sure we don't go into an endless error loop\n        if in_error then return end\n        in_error = true\n\n        naughty.notify({ preset = naughty.config.presets.critical,\n                         title = \"Oops, an error happened!\",\n                         text = err })\n        in_error = false\n    end)\nend\n-- }}}\n\n-- {{{ 变量定义\n-- 主题定义：颜色、图标、字体、壁纸\nbeautiful.init(\"/usr/share/awesome/themes/default/theme.lua\")            -- 默认主题配置文件所在路径\n\n-- 设置默认的终端和文本编辑器\nterminal = \"mate-terminal\"\neditor = \"pluma\"\neditor_cmd = terminal .. \" -e \" .. editor\n\n-- 默认的modkey设置，用于快捷键。默认是Mod4，也就是Win键\n-- 通常，Mod4键位于键盘左侧的Ctrl和Alt键之间\n-- 如果你不喜欢这样的设置或者没有这个按键，\n-- 建议你使用xmodmap或者别的工具把Mod4键映射到别的按键\nmodkey = \"Mod4\"\n\n-- 默认的布局方式和顺序\n-- 可以手动调整顺序，可以删除不需要的布局方式（建议注释掉即可，以免以后再想使用）\nlocal layouts =\n{\n    awful.layout.suit.tile,                -- 平铺\n    awful.layout.suit.floating,         -- 浮动\n    awful.layout.suit.tile.left,\n    awful.layout.suit.tile.bottom,\n    awful.layout.suit.tile.top,\n    awful.layout.suit.fair,                -- 平铺，每个窗口大小一致\n    awful.layout.suit.max,                -- 最大化\n--  awful.layout.suit.fair.horizontal,\n--  awful.layout.suit.max.fullscreen,    -- 全屏\n--    awful.layout.suit.spiral,            -- 螺旋式\n    awful.layout.suit.magnifier         -- 放大\n}\n-- }}}\n\n-- {{{ 壁纸设置\nif beautiful.wallpaper then\n    for s = 1, screen.count() do\n        gears.wallpaper.maximized(\"/home/td/Pictures/background.jpg\", s, true)            -- 替代引号中图片路径即可\n    end\nend\n-- }}}\n\n-- {{{ 桌面标签\n-- 定义一个包含所有虚拟桌面的标签列表\ntags = {\n  names = {\"Internet\",\"Term\",\"Code\",\"Music\",5,6},                                        -- 桌面标签的名称\n  layout = {layouts[1],layouts[1],layouts[1],layouts[1],layouts[2],layouts[1]}            -- 标签默认布局，用索引表示，按照上面设置的layouts顺序\n}\nfor s = 1, screen.count() do\n    tags[s] = awful.tag(tags.names, s, tags.layout)\nend\n-- }}}\n\n-- {{{ 菜单\n-- myawesomemenu是mymainmenu主菜单的一项，这里包含3个子菜单，可以手动修改子菜单\n-- 还可以仿照myawesomemenu向主菜单添加新项，添加后务必加入下面的mymainmenu中\nmyawesomemenu = {\n   { \"edit config\", \"pluma /home/td/.config/awesome/rc.lua\" },        -- 这个子菜单用于修改awesome配置文件，pluma是一个简单的文本编辑器\n   { \"restart\", awesome.restart },\n   { \"quit\", awesome.quit }\n}\n-- mymainmenu主菜单\nmymainmenu = awful.menu({ items = { { \"awesome\", myawesomemenu, beautiful.awesome_icon },    -- 这里的awesome项添加上面的myawesomemenu\n                                    { \"应用程序\", debian.menu.Debian_menu.Debian },            -- 这是debian.menu模块自动生成的应用程序子菜单\n                                    { \"文件管理器\", \"caja /home/td/\" },                        -- 手动添加的项\n                                    { \"网络浏览器\", \"chromium-browser %u\" },                -- 手动添加的项\n                                    { \"open terminal\", terminal },\n                                    { \"重启电脑\", \"gksu reboot now\" },                        -- 手动添加的项\n                                    { \"关闭系统\", \"gksu 'shutdown -h now'\" },                -- 手动添加的项\n                                  }\n                        })\n\nmylauncher = awful.widget.launcher({ image = beautiful.awesome_icon,\n                                     menu = mymainmenu })\n\nmenubar.utils.terminal = terminal -- 应用终端，见上文默认终端设置\n-- }}}\n\n-- {{{ 窗口和布局\n-- 创建一个时钟部件\nmytextclock = awful.widget.textclock(\"%X\",1)\n\n-- 为每个屏幕创建一个wibox\nmywibox = {}\nmypromptbox = {}\nmylayoutbox = {}\nmytaglist = {}\nmytaglist.buttons = awful.util.table.join(\n                    awful.button({ }, 1, awful.tag.viewonly),\n                    awful.button({ modkey }, 1, awful.client.movetotag),\n                    awful.button({ }, 3, awful.tag.viewtoggle),\n                    awful.button({ modkey }, 3, awful.client.toggletag),\n                    awful.button({ }, 4, function(t) awful.tag.viewnext(awful.tag.getscreen(t)) end),\n                    awful.button({ }, 5, function(t) awful.tag.viewprev(awful.tag.getscreen(t)) end)\n                    )\nmytasklist = {}\nmytasklist.buttons = awful.util.table.join(\n                     awful.button({ }, 1, function (c)\n                                              if c == client.focus then\n                                                  c.minimized = true\n                                              else\n                                                  -- Without this, the following\n                                                  -- :isvisible() makes no sense\n                                                  c.minimized = false\n                                                  if not c:isvisible() then\n                                                      awful.tag.viewonly(c:tags()[1])\n                                                  end\n                                                  -- This will also un-minimize\n                                                  -- the client, if needed\n                                                  client.focus = c\n                                                  c:raise()\n                                              end\n                                          end),\n                     awful.button({ }, 3, function ()\n                                              if instance then\n                                                  instance:hide()\n                                                  instance = nil\n                                              else\n                                                  instance = awful.menu.clients({\n                                                      theme = { width = 250 }\n                                                  })\n                                              end\n                                          end),\n                     awful.button({ }, 4, function ()\n                                              awful.client.focus.byidx(1)\n                                              if client.focus then client.focus:raise() end\n                                          end),\n                     awful.button({ }, 5, function ()\n                                              awful.client.focus.byidx(-1)\n                                              if client.focus then client.focus:raise() end\n                                          end))\n\nfor s = 1, screen.count() do\n    -- 为每个屏幕创建一个信息框\n    mypromptbox[s] = awful.widget.prompt()\n    -- 在屏幕右上角显示目前正在使用的布局样式\n    mylayoutbox[s] = awful.widget.layoutbox(s)\n    mylayoutbox[s]:buttons(awful.util.table.join(\n                           awful.button({ }, 1, function () awful.layout.inc(layouts, 1) end),\n                           awful.button({ }, 3, function () awful.layout.inc(layouts, -1) end),\n                           awful.button({ }, 4, function () awful.layout.inc(layouts, 1) end),\n                           awful.button({ }, 5, function () awful.layout.inc(layouts, -1) end)))\n    -- 创建屏幕左上方的tag列表\n    mytaglist[s] = awful.widget.taglist(s, awful.widget.taglist.filter.all, mytaglist.buttons)\n\n    -- Create a tasklist widget\n    mytasklist[s] = awful.widget.tasklist(s, awful.widget.tasklist.filter.currenttags, mytasklist.buttons)\n\n    -- Create the wibox\n    mywibox[s] = awful.wibox({ position = \"top\", screen = s })\n\n    -- 左对齐的部件\n    local left_layout = wibox.layout.fixed.horizontal()\n    left_layout:add(mylauncher)\n    left_layout:add(mytaglist[s])\n    left_layout:add(mypromptbox[s])\n\n    -- 右对齐的部件\n    local right_layout = wibox.layout.fixed.horizontal()\n    if s == 1 then right_layout:add(wibox.widget.systray()) end\n    right_layout:add(mytextclock)\n    right_layout:add(mylayoutbox[s])\n\n    --\n    local layout = wibox.layout.align.horizontal()\n    layout:set_left(left_layout)\n    layout:set_middle(mytasklist[s])\n    layout:set_right(right_layout)\n\n    mywibox[s]:set_widget(layout)\nend\n-- }}}\n\n-- {{{ 鼠标绑定\nroot.buttons(awful.util.table.join(\n    awful.button({ }, 3, function () mymainmenu:toggle() end),\n    awful.button({ }, 4, awful.tag.viewnext),\n    awful.button({ }, 5, awful.tag.viewprev)\n))\n-- }}}\n\n-- {{{ 快捷键\nglobalkeys = awful.util.table.join(\n    awful.key({ modkey,           }, \"Left\",   awful.tag.viewprev       ),                -- 向左一个标签\n    awful.key({ modkey,           }, \"Right\",  awful.tag.viewnext       ),                -- 向右一个标签\n    awful.key({ modkey,           }, \"Escape\", awful.tag.history.restore),                -- 之前使用的标签\n\n    awful.key({ modkey,           }, \"j\",                                                -- 切换下一个窗口\n        function ()\n            awful.client.focus.byidx( 1)\n            if client.focus then client.focus:raise() end\n        end),\n    awful.key({ modkey,           }, \"k\",                                                -- 切换上一个窗口\n        function ()\n            awful.client.focus.byidx(-1)\n            if client.focus then client.focus:raise() end\n        end),\n    awful.key({ modkey,           }, \"w\", function () mymainmenu:show() end),            -- 显示主菜单，鼠标右键关闭\n\n    -- Layout manipulation\n    awful.key({ modkey, \"Shift\"   }, \"j\", function () awful.client.swap.byidx(  1)    end),        -- 当前窗口和前一个窗口互换位置\n    awful.key({ modkey, \"Shift\"   }, \"k\", function () awful.client.swap.byidx( -1)    end),        -- 当前窗口和后一个窗口互换位置\n    awful.key({ modkey, \"Control\" }, \"j\", function () awful.screen.focus_relative( 1) end),        -- 切换到下一个屏幕\n    awful.key({ modkey, \"Control\" }, \"k\", function () awful.screen.focus_relative(-1) end),        -- 切换到上一个屏幕\n--  awful.key({ modkey,           }, \"u\", awful.client.urgent.jumpto),\n    awful.key({ modkey,           }, \"Tab\",                    -- 切换到之前使用的窗口\n        function ()\n            awful.client.focus.history.previous()\n            if client.focus then\n                client.focus:raise()\n            end\n        end),\n\n    -- 标准程序\n    awful.key({ modkey,           }, \"Return\", function () awful.util.spawn(terminal) end),\n    awful.key({ modkey, \"Control\" }, \"r\", awesome.restart),                                        -- 重启awesome\n    awful.key({ modkey, \"Shift\"   }, \"q\", awesome.quit),                                        -- 退出awesome\n\n    awful.key({ modkey,           }, \"l\",     function () awful.tag.incmwfact( 0.05)    end),    -- 增加主区域宽度\n    awful.key({ modkey,           }, \"h\",     function () awful.tag.incmwfact(-0.05)    end),    -- 减少主区域宽度\n    awful.key({ modkey, \"Shift\"   }, \"h\",     function () awful.tag.incnmaster( 1)      end),    -- 增加主区域窗口数目\n    awful.key({ modkey, \"Shift\"   }, \"l\",     function () awful.tag.incnmaster(-1)      end),    -- 减少主区域窗口数目\n    awful.key({ modkey, \"Control\" }, \"h\",     function () awful.tag.incncol( 1)         end),\n    awful.key({ modkey, \"Control\" }, \"l\",     function () awful.tag.incncol(-1)         end),\n    awful.key({ modkey,           }, \"space\", function () awful.layout.inc(layouts,  1) end),    -- 按顺序切换布局样式\n    awful.key({ modkey, \"Shift\"   }, \"space\", function () awful.layout.inc(layouts, -1) end),    -- 反向切换布局样式\n\n    awful.key({ modkey, \"Control\" }, \"n\", awful.client.restore),\n\n    -- 启动器\n    awful.key({ modkey },            \"r\",     function () mypromptbox[mouse.screen]:run() end),        -- 默认，程序启动器\n--    awful.key({ modkey },            \"r\",     function () awful.util.spawn( \"dmenu_run\" ) end),        -- dmenu，程序启动器，需额外安装\n    -- 包含显式选项的启动器\n    awful.key({ modkey }, \"p\", function() menubar.show() end)\n)\n\nclientkeys = awful.util.table.join(\n    awful.key({ modkey,           }, \"f\",      function (c) c.fullscreen = not c.fullscreen  end),    -- 切换全屏/非全屏\n    awful.key({ modkey, \"Shift\"   }, \"c\",      function (c) c:kill()                         end),\n    awful.key({ modkey, \"Control\" }, \"space\",  awful.client.floating.toggle                     ),\n    awful.key({ modkey, \"Control\" }, \"Return\", function (c) c:swap(awful.client.getmaster()) end),\n    awful.key({ modkey,           }, \"o\",      awful.client.movetoscreen                        ),\n    awful.key({ modkey,           }, \"t\",      function (c) c.ontop = not c.ontop            end),    -- 标记当前窗口\n    awful.key({ modkey,           }, \"n\",        -- 最小化窗口\n        function (c)\n            -- The client currently has the input focus, so it cannot be\n            -- minimized, since minimized clients can't have the focus.\n            c.minimized = true\n        end),\n    awful.key({ modkey,           }, \"m\",        -- 最大化窗口\n        function (c)\n            c.maximized_horizontal = not c.maximized_horizontal\n            c.maximized_vertical   = not c.maximized_vertical\n        end)\n)\n\n-- 把数字键1到9绑定到对应的标签\nfor i = 1, 9 do\n    globalkeys = awful.util.table.join(globalkeys,\n        -- 转到指定窗口\n        awful.key({ modkey }, \"#\" .. i + 9,\n                  function ()\n                        local screen = mouse.screen\n                        local tag = awful.tag.gettags(screen)[i]\n                        if tag then\n                           awful.tag.viewonly(tag)\n                        end\n                  end),\n\n        awful.key({ modkey, \"Control\" }, \"#\" .. i + 9,\n                  function ()\n                      local screen = mouse.screen\n                      local tag = awful.tag.gettags(screen)[i]\n                      if tag then\n                         awful.tag.viewtoggle(tag)\n                      end\n                  end),\n        -- 把窗口移动到指定标签\n        awful.key({ modkey, \"Shift\" }, \"#\" .. i + 9,            -- 快捷键，注意需要先用 Mod4 + t 标记当前窗口\n                  function ()\n                      if client.focus then\n                          local tag = awful.tag.gettags(client.focus.screen)[i]\n                          if tag then\n                              awful.client.movetotag(tag)\n                          end\n                     end\n                  end),\n\n        awful.key({ modkey, \"Control\", \"Shift\" }, \"#\" .. i + 9,\n                  function ()\n                      if client.focus then\n                          local tag = awful.tag.gettags(client.focus.screen)[i]\n                          if tag then\n                              awful.client.toggletag(tag)\n                          end\n                      end\n                  end))\nend\n\nclientbuttons = awful.util.table.join(\n    awful.button({ }, 1, function (c) client.focus = c; c:raise() end),\n    awful.button({ modkey }, 1, awful.mouse.client.move),\n    awful.button({ modkey }, 3, awful.mouse.client.resize))\n\n-- 应用快捷键\nroot.keys(globalkeys)\n-- }}}\n\n-- {{{ 规则\n-- 设置部分程序启动时默认所在的屏幕和虚拟桌面，以及是否浮动（支持多屏幕，默认为屏幕1）\nawful.rules.rules = {\n    { rule = { },\n      properties = { border_width = beautiful.border_width,\n                     border_color = beautiful.border_normal,\n                     focus = awful.client.focus.filter,\n                     raise = true,\n                     keys = clientkeys,\n                     buttons = clientbuttons } },\n    { rule = { class = \"MPlayer\" },\n      properties = { floating = true } },        -- 设置mplayer启动时默认为浮动状态\n    { rule = { class = \"pinentry\" },\n      properties = { floating = true } },\n    { rule = { class = \"gimp\" },\n      properties = { floating = true } },\n-- 设置chromium浏览器启动时默认位于第一个屏幕的第一个标签\n    { rule = { class = \"Chromium-browser\" },\n      properties = { tag = tags[1][1] } },\n--  { rule = { class = \"Firefox\" },\n--    properties = { tag = tags[1][1] } },\n}\n-- }}}\n\n-- {{{ Signals\n-- 以下功能仅在新窗口出现时生效\nclient.connect_signal(\"manage\", function (c, startup)\n    -- Enable sloppy focus\n    c:connect_signal(\"mouse::enter\", function(c)\n        if awful.layout.get(c.screen) ~= awful.layout.suit.magnifier\n            and awful.client.focus.filter(c) then\n            client.focus = c\n        end\n    end)\n\n    if not startup then\n        -- Set the windows at the slave,\n        -- i.e. put it at the end of others instead of setting it master.\n        -- awful.client.setslave(c)\n\n        -- Put windows in a smart way, only if they does not set an initial position.\n        if not c.size_hints.user_position and not c.size_hints.program_position then\n            awful.placement.no_overlap(c)\n            awful.placement.no_offscreen(c)\n        end\n    elseif not c.size_hints.user_position and not c.size_hints.program_position then\n        -- Prevent clients from being unreachable after screen count change\n        awful.placement.no_offscreen(c)\n    end\n\n    local titlebars_enabled = false\n    if titlebars_enabled and (c.type == \"normal\" or c.type == \"dialog\") then\n        -- 标题栏的按钮\n        local buttons = awful.util.table.join(\n                awful.button({ }, 1, function()\n                    client.focus = c\n                    c:raise()\n                    awful.mouse.client.move(c)\n                end),\n                awful.button({ }, 3, function()\n                    client.focus = c\n                    c:raise()\n                    awful.mouse.client.resize(c)\n                end)\n                )\n\n        -- 左对齐的部件\n        local left_layout = wibox.layout.fixed.horizontal()\n        left_layout:add(awful.titlebar.widget.iconwidget(c))\n        left_layout:buttons(buttons)\n\n        -- 右对齐的部件\n        local right_layout = wibox.layout.fixed.horizontal()\n        right_layout:add(awful.titlebar.widget.floatingbutton(c))\n        right_layout:add(awful.titlebar.widget.maximizedbutton(c))\n        right_layout:add(awful.titlebar.widget.stickybutton(c))\n        right_layout:add(awful.titlebar.widget.ontopbutton(c))\n        right_layout:add(awful.titlebar.widget.closebutton(c))\n\n        -- 中间的标题\n        local middle_layout = wibox.layout.flex.horizontal()\n        local title = awful.titlebar.widget.titlewidget(c)\n        title:set_align(\"center\")\n        middle_layout:add(title)\n        middle_layout:buttons(buttons)\n\n        -- Now bring it all together\n        local layout = wibox.layout.align.horizontal()\n        layout:set_left(left_layout)\n        layout:set_right(right_layout)\n        layout:set_middle(middle_layout)\n\n        awful.titlebar(c):set_widget(layout)\n    end\nend)\n\nclient.connect_signal(\"focus\", function(c) c.border_color = beautiful.border_focus end)\nclient.connect_signal(\"unfocus\", function(c) c.border_color = beautiful.border_normal end)\n-- }}}\n\n```\n","categories":["configure"]},{"title":"Archlinux配置","url":"%2F2019%2F04%2F16%2FLinux%2FArchlinux%2FArchlinux%E9%85%8D%E7%BD%AE%2F","content":"\n{% codeblock lang:sh %}\n#=======================================================\n# 配置archlinux\n# archlinux-comfiguration需要下载到用户home目录\n#=======================================================\necho \"-------------------------------------------------------\"\necho \" 确认是否为archlinux系发行版\"\necho \"-------------------------------------------------------\"\nif which pacman > /dev/null ; then\n    echo \"该linux发行版是archlinux...\"\nelse\n    echo \"这个配置文件不适合这个发行版！,将退出安装...\"\n    exit\nfi\n\necho \"开始配置archlinux\"\n\necho \"-------------------------------------------------------\"\necho \"1 实用配置\"\necho \"-------------------------------------------------------\"\necho \"a 开始dns配置...\"\nsudo cp ./pacman/resolv.conf /etc/resolv.conf\nsudo chattr +a /etc/resolv.conf #追加权限，重新开机时不用重新修改\necho \"dns配置结束...\"\n\nsudo pacman -S git -y\necho \"b 开始下载配置文件...\"\ngit clone https://github.com/rack-leen/archlinux-comfiguration.git ~/\necho \"下载结束...\"\n\necho \"c 开始archlinux源配置...\"\nsudo mv /etc/pacman.d /etc/pacman.d.backup\nsudo rm -r /etc/pacman.d\nsudo cp -r ./pacman/pacman.d /etc/pacman.d\nsudo mv /etc/pacman.conf /etc/pacman.conf.backup\nsudo rm -r /etc/pacman.conf\nsudo cp -r ./pacman/pacman.conf /etc/pacman.conf\nsudo pacman -y -S yaourt archlinuxcn-keyring   #下载archlinuxcn密钥\nsudo pacman -y -Syyu  #更新系统\necho \"archlinux源配置结束...\"\n\necho \"d 设置字体\"\nsudo cp -r ~/archlinux-comfiguration/myfonts  /usr/share/fonts/\nsudo pacman -y -S adobe-source-code-pro-fonts wqy-bitmapfont wqy-microhei wqy-zenhei\necho \"设置结束...\"\n\necho \" e 设置声卡\"\nsudo cp -r ~/archlinux-comfiguration/alsamixer/asound.conf /etc/\necho \"设置结束...\"\n\necho \"urxvt配置\"\ntouch ~/.Xresources\necho \"xft.dpi:125 #设置dpi，对4k高分屏需要设置，设置成默认值的2倍试试。\" >> ~/.Xresources\necho \"URxvt.font: xft:Source Code Pro:antialias=True:pixelsize=18,xft:WenQuanYi Zen Hei:pixelsize=18\" >> ~/.Xresources\necho \"URxvt.boldfont: xft:Source Code Pro:antialias=True:pixelsize=18,xft:WenQuanYi Zen Hei:pixelsize=18\" >> ~/.Xresources\necho \"urxvt配置结束...\"\n\necho \"f 配置中文输入\"\nsudo pacman -y -S fcitx fcitx-configtool fcitx-googlepinyin fcitx-sogoupinyin\nsed -i \"4i #fcitx\" ~/.xprofile\nsed -i \"5i export GTK_IM_MODULE=fcitx\" ~/.xprofile\nsed -i \"6i export QT_IM_MODULE=fcitx\" ~/.xprofile\nsed -i \"7i export XMODIFIERS=@im=fcitx\" ~/.xprofile\nsed -i \"8i fcitx &\" ~/.xprofile\necho \"配置结束...\"\n\necho \"-------------------------------------------------------\"\necho \" 2 安装常用软件\"\necho \"-------------------------------------------------------\"\n\necho \" a 安装编译工具链\"\nsudo pacman -y -S cmake make gcc gdb autoconf\necho \"安装结束...\"\n\necho \" b 安装各个语言解释器\"\nsudo pacman -y -S perl ruby lua\necho \"安装结束...\"\n\necho \" c 安装常用工具\"\nsudo pacman -y -S axel vim curl wget links netease-cloud-music mplayer\necho \"安装结束...\"\n\necho \" d 安装命令行版musicbox\"\nsudo pacman -y -S python-pip python-setuptools python2-pip python2-setuptools mpg123\ncd ~/\ngit clone https://github.com/darknessomi/musicbox.git\ncd ./musicbox\nsudo python setup.py install\ncd ~/\nsudo rm -r musicbox\necho \"安装结束...\"\n\necho \" e 安装flash\"\ncp -r ~/archlinux-comfiguration/flash/flash ~/\nmkdir -p ~/.mozilla/plugin\ncp -r ~/archlinux-comfiguration/flash/libflashplayer.so\necho \"安装结束...\"\n\necho \"f 安装常用软件\"\nsudo pacman -y -S firefox firefox-i18n-zh-cn\nsudo pacman -y -S pycharm\nsudo pacman -y -S google-chrome\nsudo pacman -y -S wps-office\nsudo pacman -y -S libreoffice\nsudo pacman -y -S atom wiznote kodi rhythmbox\nsudo pacman -y -S gedit netease-cloud-music\necho \"安装结束...\"\n\necho \"g 安装oh-my-zsh\"\ncurl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh\necho \"安装结束...\"\n\necho \"h 安装spacemacs\"\ngit clone https://github.com/syl20bnr/spacemacs ~/.emacs.d\necho \"安装结束...\"\n\necho \"-------------------------------------------------------\"\necho \" 2 vim配置\"\necho \"-------------------------------------------------------\"\n#echo \"a 下载vim配置文件\"\n#cd ~/\n#git clone https://github.com/rack-leen/vim.git\n#mv vim ~/.vim\n#cp ~/.vim/vimrc ~/.vimrc\n#touch ~/1\n#echo \"vim安装正在进行，请耐心等候... \" > ~/1\n#vim 1 -c \"PluginInstall\" -c \"q\"\n#rm 1\necho \"a 安装vim发行版spf13-vim\"\ncurl https://j.mp/spf13-vim3 -L > spf13-vim.sh && sh spf13-vim.sh\necho \"个性化配置spf13-vim\"\ncp ~/archlinux-comfiguration/.vim.before.local ~/\ncp ~/archlinux-comfiguration/.vim.local ~/\nvim 1 -c \"BundleInstall\" -c \"q\"\nrm 1\necho \"安装结束...\"\n\necho \"b 安装youcompleteme插件\"\necho \"安装youcompleteme\"\nsudo pacman -y -S vim-youcompleteme-git\necho \"安装clang编译器\"\nsudo pacman -y -S clang extra/boost\necho \"编译\"\nmkdir ~/ycm_build\ncd ./ycm_build\nsudo cmake -G \"Unix Mkaefiles\" -DEXTERNAL_LIBCLANG_PATH=/usr/lib/libclang.so  ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp\nsudo cmake --build . --target ycm_core --config Release\ncp ~/archlinux-configuration/.ycm_extra_conf.py ~/.vim\nsudo rm -r ~/ycm_build\necho \"安装完成...\"\n\n\necho \"thank you\"\n\n{% endcodeblock %}\n","categories":["configure"]}]